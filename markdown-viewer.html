<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>xut | Apuntes</title>

  <link rel="stylesheet" href="assets/css/main.css">

  <!-- Markdown & highlight -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"
  />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

  <link rel="icon" type="img/png" href="https://avatars.githubusercontent.com/u/172497238?v=4">
</head>

<body>
  <!-- HEADER -->
  <header class="site-header">
    <div class="site-header-inner">
      <div class="site-left">
        <a class="site-brand" href="/" aria-label="xut - inicio">
          <span aria-hidden="true">✱</span>
          <span>xut</span>
        </a>
        <a id="toggle-index" class="site-link" href="#">Índice</a>
      </div>

      <nav class="site-nav" aria-label="Principal">
        <ul>
          <li><a href="/">Inicio</a></li>
          <li><a href="/sobre-mi.html">Sobre mí</a></li>
          <li><a href="https://github.com/xut-e" rel="noopener" target="_blank">GitHub</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <!-- LAYOUT -->
  <main class="page-shell">
    <!-- SIDEBAR -->
    <aside class="sidebar" id="indice">
      <h2 id="indice-label">Índice</h2>
      <div id="dynamic-index">
        <p>Cargando índice...</p>
      </div>
    </aside>

    <!-- CONTENIDO MARKDOWN -->
    <section class="markdown-body">
      <div id="breadcrumb" class="breadcrumb">Cargando ruta...</div>
      <h1 id="md-title">Cargando…</h1>

      <div id="md-content" style="font-size:.95rem; line-height:1.5;">
        Cargando contenido del apunte…
      </div>

      <div class="nav-buttons">
        <button id="prev-note" title="Anterior">&lt;</button>
        <button id="next-note" title="Siguiente">&gt;</button>
      </div>
    </section>
  </main>

  <!-- FOOTER -->
  <footer class="site-footer">
    <div class="site-footer-inner">
      <small>© <span id="year"></span> xut-e — Todos los derechos reservados</small>
      <pre class="ascii" aria-hidden="true">
             ..                      .....          
   .H88x.  :~)88:                 .H8888888h.  ~-.  
  x888888X ~:8888    x.    .      888888888888x  `> 
 ~   "8888X  %88"  .@88k  z88u   X~     `?888888hx~ 
      X8888       ~"8888 ^8888   '      x8.^"*88*"  
   .xxX8888xxxd>    8888  888R    `-:- X8888x       
  :88888888888"     8888  888R         488888>      
  ~   '8888         8888  888R       .. `"88*       
 xx.  X8888:    .   8888 ,888B .   x88888nX"      . 
X888  X88888x.x"   "8888Y 8888"   !"*8888888n..  :  
X88% : '%8888"      `Y"   'YP    '    "*88888888*   
 "*=~    `""                             ^"***"`    
      </pre>
    </div>
  </footer>

  <!-- AÑO -->
  <script>
    document.getElementById("year").textContent = new Date().getFullYear();
  </script>

  <!-- GENERAR ÍNDICE LATERAL -->
  <script src="assets/js/generate-index.js"></script>

  <!-- MOSTRAR / OCULTAR ÍNDICE -->
  <script>
  window.addEventListener("load", () => {
    const btn = document.getElementById("toggle-index");
    const aside = document.getElementById("indice");
    const pageShell = document.querySelector(".page-shell");
    if (!btn || !aside || !pageShell) return;

    // estado inicial respetando localStorage
    const isVisible = localStorage.getItem("indexVisible") === "true";
    if (isVisible) {
      aside.classList.remove("hidden");
      pageShell.classList.remove("full-width");
      btn.textContent = "Ocultar índice";
      btn.classList.add("active");
    } else {
      aside.classList.add("hidden");
      pageShell.classList.add("full-width");
      btn.textContent = "Mostrar índice";
      btn.classList.remove("active");
    }

    // toggle
    btn.addEventListener("click", e => {
      e.preventDefault();
      const hidden = aside.classList.contains("hidden");
      if (hidden) {
        aside.classList.remove("hidden");
        pageShell.classList.remove("full-width");
        btn.textContent = "Ocultar índice";
        btn.classList.add("active");
        localStorage.setItem("indexVisible", "true");
      } else {
        aside.classList.add("collapsing");
        pageShell.classList.add("full-width");
        btn.textContent = "Mostrar índice";
        btn.classList.remove("active");
        localStorage.setItem("indexVisible", "false");
        setTimeout(() => {
          aside.classList.remove("collapsing");
          aside.classList.add("hidden");
        }, 300);
      }
    });
  });
  </script>

  <!-- CARGA Y RENDER DE MARKDOWN (.md / .pdf / otros) -->
  <script>
  (async function () {
    const params = new URLSearchParams(window.location.search);
    const fileParam = params.get("file");
    const titleEl = document.getElementById("md-title");
    const contentEl = document.getElementById("md-content");

    if (!fileParam) {
      titleEl.textContent = "Sin archivo";
      contentEl.textContent = "No se ha especificado ningún archivo.";
      return;
    }

    // normalizar ruta a "content/...":
    const realPath = fileParam.startsWith("content/") ? fileParam : "content/" + fileParam;
    const lower = realPath.toLowerCase();

    // PDFs incrustados
    if (lower.endsWith(".pdf")) {
      const cleanName = realPath.split("/").pop().replace(/\.pdf$/i, "");
      titleEl.textContent = cleanName;
      contentEl.innerHTML = `<iframe src="${realPath}" width="100%" height="80vh" style="border:1px solid var(--border-color,#444)"></iframe>`;
      return;
    }

    // Markdown
    if (lower.endsWith(".md")) {
      try {
        const res = await fetch(realPath);
        if (!res.ok) throw new Error("No se pudo cargar el archivo");
        let mdText = await res.text();

        // título = primer H1 o nombre de archivo
        const lines = mdText.split("\n");
        const h1Match = lines[0]?.match(/^#\s+(.+)/);
        titleEl.textContent = h1Match
          ? h1Match[1].trim()
          : realPath.split("/").pop().replace(/\.md$/i, "");

        // markdown -> HTML
        mdText = marked.parse(mdText, { gfm: true, breaks: true });

        // imágenes estilo ![[foo.png]]
        mdText = mdText.replace(/!\[\[(.+?)\]\]/g, (m, p1) => {
          const src = decodeURIComponent(p1.trim());
          return `<img src="/content/Ciberseguridad/Z%20Imagenes/${encodeURIComponent(src)}" alt="${src}">`;
        });

        // abrir links externos en nueva pestaña
        mdText = mdText.replace(
          /<a href="(https?:\/\/[^"]+)">/g,
          '<a href="$1" target="_blank" rel="noopener">'
        );

        // inyectar
        contentEl.innerHTML = mdText;

        // resaltar bloques de código
        contentEl.querySelectorAll("pre code").forEach(b => hljs.highlightElement(b));
      } catch {
        titleEl.textContent = "Error";
        contentEl.textContent = "No se pudo cargar el archivo seleccionado.";
      }
      return;
    }

    // fallback para otros tipos
    titleEl.textContent = realPath.split("/").pop();
    contentEl.innerHTML = `<p>No sé mostrar este tipo de archivo todavía.</p>
      <p><a href="${realPath}" target="_blank" rel="noopener noreferrer">Abrir directamente</a></p>`;
  })();
  </script>

  <!-- ÍNDICE PERSISTENTE + BREADCRUMB + FLECHAS -->
  <script>
  window.addEventListener("DOMContentLoaded", async () => {
    const params = new URLSearchParams(window.location.search);
    const currentFile = params.get("file");
    const breadcrumbEl = document.getElementById("breadcrumb");
    const prevBtn = document.getElementById("prev-note");
    const nextBtn = document.getElementById("next-note");
    const aside = document.getElementById("indice");

    if (!currentFile) {
      breadcrumbEl.textContent = "(Sin ruta)";
      return;
    }

    try {
      const res = await fetch("apuntes/arbol.json");
      if (!res.ok) throw new Error("No se pudo cargar arbol.json");
      const data = await res.json();

      // aplana el árbol jerárquico a una lista ordenada de .md
      function flattenTree(node, path = "") {
        if (!node) return [];
        let files = [];
        if (Array.isArray(node)) {
          node.forEach(n => files.push(...flattenTree(n, path)));
        } else if (node.type === "directory") {
          const newPath = path ? `${path}/${node.name}` : node.name;
          if (node.name === "Z Imagenes") return files; // skip imágenes
          node.contents?.forEach(n => files.push(...flattenTree(n, newPath)));
        } else if (node.type === "file" && node.name.endsWith(".md")) {
          files.push(`${path}/${node.name}`); // path relativo estilo "THM/0. Pre Career/.../note.md"
        }
        return files;
      }

      const allFiles = flattenTree(data)
        .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));

      const normalizeForCompare = s =>
        s.replace(/\\/g, "/").replace(/%20/g, " ").toLowerCase();

      // localizar índice de la nota actual en allFiles
      const idx = allFiles.findIndex(f =>
        normalizeForCompare(currentFile).endsWith(normalizeForCompare(f))
      );

      // pintar breadcrumb bonito
      const parts = currentFile
        .replace(/^content\/?/i, "")
        .split("/")
        .filter(Boolean)
        .map(seg => seg.replace(/\.md$/i, ""))
        .map(seg => seg.replace(/-/g, " "))
        .map(seg =>
          seg.replace(/\b\w/g, c => c.toUpperCase())
        );
      breadcrumbEl.textContent = parts.join(" > ") || "(Sin ruta)";

      // helpers de normalización para el índice lateral
      function normalizePathLikeIndex(raw) {
        if (!raw) return "";
        let s = decodeURIComponent(raw);
        s = s.replace(/\\/g, "/").trim().replace(/\/{2,}/g, "/");
        if (!s.toLowerCase().startsWith("content/")) s = "content/" + s;
        return s.toLowerCase();
      }

      // resalta en el índice lateral la página actual
      function updateIndexHighlight(targetFileRaw) {
        const container = document.getElementById("dynamic-index");
        if (!container) return;

        const targetNorm = normalizePathLikeIndex(targetFileRaw);

        const links = container.querySelectorAll("a.tree-leaf");
        let currentLink = null;
        links.forEach(a => {
          const href = a.getAttribute("href") || "";
          const fileParam = href.split("?file=")[1] || "";
          const linkNorm = normalizePathLikeIndex(fileParam);
          if (linkNorm === targetNorm) currentLink = a;
        });
        if (!currentLink) return;

        // marca link activo
        container
          .querySelectorAll("a.tree-leaf.current-page")
          .forEach(el => el.classList.remove("current-page"));
        currentLink.classList.add("current-page");

        // colapsa todo...
        container.querySelectorAll("details").forEach(d => (d.open = false));

        // ...y reabre sólo la rama hasta la nota actual
        const opened = [];
        let parent = currentLink.closest("details");
        while (parent) {
          parent.open = true;
          const sum = parent.querySelector(":scope > summary");
          if (sum) opened.push(sum.textContent.trim());
          parent = parent.parentElement?.closest("details");
        }

        // persistir rama abierta y última nota
        localStorage.setItem("indexOpenBranches", JSON.stringify(opened));
        localStorage.setItem("indexLastFile", targetFileRaw);

        // scroll suave al elemento activo
        setTimeout(() => {
          currentLink.scrollIntoView({ behavior: "smooth", block: "center" });
        }, 100);
      }

      // esperar a que generate-index.js haya montado el índice en el DOM
      function waitForIndexThenHighlight(currentFileRaw) {
        let tries = 0;
        const interval = setInterval(() => {
          tries++;
          const ready = document.querySelectorAll("#dynamic-index a.tree-leaf").length > 0;
          if (ready) {
            clearInterval(interval);
            updateIndexHighlight(currentFileRaw);
          }
          if (tries > 60) clearInterval(interval);
        }, 150);
      }
      waitForIndexThenHighlight(currentFile);

      // Navegación con las flechas
      const goTo = i => {
        const target = allFiles[i];
        if (!target) return;
        localStorage.setItem("indexLastFile", target);
        // al navegar, simplemente cambiamos de página
        window.location.href = `markdown-viewer.html?file=${encodeURIComponent(target)}`;
      };

      if (idx > 0) {
        prevBtn.onclick = () => goTo(idx - 1);
      } else {
        prevBtn.disabled = true;
      }

      if (idx < allFiles.length - 1) {
        nextBtn.onclick = () => goTo(idx + 1);
      } else {
        nextBtn.disabled = true;
      }

      // respetar visibilidad previa del índice lateral
      const indexVisible = localStorage.getItem("indexVisible") === "true";
      if (indexVisible) {
        aside.classList.remove("hidden", "collapsing");
      } else {
        aside.classList.add("hidden");
      }

    } catch (err) {
      console.error("💥 Error índice/breadcrumb/navegación:", err);
      breadcrumbEl.textContent = "(Error al generar ruta)";
    }
  });
  </script>

  <!-- RESALTADO VERDE + SCROLL CUANDO VENIMOS DESDE SEARCH -->
  <script>
  document.addEventListener("DOMContentLoaded", () => {
    const params = new URLSearchParams(window.location.search);
    const q = params.get("q");
    if (!q) return; // si no venimos desde la búsqueda, no hacemos nada

    // normaliza texto (quita acentos, pasa a minúsculas)
    function normalize(str) {
      return str
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .toLowerCase();
    }

    // resalta TODAS las apariciones de query dentro de #md-content,
    // sin destruir event listeners ni machacar todo el innerHTML
    function highlightInElement(root, query) {
      const normQuery = normalize(query);
      if (!normQuery) return;

      // recorremos todos los nodos de texto dentro de root
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);
      const textNodesToProcess = [];

      while (walker.nextNode()) {
        const node = walker.currentNode;
        const original = node.textContent;
        const normOriginal = normalize(original);

        if (normOriginal.includes(normQuery)) {
          textNodesToProcess.push({ node, original, normOriginal });
        }
      }

      textNodesToProcess.forEach(({ node, original, normOriginal }) => {
        const normQueryLen = normQuery.length;
        const ranges = [];
        let searchStart = 0;

        // localizar TODAS las posiciones donde aparece la query normalizada
        while (true) {
          const idx = normOriginal.indexOf(normQuery, searchStart);
          if (idx === -1) break;
          ranges.push([idx, idx + normQueryLen]);
          searchStart = idx + normQueryLen;
        }

        if (!ranges.length) return;

        // construir HTML seguro con <mark> envolviendo cada match
        let resultHTML = "";
        let lastPos = 0;
        ranges.forEach(([start, end]) => {
          resultHTML += original.slice(lastPos, start)
            + "<mark>"
            + original.slice(start, end)
            + "</mark>";
          lastPos = end;
        });
        resultHTML += original.slice(lastPos);

        // reemplazar el nodo de texto por un span con ese HTML
        const span = document.createElement("span");
        span.innerHTML = resultHTML;
        node.parentNode.replaceChild(span, node);
      });
    }

    // hace scroll a la primera coincidencia y la hace parpadear en verde
    function focusFirstMatch(container) {
      const first = container.querySelector("mark");
      if (!first) return;
      first.scrollIntoView({ behavior: "smooth", block: "center" });
      first.animate(
        [
          { backgroundColor: "rgba(102,161,130,0.8)" },
          { backgroundColor: "rgba(102,161,130,0.25)" }
        ],
        { duration: 1200, easing: "ease-out" }
      );
    }

    // esperamos a que el markdown esté realmente cargado en #md-content
    function waitUntilContentReady() {
      const contentEl = document.getElementById("md-content");
      if (!contentEl) return;

      const obs = new MutationObserver((mutList, observer) => {
        // contenido ya está cargado (no es el placeholder "Cargando...")
        const txt = contentEl.innerText.trim();
        if (txt && !/^Cargando/i.test(txt)) {
          observer.disconnect();

          // aplicar resaltado
          highlightInElement(contentEl, q);

          // hacer scroll y destello
          focusFirstMatch(contentEl);
        }
      });

      obs.observe(contentEl, { childList: true, subtree: true });
    }

    waitUntilContentReady();
  });
  </script>
</body>
</html>

