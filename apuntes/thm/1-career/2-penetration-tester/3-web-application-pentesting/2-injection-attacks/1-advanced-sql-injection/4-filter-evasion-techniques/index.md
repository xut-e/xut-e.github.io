---
layout: apunte
title: "4. Filter Evasion Techniques"
---

En los ataques de inyección SQL avanzados, evadir filtros es crucial para explotar las vulnerabilidades exitosamente. Las aplicaciones web modernas normalmente implementan medidas defensivas para sanitizar o bloquear patrones de ataque comunes, haciendo los intentos de inyección SQL simple inefectivos. Para esto debemos adaptarnos y llevar a cabo técnicas más sofisticadas. Esta sección cubrirá estos métodos incluyendo encoding de caracteres, inyección SQL sin commillas y cómo manejar escenarios donde no podemos usar espacios.

--------------------------------------
<h2>Character Encoding</h2>
Involucra convertir caracteres especiales en el payload de inyección SQL en formas encodeadas que puedan sobrepasar filtros.

- **URL Encoding:** El encodding URL es un método común donde los caracteres se representan usando un porcentaje seguido de su valor en hexadecimal ASCII. Por ejemplo el payload `'OR 1=1--` puede encodearse como `%27%20OR%201%3D1--`.
- **Hexadecimal Encoding:** Es otra técnica efectiva para construir queries SQL usando valores hexadecimales. Por ejemplo, la query `SELECT * FROM users WHERE name = 'admin'` puede ser encodeada como `SELECT * FROM users WHERE name = 0x61646d696e`.
- **Unicode Encoding:** Representa caracteres usando las secuencias de escape Unicode. Por ejemplo, la string `admin` puede ser encodeada como `\u0061\u0064\u006d\u0069\u006e`.

<h4>Ejemplo</h4>
En este ejemplo exploraremos cómo los desarrolladores pueden implementar filtros para prevenir los ataques de inyección SQL eliminando ciertas palabras clave y caracteres del input del usuario. También veremos cómo los atacantes pueden sobrepasarlos usando técnicas de encodeado.

Aquí está el código PHP (`search_books.php`) que maneja la funcionalidad de buscado.

```php
$book_name = $_GET['book_name'] ?? '';
$special_chars = array("OR", "or", "AND", "and" , "UNION", "SELECT");
$book_name = str_replace($special_chars, '', $book_name);
$sql = "SELECT * FROM books WHERE book_name = '$book_name'";
echo "<p>Generated SQL Query: $sql</p>";
$result = $conn->query($sql) or die("Error: " . $conn->error . " (Error Code: " . $conn->errno . ")");
if ($result->num_rows > 0) {
    while ($row = $result->fetch_assoc()) {
...
..
```

Este es el código Javascript en el `index.html` que ofrece la interfaz para la búsqueda de libros.

```javascript
function searchBooks() {
const bookName = document.getElementById('book_name').value;
const xhr = new XMLHttpRequest();
xhr.open('GET', 'search_books.php?book_name=' + encodeURIComponent(bookName), true);
   xhr.onload = function() {
       if (this.status === 200) {
           document.getElementById('results').innerHTML = this.responseText;
```

En el ejemplo de arriba, el desarrollador ha implementado un mecanismo de defensa básico para prevenir los ataques de inyección SQL eliminando palabras clave específicas como `OR`, `AND`, `UNION` y `SELECT`. El filtro usa la función `str_replace`, la cual extrae estas palabras claves del input del usuario antes de incluirlas en la query SQL. Este acercamiento de filtro busca hacer más difícil a los atacantes inyectar comandos SQL maliciosos, ya que estas palabras claves son esenciales para dichos ataques.

-------------------------------------------
<h2>Preparing the Payload</h2>
Caminemos por el proceso de preparar un payload de inyección SQL paso a paso, mostrando cómo el encodeado URL puede sobrepasar defensas básicas. Primero, veamos qué ocurre con un input normal que contiene caracteres especiales o palabras clave SQL. 

!**Pasted image 20260103131048.png**

Pero ¿qué pasa si tratamos de añadir `'` o `;`? Obtendremos el siguiente output.

!**Pasted image 20260103131126.png**

La query SQL no se está ejecutando correctamente lo que probablemente significa que hay una probabilidad de SQLi. Intentemos inyectar el payload `Intro to PHP' OR 1=1`.

!**Pasted image 20260103131225.png**

Lo que está pasando aquí es que el script PHP está usando la función `str_replace` que extrae la palabra clave `OR` y la comilla simple, resultando en un input sanitizado que no ejecutará la inyección SQL intentada. Este input es inefectivo porque el filtro elimina los componentes críticos necesarios.

Para sobrepasar el filtro necesitamos encodear el input usando encodeade URL, el cual representa caracteres especiales y palabras clave en una forma en la que el filtro no reconoce ni elimina estas. Aquí está el payload de ejemplo `1%27%20||%201=1%20--+`.

- `%27`:
- `%20`: 
- `||`: 
- `%3D`: 
- `%2D%2D`: 

En el payload de arriba `1'` cierra el valor o string actual de la query SQL. Por ejemplo, si la query busca un nombre de libro que coincida con `1`, añadiendo `'` cerramos la string, haciendo al resto del inputparte del statement SQL. La parte `|| 1=1` usa el operador `OR` SQL para añadir una condición que siempre es `true`. 