---
layout: apunte
title: "3. Types of SSRF - Basic"
---

El SSRF básico es una técnica de ataque web donde un atacante engaña al servidor para que haga peticiones en su ppropio nombre, normalmente a sistemas internos o a servicios de terceros. Explotando las vulnerabilidades en la validación de input, el atacante puede ganar acceso no autorizado a información sensible o control sobre recursos remostos.

Un SSRF básico puede emplearse contra un servidor local o interno. exploraremos ambos escenarios en detalle.

----------------------------------------
<h2>Escenario 1: SSRF Contra un Servidor Local</h2>

En este ataque, el atacante hace una petición no autorizada al servidor que hostea la aplicación web. El atacante da una dirección IP loopback o localhost para obtener la respuesta. La vulnerabilidad surge debido a cómo la aplicación maneja el input para formar la query o llamada a la API.

Por ejemplo, en la aplicación HRMS, hay una funcionalidad que carga páginas adicionales basado en un parámetro URL. Por ejemplo, navegar a `http://hrms.thm?url=localhost/copyright` cargaría una página de copyright de la aplicación. Esta funcionalidad está hecha para uso interno y está diseñada para pedir y mostrar páginas del servidor local (usando por ello `localhost` en la query).

Sin embargo, debido a validación insuficiente en el input URL, un atacante puede manipular esta funcionalidad para hacer un ataque SSRF. Cambiando el parámetro de la URL para apuntar a otra página/servicio, el atacante puede forzar que el servidor HRMS haga peticiones a donde él quiera. Por ejemplo, si el atacante usa una URL como `http://hrms.thm/?url=localhost/config` y `config` es una página válida, el servidor HRMS intentará cargar el contenido de esta página y cargar el resultado..

La idea principal es suplantar una petición legítima y hacer que el servidor realice una ación que no debería.

<h4>Cómo Funciona</h4>
- Supón que te han mandado hacer un pentest en el sitio web HRMS e identificar cualquier agujero de SSRF que veas. Visita el sitio web `http://hrms.thm` y verás que la página de login está protegida mediante un usuario y contraseña.
  !**Pasted image 20260122133737.png**
- Vemos que una vez que visitamos la página `http://hrms.thm`, automáticamente nos redirige a `http://hrms.thm/?url=localhost/copyright`. La página web muestra el estado del copyright de la web.
  !**Pasted image 20260122133829.png**
- Esto significa que el desarrollador probablemente ha incurrido en algunos errores al manejar un archivo que muestra el estado del copyright. Aquí está el código de la página que toma los parámetros.

```php
$uri = rtrim($_GET['url'], "/");
...					
$path = ROOTPATH . $file;
...
if (file_exists($path)) {
  echo "<pre>";
  echo htmlspecialchars(file_get_contents($path));
  echo "</pre>";
  } else { ?>
    <p class="text-xl"><?= ltrim($file, "/") ?> is not found</p>
 <?php
... 
```

- Podemos ver que en el código de arrina el parámetro `url` no tiene el filtrado adecuado y carga lo que el parámetro le pase desde `localhost`.
- Intentaremos cambiar la URL a `http://hrms.thm/?url=localhost/hello`. Muestra un error: `hello.php is not found`.
  !**Pasted image 20260122134059.png**
- Así que la página llama a un archivo PHP y lo muestra en el footer de la página actual. ¿Qué pasa si llamamos a archivos sensibles como `connection.php` o `config.php`?
- Cuando intentamos acceder al archivo `http://hrms.thm/?url=localhost/config`, veremos que el footer muestra el contenido de esta página.

```php
<?php 
$adminURL = "xxxxxxx";
$username = "xxxxx"; 
$password = "xxxx"; 
...
?>
```

