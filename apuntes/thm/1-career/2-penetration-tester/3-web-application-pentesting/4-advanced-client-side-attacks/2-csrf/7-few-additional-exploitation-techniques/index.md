---
layout: apunte
title: "7. Few Additional Exploitation Techniques"
---

<h2>Explotación XMLHttpRequest</h2>
En el contexto de una petición AJAX, CSRF es como si alguien estuviera haciendo que tu navegador mandara una petición sin saberlo a una web en la que estás logueado. Es como si alguien engañara a tu navegador para hacer algo en un sitio confiado por ti sin que lo supieras, potencialmente causando acciones no intencionadas o cambios en tu cuenta. Los ataques CSRF pueden resultar exitosos incluso cuando las peticiones AJAX están sujetas a [Same-Origin Policy (SOP)](https://en.wikipedia.org/wiki/Same-origin_policy), lo que suele prohibir las peticiones cross-origin.

!**Pasted image 20260218113136.png**

Aquí tienes un ejemplo de cómo un atacante puede actualizar una contraseña en `mybank.thm` y mandar una petición asíncrona para actualizar el email a la vez.

```javascript
<script>
	var xhr = new XMLHttpRequest();
	xhr.open('POST', 'http://mybank.thm/updatepassword', true);
	xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
	xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
	xhr.onreadystatechange = function () {
		if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
			alert("Action executed!");
		}
	};
	xhr.send('action=execute&parameter=value');
</script>
```

La XMLHttpRequest en el código de arriba está diseñada para subir un formulario de información al servidor e incluir headers personalizados. El proceso completo de mandar peticiones será único ya que las peticiones se realizan en JavaScript usando AJAX.

--------------------------------
<h2>Same Origin Policy (SOP) y Cross-Origin Resource Sharing (CORS) Bypass</h2>
El bypasseo de CORS y SOP para lanzar un CSRF es como un atacante usando un truco para hacer que tu navegador mande peticiones a diferentes sitios web en los que estás. Bajo una política CORS errónea, ciertas peticiones podrían ser subidas por orígenes reconocidos. Sin embargo, las configuraciones erróneas en las políticas CORS pueden permitir a los atacantes circunvalar estas limitaciones si confían en orígenes que el atacante puede controlar o si las credenciales son incluidas en peticiones en peticiones cross.origin.

```php
<?php // Server-side code (PHP)
 header('Access-Control-Allow-Origin: *'); 
// Allow requests from any origin (vulnerable CORS configuration) .
..// code to update email address ?>
```

Este es un script simple en PHP del lado del servidor que maneja las peticiones POST. Tiene una configuración de CORS vulnerable (`Access-Control-Allow-Origin:*`), permitiendo peticiones de cualquier origen, siendo vulnerable a CSRF ya que no implementa medidas anti-CSRF. El uso de este header depende del caso de uso y requerimientos. Hay escenarios donde permitir peticiones de diferentes orígenes es necesario y legítimo, como en APIs públicas o redes de distribución de contenido. Sin embargo, es crucial considerar cuidadosamente las implicaciones en cuanto a seguridad y asegurar que **Access-Control-Allow-Credentials** esté bien configurado para aceptar sólo orígenes confiables. Es importante saber que `Access-Control-Allow-Origins:*` y `Access-Control-Allow-Credentials:true` no pueden ser usados juntos por restricciones de seguridad impuestas por la [Especificación de CORS](https://fetch.spec.whatwg.org/#cors-protocol-and-credentials).

-------------------------------------
<h2>Referer Header Bypass</h2>
Al hacer peticiones HTTP, el header referer contiene el URL de la última página que el usuario visitó antes de hacer la petición actual. Algunos sitios web se protegen contra CSRF permitiendo sólo las queries si el header referer coincide con su dominio. La utilidad de esto como protección única contra CSRF se reduce cuando este header se modifica o se cambia, como ocurre con las extensiones de navegador instaladas por el usuario, herramientas de privacidad o etiquetas meta que le dicen al servidor que omitan el referer.

