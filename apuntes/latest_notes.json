[
  {
    "title": "3. How ORM Works",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/6-orm-injection/3-how-orm-works/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/6. ORM Injection/3. How ORM Works.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 6. ORM Injection",
    "content": "<h2>Mapear Entre Objetos en el Código y Tablas de Bases de Datos</h2>\nORM es una técnica que simplifica la interacción de información en una aplicación mapeando objetos en el código a tablas de bases de datos. En PHP, este proceso involucra definir clases que representen tablas de bases de datos y sus relaciones, Cada clase corresponde a una columna en la tabla, y cada instancia de clase representa una fila.\n\nPor ejemplo, usando Laravel's Eloquent ORM, puedes definir una clase modelo así:\n\n```php\nnamespace App\\Models;\nuse Illuminate\\Database\\Eloquent\\Model;\nclass User extends Model\n{\n    protected $table = 'users';\n    protected $fillable = [\n        'name', 'email', 'password',\n    ];\n    // Other Eloquent model configurations can go here...\n}\n```\n\nEn este ejemplo, la clase `User` se mapea a la tabla `user` en la base de datos, con propiedades correspondiendo a las columnas. Eloquent ORM maneja la traducción entre estas representaciones de objetos y las queries SQL subyacentes, permitiendo a los desarrolladores manipular registros de bases de datos usando sintaxis orientada a objetos.\n\n----------------------------------------\n<h2>Operaciones ORM Comunes (Create, Read, Update, Delete)</h2>\nLas operaciones comunes de bases de datos en frameworks ORM, comúnmente conocidas como CRUD:\n\n- **Create:** Crear nuevos registros en la base de datos involucra instanciar un nuevo objeto modelo, configurando sus propiedades y guardándolo en la base da datos.\n  \n```php\nuse App\\Models\\User;\n\n// Create a new user\n$user = new User();\n$user->name = 'Admin';\n$user->email = 'admin@example.com';\n$user->password = bcrypt('password'); \n$user->save();\n```\n  \n  Este código crea un nuevo usuario y lo guarda en la base de datos. El método de guardado prepara la entidad para su inserción y ejecuta el statement SQL INSERT para añadir un nuevo registro en la tabla users. La función `bcrypt()` es usada para hashear de forma segura la contraseña antes de guardarla.\n- **Read:** Leer los registros de la base de datos involucra recuperar información usando varios métodos de Eloquent.\n  \n```php\nuse App\\Models\\User;\n\n// Find a user by ID\n$user = User::find(1);\n\n// Find all users\n$allUsers = User::all();\n\n// Find users by specific criteria\n$admins = User::where('email', 'admin@example.com')->get();\n```\n  \n  Este código demuestra formas diferentes de recuperar registros de la base de datos. La función `find(1)` recupera el usuario con ID 1 ejecutando el statement SQL SELECT. La función `all()` recupera todos los usuarios ejecutando `SELECT * FROM users`. La cláusula `where('email', 'admin@example.com')->get()` recupera los usuarios con el email especificado ejecutando `SELECT * FROM users WHERE emai = 'admin@example.com'`.\n\nDe forma similar a las operaciones create y read, las funcionalidades delete y update siguen un enfoque similar. Para actualizaciones recuperas el registro existente, lo modificas y guardas los cambios. Para borrados recuperas el registro y llamas al método delete para eliminarlo de la base de datos. \n\n------------------------------------------------\n<h2>Comparando la Inyección SQL y ORM</h2>\nLa inyección SQL y ORM son ambas técnicas usada para explotar vulnerabilidades en las interacciones de las bases de datos, pero tienen como objetivos diferentes niveles del stack:\n\n- **SQL Injection:** Apunta a queries SQL, permitiendo a los atacantes manipular statements SQL directamente. Esto se consigue inyectando input malicioso en la string query. La parte de inyección en la siguiente query, `OR '1'='1`, siempre evalúa en true.\n\n```php\nSELECT * FROM users WHERE username = 'admin' OR '1'='1';\n```\n\n- **ORM Injection:** Apunta al framework ORM explotando cómo se construyen las queries desde las operaciones de objetos. Los atacantes manipulan los métodos ORM y propiedades para influenciar las queries SQL resultantes.\n  \n ```php\n $userRepository->findBy(['username' => \"admin' OR '1'='1\"]);\n ```\n  \n  En el código de arriba, la parte de la inyección, `admin' OR '1'='1`, siempre se evalúa en true.\n\n------------------------------------------\n<h2>Diferencias Clave en Técnicas de Explotación</h2>\n\n| **Aspecto**        | **SQL Injection  <br>**                                                   | **ORM Injection**                                                                                                              |\n| ------------------ | ------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |\n| Nivel de Inyección | Apunta a queries SQL raw directamente                                     | Apunta a la construcción de queries del framework ORM                                                                          |\n| Complejidad        | Más directo ya que manipula SQL                                           | Requiere entendimiento de cómo funcionan los métodos internos de ORM                                                           |\n| Detección          | Más fácil de detectar con WAFs tradicionales y registros query            | Más difícil detectar ya que los payloads están en métodos ORM                                                                  |\n| Mitigación         | Uso de statements preparados, queries parametrizadas, validación de input | Configuración ORM correcta, validación de input a nivel de aplicación, funcionalidades ORM reforzando la seguridad de la query |\n\n----------------------------------------------\n<h2>Configurando el Entorno</h2>\nYa que estamos usando Laravel para este proyecto, explicaremos brevemente cómo configurar Eloquent ORM (Laravel-Based). Eloquent ORM es el ORM por defecto de Laravel, que ofrece una implementación de `Active Record` simple y bonita para trabajar con tu base de datos. Primero, debemos instalar Laravel usando Composer. Abre tu terminal y ejecuta el comando `composer create-project --prefer-dist laravel/laravel thm-project`, donde `thm-project` es el nombre del proyecto. No necesitas hacer estos pasos, es sólo para ayudarte a entender cómo funciona.\n\n<h4>Configurar las Credenciales de la Base de Datos</h4>\nDespués necesitamos configurar nuestras credenciales. Laravel usa el archivo `.env` para almacenar las variables de entorno, incluyendo credenciales. Abre el archivo `.env` en la raíz de tu proyecto Laravel y actualiza las siguientes líneas con los detalles de tu base de datos.\n\n```php\nDB_CONNECTION=mysql\nDB_HOST=127.0.0.1\nDB_PORT=3306\nDB_DATABASE=your_database_name\nDB_USERNAME=your_database_user\nDB_PASSWORD=your_database_password\n```\n\n<h4>Configurar Migraciones</h4>\nLas migraciones son el control de versiones de tu base de datos, permitiéndote modificar y compartir fácilmente el esquema de la base de datos. El sistema de migración de Laravel es una parte esencial del framework y simplifica el manejo de los cambios en la base de datos.\n\n<h4>Crear una Migración</h4>\nPara crear una migración, podemos usar el comando `Artisan` que viene con Laravel. Puedes ejecutar el comando `php artisan make:migration create_users_table --create=users` para generar una migración para la tabla `users`.\n\nEste comando genera un archivo de migración en el directorio de base de datos/migración. El archivo de migración contiene métodos para definir la estructura de la tabla `users`.\n\n```php\n<?php\nuse Illuminate\\Database\\Migrations\\Migration;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Support\\Facades\\Schema;\nclass CreateUsersTable extends Migration\n{\n    public function up()\n    {\n        Schema::create('users', function (Blueprint $table) {\n            $table->id();\n            $table->string('name');\n            $table->string('email')->unique();\n            $table->string('password');\n            $table->timestamps();\n        });\n    }\n    public function down()\n    {\n        Schema::dropIfExists('users');\n    }\n}\n```\n\nEn el código de arriba, el método `up()` define la estructura de la tabla `users`. Por el contrario, `down()` dropea la tabla `users` si se revierte la migración.\n\nDespués de definir la migración, ejecuta el comando `php artisan migrate` para aplicar la migración y crear la tabla `users` en la base de datos. Este comando ejecutará `up()` en el archivo de migración y creará la tabla `users` con las columnas especificadas en la base de datos.\n\nEn el contexto de ORM, las migraciones simplifican el proceso de mapear las tablas de la base de datos para modelos de aplicación. Sin embargo, desde el punto de vista de un red teamer, migraciones mal configuradas pueden llevar a vulnerabilidades como ORM injection.",
    "modified": "2026-01-16T00:55:48"
  },
  {
    "title": "2. Understanding ORM",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/6-orm-injection/2-understanding-orm/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/6. ORM Injection/2. Understanding ORM.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 6. ORM Injection",
    "content": "<h2>¿Qué es ORM?</h2>\nORM es una técnica de programación que facilita la conversión de información entre sistemas incompatibles usando lenguajes de programación orientados a objetos. Permite a los desarrolladores interactuar con la base de datos usando la sintaxis nativa del lenguaje de programación haciendo la manipulación de información más intuitiva y reduciendo la necesidad de queries SQL extensas. ORM es particularmente beneficioso cuando se requieren interacciones de información complejas, ya que simplifica el aceso a la base de datos y promueve al reutilización de código.\n\n![[Pasted image 20260115123955.png]]\n\n----------------------------------------------\n<h2>Propósito</h2>\nORM sirve como un puente entre el modelo de programación orientado a objetos y el modelo de base de datos relacional. El propósito principal de un ORM es abstraer la capa de base de datos, permitiendo a los desarrolladores trabajar con objetos en lugar de tablas y filas. Esta capa de abstracción ayuda en:\n\n- **Reducir el Código Boilerplate:** ORM reduce la necesidad de código repetitivo generando automáticamente queries SQL basadas en operaciones con objetos.\n- **Incrementar Productividad:** Los desarrolladores pueden centrarse en la lógica de negocio sin preocuparse por las interacciones de la base de datos.\n- **Asegurar Consistencia:** Los frameworks ORM manejan consistentemente las operaciones de la base de datos reduciendo el riesgo de errores.\n- **Mejorar el Mantenimiento:** Los cambios al esquema de la base de datos son más fáciles de manejar, ya que pueden ser reflejados en el modelo del objeto sin modificaciones de código excesivas.\n\n-----------------------------------------------\n<h2>Frameworks ORM Comúnmente Usados</h2>\nVarios frameworks son ampliamente usados en la comunidad de desarrollo, cada uno refiriéndose a diferentes lenguajes de programación y entornos. Aquí hay algunos ejemplos:\n\n<h4>Doctrine (PHP)</h4>\nDoctrine es un framework ORM poderoso y flexible para PHP. Es particularmente popular en el framework Symfony pero puede ser usado independientemente. Doctrine ofrece un conjunto de herramientas para interacciones con las bases de datos. Su habilidad de mapear estructuras complejas en esquemas de bases de datos lo hace el favorito de los desarrolladores PHP.\n<h4>Hibernate (Java)</h4>\nEs un framework ORM maduro y robusto para aplicaciones Java. Simplifica el mapeo de clases Java a tablas de bases de datos y ofrece una capabilidad de recuperación y manipulación de información a través de Hibernate Query Language (HQL). \n<h4>SQLAlchemy (Python)</h4>\nSQLAlchemy es un framework ORM versátil y poderoso para Python. Ofrece un toolkit SQL y un sistema ORM que permite a los desarrolladores usar SQL crudo cuando se necesite sin perder las ventajas de un ORM.\n<h4>Entity Framework (C#)</h4>\nEs un framework ORM de Microsoft para aplicaciones .NET. Permite a los desarrolladores trabajar con información relacional usando objetos de dominio específicos, eliminando la necesidad de la mayoría de código de acceso que los desarrolladores típicamente suelen tener que escribir.\n<h4>Active Record (Ruby on Rails)</h4>\nEs el framework ORM por defecto para aplicaciones Ruby on Rails. Sigue el patrón de diseño Active Record, lo que signidica que cada tabla en la base de datoos corresponde a una clase y cada fila en la tabla corresponde a una clase y cada fila a una instancia de dicha clase.",
    "modified": "2026-01-16T00:55:48"
  },
  {
    "title": "1. Introduction",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/6-orm-injection/1-introduction/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/6. ORM Injection/1. Introduction.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 6. ORM Injection",
    "content": "Con los avances en ciber seguridad, muchos desarrolladores han adoptado un object-relational mapping (ORM) para mitigar los ataques de inyección SQL. Aqunque ORM pretende simplificar las interacciones de las bases de datos y mejorar la seguridad, la amenaza de los ataques de inyección no ha acabado. ORM Injection ocurre cuando los atacantes explotan vilnerabilidades en frameworks ORM, permitiéndoles ejecutar queries arbitrarias. Exploraremos técnicas de inyección ORM avanzadas.\n\n----------------------------------------\n<h2>Objetivos de Aprendizaje</h2>\nA lo largo de esta unidad ganarás un entendimiento profundo de los siguientes conceptos:\n\n- ORM\n- Identificar inyecciones\n- Implementación débil\n- Implementación vulnerable\n\n---------------------------------------\n<h2>Pre-requisitos</h2>\n- [[Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/3. Introduction to Web Hacking/11. SQL Injection/0. SQL Injection]]\n- [[Ciberseguridad/THM/0. Pre Career/2. Cyber Security 101/8. Web Hacking/5. OWASP Top 10 - 2021/0. OWASP Top 10 - 2021]]",
    "modified": "2026-01-16T00:55:48"
  },
  {
    "title": "4. Injection Fundamentals",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/5-ldap-injection/4-injection-fundamentals/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/5. LDAP Injection/4. Injection Fundamentals.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 5. LDAP Injection",
    "content": "La inyección LDAP es una vulnerabilidad de seguridad crítica que ocurre cuando el input de un usuario no se sanitiza correctamente antes de incorporarlo en queries LDAP. \n\nLa inyección LDAP explota la forma en la que las aplicaciones web construyen queries LDAP. Cuando el input del usuario se añade directamente en estas queries sin una correcta sanitización y validación, los atacantes pueden inyectar  statements LDAP maliciosos.\n\nEl proceso es parecido al de la SQLi, donde se inyectan statements SQL maliciosos para manipular las operaciones de las bases de datos.\n\n------------------------------------------------\n<h2>Vectores de Ataques Comunes</h2>\n1. **Bypass de Autentificación:** Modificar las queries de autentificación LDAP para iniciar sesión con otro usuario sin saber su contraseña.\n2. **Acceso no Autorizado a Datos:** Alterar queries de búsqueda LDAP para recuperar informacióon sensible que no debería poder ser accedida.\n3. **Manipulación de Datos:** Inyectar queries que modifican el directorio LDAP, como añadir o modificar atributos de usuario.\n\n----------------------------------------------\n<h2>Proceso de Injección</h2>\nHacer un ataque de inyección LDAP requiere varios pasos clave, desde identificar el punto de inyección hasta explotar la vulnerabilidad.\n\n![[Pasted image 20260115095813.png]]\n\nEste diagrama ilustra la interacción entre el atacante, la aplicación web y el servidor LDAP durante uno de estos ataques.",
    "modified": "2026-01-16T00:55:48"
  },
  {
    "title": "5. Exploiting LDAP",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/5-ldap-injection/5-exploiting-ldap/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/5. LDAP Injection/5. Exploiting LDAP.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 5. LDAP Injection",
    "content": "La inyección LDAP puede ser particularmente peligrosa al ser explotada en sus mecanismos de autentificación. Los atacantes pueden manipular las queries LDAP para bypassear controles de seguridad ganando acceso a aplicaciones. \n\nPor ejemplo, debajo está un trozo de código PHP simplificado usado en una aplicación web para la autentificación de usuarios en el servidor LDAP.\n\n```php\n<?php\n$username = $_POST['username'];\n$password = $_POST['password'];\n\n$ldap_server = \"ldap://localhost\";\n$ldap_dn = \"ou=People,dc=ldap,dc=thm\";\n$admin_dn = \"cn=tester,dc=ldap,dc=thm\";\n$admin_password = \"tester\"; \n\n$ldap_conn = ldap_connect($ldap_server);\nif (!$ldap_conn) {\n    die(\"Could not connect to LDAP server\");\n}\n\nldap_set_option($ldap_conn, LDAP_OPT_PROTOCOL_VERSION, 3);\n\nif (!ldap_bind($ldap_conn, $admin_dn, $admin_password)) {\n    die(\"Could not bind to LDAP server with admin credentials\");\n}\n\n// LDAP search filter\n$filter = \"(&(uid=$username)(userPassword=$password))\";\n\n// Perform the LDAP search\n$search_result = ldap_search($ldap_conn, $ldap_dn, $filter);\n\n// Check if the search was successful\nif ($search_result) {\n    // Retrieve the entries from the search result\n    $entries = ldap_get_entries($ldap_conn, $search_result);\n    if ($entries['count'] > 0) {\n        foreach ($entries as $entry) {\n            if (is_array($entry)) {\n                if (isset($entry['cn'][0])) {\n                    $message = \"Welcome, \" . $entry['cn'][0] . \"!\\n\";\n                }\n            }\n        }\n    } else {\n        $error = true;\n    }\n} else {\n    $error = \"LDAP search failed\\n\";\n}\n?>\n```\n\nEste código es vulnerable porque inserta directamente el input proporcionado por el usuario (`$username` y `$password`) en la query LDAP sin sanitizar ni escapar.\n\nPara explotar esta vulnerabilidad, un atacante puede subir un nombre de usuario con un filtro LDAP malicioso. Por ejemplo, el atacante podría usar un nomber de usuario como `*`, lo que traducido a la query LDAP siempre se evalúa como `true`.\n\nEsta query autentificará exitosamente si hay algún usuario en el directorio LDAP, ya que la condición inyectada `uid=*` siempre será `true`.\n\n---------------------------------------------\n<h2>Técnicas de Bypass de Autentificación</h2>\n<h4>Tautology-Based Injection</h4>\nLa inyección basada en tautología (repetición innecesaria y poco afortunada) involucra insertar condiciones en una query LDAP que son inherentemente ciertas, asegurando así que la query devuelve `true`. Este método es particularmente efectivo contra queries construuídas con el input del usuario sin sanitizar correctamente. Considera una query de autentificación LDAP donde el username y password se insertan desde el input del usuario.\n\n```php\n(&(uid={userInput})(userPassword={passwordInput}))\n```\n\nUn atacante podría ofrecer un input tautology-based, como `*)(|(&` para `userInput}` y `pwd)` para `{passwordInput}`, lo que transforma la query en:\n\n```php\n(&(uid=*)(|(&)(userPassword=pwd)))\n```\n\nEsta query bypassea la comprobación de la contraseña debido a cómo los operadores lógicos se usan en el filtro. La query consiste en dos partes, uso combinado y el operador AND (`&`).\n\n1. `(uid=*)`: Esta parte del filtro coincide con cualquier entrada con un atributo `uid`, es decir, todos los usuarios.\n2. `(|(&)(userPassword=pwd))`: El operador OR (`|`) significa que cualquiera de las dos condiciones dentro necesita ser `true` para sobrepasar el filtro. En LDAP, una condición AND (`&`)vacía se considera siempre true. La otra condición comprueba si el atributo `userPassword` coincide con el valor `pwd`, que fallará si el usuario no usa `pwd` como contraseña.\n\nPoniéndolo todo junto, la segunda parte del filtro `(|(&)(userPassword=pwd))` siempre será true debido a la condición `(&)`. El operador OR sólo necesita que una de sus condiciones sea true, por lo que el OR entero es true sin importar la contraseña.\n\n<h4>Wildcard Injection</h4>\nlos wildcards (`*`) se utilizan en las queries LDAP para coincidir con cualquier secuencia de caracteres, haciéndolos herramientas poderosas para búsquedas amplias. Sin embargo, cuando el input del usuario que contiene wildcards no se sanitiza correctamente, puede llevar a resultados de query no intencionados, como bypassear la autentificación. Por ejemplo, si la query de búsqueda se ve así:\n\n```php\n(&(uid={userInput})(userPassword={passwordInput}))\n```\n\nUn atacante piede usar un wildcard como input en ambos `uid` y `password`. Usar `*` en el nomber de usuario puede hacer que la query ignore nombres específicos y se centre en la password. Sin embargo al haber un wildcard (`*`) presente en la contraseña, no valida el contenido de esta contra un valor esperado. En su lugar sólo comprueban la existenca del atributo `userPassword` sin importar su contenido.\n\nEsto significa que la query devolverá un resultado positivo para cualquier usuario sin verificar que la contraseña dada durante el proceso de autentificación coincide con la contraseña guardada.\n\n------------------------------------------------------------\n<h2>Ejemplo de Bypasseo de Autentificación</h2>\nPara demostrar un ataque simple de inyección LDAP, ve a `http://IP/normal.php`. Basado en el código de arriba, la aplicación construye una query LDAP para la autentificación basada en el input del usuario sin la sanitización adecuada.\n\nUn atacante puede explotar esto subiendo un username y una password con un caracter que la aplicación no espera, como un asterisco para los atributos uid y userPassword. Esto hace que la condición siempre se evalue en true, bypasseando la comprobación de contraseña.\n\n<h4>Username y Password Inyectados</h4>\n```php\nusername=*&password=*\n```\n\n![[Pasted image 20260115111936.png]]\n\n<h4>Componente Resultante de Query LDAP</h4>\n```php\n(&(uid=*)(userPassword=*))\n```\n\n![[Pasted image 20260115112003.png]]\n\nEsta inyección siempre hace que la condición de la query LDAP sea true. Sin embargo, usar sólo el caracter `*` resultará siempre en el primer resultado. Para apuntar a información específica, el atacante puede usar un payload como `f*`, lo que buscará un `uid` que comience por `f`.\n\n![[Pasted image 20260115112140.png]]",
    "modified": "2026-01-16T00:55:48"
  }
]