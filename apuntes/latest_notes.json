[
  {
    "title": "2. Modern Frontend Frameworks",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/4-advanced-client-side-attacks/3-dom-based-attacks/2-modern-frontend-frameworks/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/4. Advanced Client-Side Attacks/3. DOM-Based Attacks/2. Modern Frontend Frameworks.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 4. Advanced Client-Side Attacks > 3. DOM-Based Attacks",
    "content": "<h2>En los Viejos Tiempos</h2>\nEl último apunte teórico antes de adentrarnos en los ataques basados en DOM son los frameworks de frontend modernos. Aplicaciones web convencionales donde el DOM entero se actualiza con cada petición.\n\nCada vez que un usuario navega una sección diferente de la web, la respuesta dada ofrece un código HTML diferente y el DOM reconstruido desde cero. Sin embargo, esto reducía la responsividad de las aplicaciones web.\n\n--------------------------------------\n<h2>El Auge de los Tiempos Modernos</h2>\nCon el auge de los frameworks modernos, se dio a luz a un nuevo modelo de aplicación llamado Single Page Application (SPA). Las SPAs son cargadas una única vez cuando el usuario visita el sitio web por primera vez y todo el código se carga en el DOM. Usando JavaScript, en lugar de recargar el DOM con cada nueva petición, el DOM se actualiza automáticamente.\n\nEn lugar de recargar el DOM con cada petición, las respuestas sólo contienen la información requerida para actualizar el DOM. Esto reduce drásticamente el tiempo de espera de cada petición (aunque la primera carga pueda tardar más).\n\nLos frameworks de frontend modernos como Angular, React y Vue permiten a los desarrolladores crear estas SPAs. En lugar de que el servidor sea responsable del DOM, el SPA es cargado una vez y luego las interfaces a través de peticiones a la API. Aunque esto incrementa la responsividad, puede llevar a vulnerabilidades por configuración pobre.\n\n----------------------------------------\n<h2>Confusión del Límite de Seguridad</h2>\nEl primer error común es confundir donde están las fronteras de seguridad. Hay un dicho común en la seguridad de aplicaciones que dice: \"Los controles del lado del cliente son sólo para la experiencia del usuario, todos los controles de seguridad deben de estar del lado del servidor\".\n\nNo entender este principio suele conllevar a bypasses de autorización. Un ejemplo de esto es cuando los desarrolladores deshabilitan el botón editar en JavaScript. Sin embargo, como puedes alterar el DOM en tu navegador, puedes rehabilitarlo y hacer la petición, bypasseando la autorización. Aunque hace una mejor experiencia de usuario tener el botón deshabilitado, se necesita una comprobación del lado del servidor.\n\n-----------------------------------------\n<h2>Validación Insuficiente del Input del Usuario</h2>\nEl segundo error común es no validar suficiente el input del usuario. Esto suele pasar cuando los equipos de desarrollo del frontend y el backend no se comunican para precisar quién toma la responsabilidad de qué controles de seguridad. El equipo de frontend suele implementar filtros para sanitizar o validar el input del usuario antes de mandar la respuesta al servidor. Sin embargo, el equipo del backend debe realizar las mismas comprobaciones y la sanitización de dicho input. Lo que pasa es que el equipo de backend suele mandar la información raw, esperando que el frontend haga validaciones.\n\nEsto suele derivar en que ninguno de los dos equipos tome la responsabilidad de la validación del input. Como cada equipo espera que el otro se encargue de la seguridad, suele acabar con brechas de seguridad permitiendo ataques como XSS o CSRF. Esto en los días modernos puede derivar en que el input introducido en la aplicación A sea inocuo para la aplicación A, pero la aplicación B puede pensar que el input ya ha sido sanitizado y por consiguiente creando un agujero por donde los atacantes se meten.",
    "modified": "2026-02-22T01:07:55"
  },
  {
    "title": "1. The DOM Explained",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/4-advanced-client-side-attacks/3-dom-based-attacks/1-the-dom-explained/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/4. Advanced Client-Side Attacks/3. DOM-Based Attacks/1. The DOM Explained.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 4. Advanced Client-Side Attacks > 3. DOM-Based Attacks",
    "content": "Antes de que profundicemos en ataques basados en DOM, necesitamos explicar lo que es el DOM. DOM se refiere al Document Object Model, que es la interfaz de programación que muestra el documento de web. Cuando haces una petición a una aplicación web, el HTML de respuesta se carga como DOM en el navegador. En esencia, el DOM es la vista de programación de la aplicación web que el usaurio ve en su navegador. Una vez cargado, JavaScript puede interferir con el DOM y hacer actualizaciones a cosas que el usuario ve.El DOM tiene estructura de árbol, permitiendo a los desarrolladores usar JavaScript para buscar o modificar elementos específicos. Veamos un ejemplo práctico.\n\n```html\n<html>\n    <head>\n        <title>Hello World!</title>\n    </head>\n    <body>\n        <h1> Hello Moon! </h1>\n        <p> The earth says hello! </p>\n    </body>\n</html>\n```\n\nSi quieres jugar con el DOM, puedes copiar el código de arriba a un archivo llamado `index.html` y abrirlo usando tu navegador. El elemento `document` siempre es la cabeza del tree. El subtree `html` es donde todo el código HTML de la página cargada vive, la cual es dividida entre `head` y `body`. Puedes ver el DOM usando las herramientas de desarrollador integradas en el navegador.\n\n![[Pasted image 20260218164203.png]]\n\nUsando las herramientas de desarrollador, también podemos interferir con el JavaScript por consola y usar esto para modificar el DOM. Por ejemplo, podríamos crear un nuevo elemento en el DOM usando las siguientes instrucciones:\n\n1. Haz click en el botóon `Console`.\n2. Crea un nuevo párrafo: `const paragraph = document.createElement(\"p\");`\n3. Crea un nuevo nodo de texto: `const data  = document.createTextNode(\"Our new text\");\n4. Añade el texto al nuevo  párrafo: `paragraph.appendChild(data)`\n5. Encuentra el párrafo existente y añádele el nuevo párrafo: `document.getElementsByTagName(\"p\")[0].appendChild(paragraph);`\n6. Tu nuevo texto debería ser cargado como se muestra abajo.\n\n![[Pasted image 20260218164929.png]]\n\nAquí es donde está el poder de los ataques basados en DOM. Si conseguimos inyectar en el DOM, podemos alterar lo que ve el usuario o incluso tomar acciones como el usuario, efectivamente suplantando su identidad. Esto se volvió un problema significativamente mayor con los frameworks de aplicaciones web modernas donde el control sobre el DOM no significa sólo control sobre una sóla página sino persistencia en toda la aplicación web.",
    "modified": "2026-02-19T01:09:18"
  },
  {
    "title": "8. Defence Mechanisms",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/4-advanced-client-side-attacks/2-csrf/8-defence-mechanisms/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/4. Advanced Client-Side Attacks/2. CSRF/8. Defence Mechanisms.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 4. Advanced Client-Side Attacks > 2. CSRF",
    "content": "CSRF juega un rol crítico para los pentesters, permitiéndoles simular ataques donde los usuarios ejecutan acciones no autorizadas sin querer en sitios confiables. Explotando vulnerabilidades CSRF, los pentesters pueden evaluar la efectividad de las defensas de una aplicación contra peticiones falseadas, identificar agujeros de seguridad potenciales en el manejo de sesiones y evaluar la robustez de las medidas anti-CSRF implementadas.\n\n--------------------------------\n<h2>Pentesters/Red Teamers</h2>\n- **CSRF Testing:** Testear aplicaciones activamente en busca de vulnerabilidades CSRF intentando ejecutar acciones no autorizadas a través de peticiones manipuladas.\n- **Validación de Fronteras:** Evaluar los mecanismos de validación de la aplicación, asegurando que el input del usuario es validado apropiadamente y hay tokens anti-CSRF implementados.\n- **Análisis de Headers de Seguridad:** Evalúa la presencie y efectividad de headers de seguridad, como CORS y referer, para mejorar la seguridad y prevenir diferentes vectores de ataque.\n- **Testeo de Manejo de Sesiones:** Examina los mecanismos de gestión de sesiones de la aplicación, asegurando que los tokens de sesión se generan, transmiten y validan de forma segura.\n- **Escenarios de Explotación CSRF:** Explora varios escenarios de explotación CSRF, como incrustar peticiones en tags de imágenes o explotar endpoints no confiables.\n\n----------------------------------\n<h2>Desarrolladores</h2>\n- **Tokens Anti-CSRF:** Integra tokens anti-CSRF en cada formulario o petición.\n- **Atributo SameSite-Cookie:** Configura el atributo SameSite a Strict o Lax para controlar cuando las cookies se mandan en peticiones cross-site.\n- **Política de Referer:** Implementa una política referer estricta, limitando la información divulgada en el header referer.\n- **Content Security Policy (CSP):** Utiliza CSP para definir y reforzar una política que especifique las fuentes confiadas del contenido, mitigando el riesgo de inyectar scripts maliciosos en las webs.\n- **Patrón de Subida de Cookies Dobles:** Implementa un patrón de doble subida de cookies donde el CSRF se guarde tanto en la cookie como en el parámetro de petición. El servidor comprueba ambos para autentificar las peticiones.\n- **Implementación de CAPTCHAS:** Incorpora retos CAPTCHA como capa adicional de defensa contra ataques CSRF especialmente en la autentificación del usuario, subida de formularios y procesos de creación de cuentas.",
    "modified": "2026-02-19T01:09:18"
  },
  {
    "title": "7. Few Additional Exploitation Techniques",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/4-advanced-client-side-attacks/2-csrf/7-few-additional-exploitation-techniques/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/4. Advanced Client-Side Attacks/2. CSRF/7. Few Additional Exploitation Techniques.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 4. Advanced Client-Side Attacks > 2. CSRF",
    "content": "<h2>Explotación XMLHttpRequest</h2>\nEn el contexto de una petición AJAX, CSRF es como si alguien estuviera haciendo que tu navegador mandara una petición sin saberlo a una web en la que estás logueado. Es como si alguien engañara a tu navegador para hacer algo en un sitio confiado por ti sin que lo supieras, potencialmente causando acciones no intencionadas o cambios en tu cuenta. Los ataques CSRF pueden resultar exitosos incluso cuando las peticiones AJAX están sujetas a [Same-Origin Policy (SOP)](https://en.wikipedia.org/wiki/Same-origin_policy), lo que suele prohibir las peticiones cross-origin.\n\n![[Pasted image 20260218113136.png]]\n\nAquí tienes un ejemplo de cómo un atacante puede actualizar una contraseña en `mybank.thm` y mandar una petición asíncrona para actualizar el email a la vez.\n\n```javascript\n<script>\n\tvar xhr = new XMLHttpRequest();\n\txhr.open('POST', 'http://mybank.thm/updatepassword', true);\n\txhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n\txhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\txhr.onreadystatechange = function () {\n\t\tif (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {\n\t\t\talert(\"Action executed!\");\n\t\t}\n\t};\n\txhr.send('action=execute&parameter=value');\n</script>\n```\n\nLa XMLHttpRequest en el código de arriba está diseñada para subir un formulario de información al servidor e incluir headers personalizados. El proceso completo de mandar peticiones será único ya que las peticiones se realizan en JavaScript usando AJAX.\n\n--------------------------------\n<h2>Same Origin Policy (SOP) y Cross-Origin Resource Sharing (CORS) Bypass</h2>\nEl bypasseo de CORS y SOP para lanzar un CSRF es como un atacante usando un truco para hacer que tu navegador mande peticiones a diferentes sitios web en los que estás. Bajo una política CORS errónea, ciertas peticiones podrían ser subidas por orígenes reconocidos. Sin embargo, las configuraciones erróneas en las políticas CORS pueden permitir a los atacantes circunvalar estas limitaciones si confían en orígenes que el atacante puede controlar o si las credenciales son incluidas en peticiones en peticiones cross.origin.\n\n```php\n<?php // Server-side code (PHP)\n header('Access-Control-Allow-Origin: *'); \n// Allow requests from any origin (vulnerable CORS configuration) .\n..// code to update email address ?>\n```\n\nEste es un script simple en PHP del lado del servidor que maneja las peticiones POST. Tiene una configuración de CORS vulnerable (`Access-Control-Allow-Origin:*`), permitiendo peticiones de cualquier origen, siendo vulnerable a CSRF ya que no implementa medidas anti-CSRF. El uso de este header depende del caso de uso y requerimientos. Hay escenarios donde permitir peticiones de diferentes orígenes es necesario y legítimo, como en APIs públicas o redes de distribución de contenido. Sin embargo, es crucial considerar cuidadosamente las implicaciones en cuanto a seguridad y asegurar que **Access-Control-Allow-Credentials** esté bien configurado para aceptar sólo orígenes confiables. Es importante saber que `Access-Control-Allow-Origins:*` y `Access-Control-Allow-Credentials:true` no pueden ser usados juntos por restricciones de seguridad impuestas por la [Especificación de CORS](https://fetch.spec.whatwg.org/#cors-protocol-and-credentials).\n\n-------------------------------------\n<h2>Referer Header Bypass</h2>\nAl hacer peticiones HTTP, el header referer contiene el URL de la última página que el usuario visitó antes de hacer la petición actual. Algunos sitios web se protegen contra CSRF permitiendo sólo las queries si el header referer coincide con su dominio. La utilidad de esto como protección única contra CSRF se reduce cuando este header se modifica o se cambia, como ocurre con las extensiones de navegador instaladas por el usuario, herramientas de privacidad o etiquetas meta que le dicen al servidor que omitan el referer.",
    "modified": "2026-02-19T01:09:18"
  },
  {
    "title": "6. Samesite Cookie Bypass",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/4-advanced-client-side-attacks/2-csrf/6-samesite-cookie-bypass/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/4. Advanced Client-Side Attacks/2. CSRF/6. Samesite Cookie Bypass.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 4. Advanced Client-Side Attacks > 2. CSRF",
    "content": "<h2>Vista Previa</h2>\nProfundicemos en el mecanismo crucial de defensa conocido como cookies SameSite. Estas cookies vienen con un atributo especial diseñado para controlar cuándo se mandan con peticiones cross-site. Implementar esta propiedad es una manera confiable de protegerse contra filtraciones de información de cross-origin, CSRF y XSS. Dependiendo del contexto de la petición, le dice al navegador cuándo transmitir la cookie. Los tres valores potenciales son **Strict**, **Lax** y **None**.\n\nEl nivel de protección más alto es strict, que garantiza que la cookie sólo se manda si la petición viene del mismo origen que la cookie. Lax permite el uso de la cookie en orígenes cruzados por especificación.\n\n------------------------------------\n<h2>Diferentes Tipos de Cookies SameSite</h2>\n- **Lax:** Las cookies SameSite Lax son como un vecindario amigable. Ofrecen un nivel de protección moderado permitiendo cookies ser mandadas en niveles altos de navegación y métodos HTTP seguros, como GET, HEAD y OPTIONS. Esto implica que no serán mandadas en peticiones cross-origin con POST, ayudando a mitigar cierto tipo de ataques CSRF. Sin embargo, siguen estando presentes en peticiones GET iniciadas por sitios web externos, lo que puede suponer un riesgo si se guarda información sensible en las cookies.\n- **Strict:** Las cookies SameSite Strict actúan como guardias de seguridad. Ofrecen el nivel más alto de protección restringiendo las cookies para que sólo se puedan mandar por el propietario. Esto significa que las cookies sólo se mandan con peticiones que se originan del mismo sitio que configuró la cookie, previniendo efectivamente los ataques CSRF.\n- **None:** Las cookies SameSite None se comportan como trotamundos sin responsabilidades. Se mandan tanto como por el propietario como en peticiones cross-site, haciéndolas convenientes para escenarios donde las cookies necesitan ser accesibles a lo largo de diferentes orígenes. Sin embargo, para prevenir riesgos de seguridad potenciales asociados con esta configuración, las cookies None requieren del atributo Secure en true para que la petición se haga a través de HTTPS. Esto asegura que las cookies sólo se mandan en conexiones seguras.\n\n-------------------------------------\n<h2>La Aventura de Explotación Lax</h2>\n- Ahora que el atacante puede acceder a la cuenta del banco de Josh, su objetivo principal es cerrale su sesión para que no pueda hacer más transacciones.\n- Ha visto una cookie logout que se configura una vez que hace login, esta cookie está configurada como Lax, lo que significa que se mandará en todas las navegaciones de alto nivel con peticiones como GET.\n\n![[Pasted image 20260217125527.png]]\n\n- Aquí está el código del lado del servidor que valida la cookie y comprueba su valor. Basado en ese valor, el código cierra la sesión del usuario.\n\n```php\n<?php\n$cookieNames = array_keys($_COOKIE);\nif($_COOKIE[\"logout\"] == \"xxxxxxx\"){\n\t// Loop through each cookie and delete it\nforeach ($cookieNames as $cookieName) {\n// If it's desired to kill the session, also delete the session cookie.\nsession_destroy();\n..\n...\n}\n```\n\n- El script requiere un valor de cookie, pero depende por completo del tipo de valor de SameSite. Como está en Lax, no será reenviada a peticiones cross-site a excepción del alto nivel de navegación y peticiones GET.\n- Para cerrarle la sesión a Josh, el atacante puede mandar un email, haciéndose pasar por un representador del banco y persuadiéndolo para que participe en una encuesta para ganar un premio.\n\n![[Pasted image 20260218100231.png]]\n\n- Ve a `mailbox.thm:8081` y abre el mail con la insignia roja titulado \"Exclusive Opportunity: Complete Our Survey for a Chance to Win a Ferrari!\".\n\n![[Pasted image 20260218102115.png]]\n\n- Verás que el payload CSRF de logout está construido usando el siguiente payload:\n\n```html\n<a href=\"https://mybank.thm:8080/logout.php\" target=\"_blank\">Survey Link!</a>\n```\n\n- El atacante debe hacer una simple petición GET a `logout.php`, ya que la cookie está configurada como Lax.\n- Como la cookie proviene de una fuente verificada y la cookie de logout también está configurada, Josh será expulsado de su sesión y no podrá volver a iniciar sesión (ya que cambiamos su contraseña en la tarea anterior).\n\n--------------------------------------\n<h2>¿Cuál es el Link Faltante?</h2>\n- El desarrollador del MyBank LLC no consideró el atributo SameSite para las cookies al escribir el código. El ataque hubiera podido ser evitado si el atributo SameSite hubiera sido configurado como Strict en vez de Lax.\n- Además, como pentester es esencial analizar cada atributo de la cookie configurada por el dominio. La mayoría del tiempo, pequeños errores de desarrollo en programación causan avenidas abiertas de explotación en una aplicación aparentemente segura.\n\n-----------------------------------------\n<h2>Escenario Lax con POST - Encadenando el Exploit</h2>\nComo pentester, es importante comprobar las cookies que son mandadas por el sitio web. Como la cookie configurada en el ejemplo anterior era Lax, era posible cerrar la sesión de cualquier usuario. Pero ese escenario es posible sólo con peticiones GET y no se puede hacer nada en caso de peticiones POST.\n\nInicialmente, cuando el atributo SameSite fue introducido para incrementar la seguridad web restringiendo cómo se mandan las cookies en peticiones cross-site, Google Chrome y otros navegadores no reforzaron un comportamiento por defecto para cookies sin el atributo SameSite especificado. Sin embargo, con el tiempo, Google Chrome cambió esto e hizo que el valor por defecto si no se especificaba explícitamente de otra forma, fuera `SameSite=Lax`.\n\nPero ¿qué pasa si queremos hacer una petición POST? ¿Podemos hacer algo? La respuesta es sí. Como pone en la documentación de [Chrome](https://chromestatus.com/feature/5088147346030592):\n\n>[!QUOTE] _\"Chrome will make an exception for cookies set without a SameSite attribute less than **2 minute**s ago. Such cookies will also be sent with non-idempotent (e.g. POST) top-level cross-site requests despite normal SameSite=Lax cookies requiring top-level cross-site requests to have a safe (e.g. GET) HTTP method.\"_\n\nPor lo que cualquier cookie que no esté configurada con el atributo SameSite y si el servidor lee o modifica la cookie será mandada en peticiones cross-site hasta que dicha cookie cumpla dos minutos de vida. Después de esos dos minutos pasará a ser tratada como Lax.\n\nDespués de revisar el código, podemos ver que hay una cookie `isBanned` que se configura después de iniciar sesión. El valor de dicha cookie determina si el usuario es banneado o no y le muestra un mensaje. Nuestro objetivo es cambiar el valor de la cookie una vez que el usuario hace click en el link malicioso. Aquí está el código del lado del servidor que realiza la validación.\n\n```php\nif (!isset($_COOKIE['isBanned'])) { echo('&#60;script&#62;alert(\"isBanned cookie not found in request\");&#60;/script&#62;'); \texit(); }\nif (isset($_POST['isBanned'])) {\n\t$status=$_POST['isBanned'];\n     echo('<script>document.cookie=\"isBanned='.$status.'\";</script>'); \n}\n```\n\n- Hay una llamada POST API a `index.php` que acepta un parámetro `isBanned` y configura el valor de la cookie. Sin embargo, el código del lado del servidor espera la cookie para evitar ataques CSRF.\n- Si hay alguna petición cross-site a la página, no podemos ejecutar el script para crear la cookie directamente, ya que no habrá una cookie `isBanned` en nuestra petición.\n- Probemos lo siguiente. Iniciamos sesión usando `GB82MYBANK5699:GB82MYBANK5697`. Al iniciar sesión, el valor de `isBanned` será actualizado, por lo que necesitamos esperar dos minutos.\n- Después de dos minutos, abrimos el email llamado LAX+POST.\n\n![[Pasted image 20260218105334.png]]\n\n- Este email consiste de dos botones. El primero hará una petición POST a `index.php` para actualizar el valor `isBanned` de la cookie.\n- El primer botón usa el código:\n\n```javascript\n<script>\nfunction launchAttack(){ setTimeout(function(){bank.submit()},1000)\n}\n</script>\n<form style=\"display:none\" name=\"bank\" \nmethod=post action=\"http://mybank.thm:8080/index.php\">\n<input name=\"isBanned\" value=\"true\">\n<input type=\"submit\">\n</form>\n```\n\n- Haz click en el botón y mira lo que pasa:\n\n![[Pasted image 20260218105455.png]]\n\n- Esto pasa porque la cookie `isBanned` no fue redirigida por el buscador durante la petición.\n- ¿Cuál es la solución aquí? Podemos explotar la funcionalidad de que Chrome manda las cookies en una petición web si han sido modificadas en los últimos dos minutos. Como pentester es esencial entender cada petición y respuesta. La cookie `isBanned` es actualizada en dos instancias, una durante el login y la otra durante el logout.\n- Podemos encadenar el proceso para asegurarnos de que el usuario visita el link de logout. Una vez que haya cerrado la sesión y la cookie `isBanned` sea actualizada, tenemos una ventana de 2 minutos para llamar a `index.php`. para actualizar el valor de `isBanned`.\n- Aquí está el código que hace que el usuario cierre sesión y hace una llamada a `index.php` con el valor de `isBanned` actualizado.\n\n```javascript\n<script>\nfunction launchAttackSuccess(){\nlet win = window.open(\"http://mybank.thm:8080/logout.php\",'');\nsetTimeout(function(){win.close();bank.submit()},1000)\n}\n</script>\n<form style=\"display:none\" name=\"bank\" \nmethod=post action=\"http://mybank.thm:8080/index.php\">\n<input name=\"isBanned\" value=\"true\">\n<input type=\"submit\">\n</form> \n```\n\n- Haz click en el botón de `Successful Attack` el cual primero cerrará la sesión del usuario y luego hará una petición POST a `index.php` y actualizará el valor de `isBanned`. Chrome redirigirá la cookie en la petición ya que ha sido actualizada hace menos de dos minutos.",
    "modified": "2026-02-19T01:09:18"
  }
]