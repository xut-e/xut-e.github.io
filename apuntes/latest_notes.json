[
  {
    "title": "4. Identifying the OAuth Services",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/4-oauth-vulnerabilities/4-identifying-the-oauth-services/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/4. OAuth Vulnerabilities/4. Identifying the OAuth Services.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 4. OAuth Vulnerabilities",
    "content": "<h2>Identificando Uso de OAuth en una Aplicación</h2>\nLa primera indicación de que una aplicación usa OAuth es comúnmente encontrada en el proceso de login. Busca opciones que permitan a los usuarios iniciar sesión usando proveedores de servicios externos como Google, Facebook o GitHub. Estas opciones redirigen a los usuarios a la página de autorización del proveedor de servicios.\n\n----------------------------------------\n<h2>Detectando la Implementación de OAuth</h2>\nAl analizar el tráfico de red durante el proceso de login, presta atención a las redirecciones HTTP. Las implementaciones OAuth redirigirán al navegador (generalmente) a la URL del servidor de autorización. Esta URL contiene parámetros específicos como `response_type`, `client_id`, `redirect_uri`, `scope` y `state`. Estos parámetros son indicativos de un flujo OAuth en progreso. Por ejemplo, una URL puede verse así:\n\n`https://dev.coffee.thm/authorize?response_type=code&client_id=AppClientID&redirect_uri=https://dev.coffee.thm/callback&scope=profile&state=xyzSecure123`\n\n--------------------------------------------\n<h2>Identificando el Framework de OAuth</h2>\nUna vez confirmado que OAuth está siendo usado, el siguiente paso es identificar el framework o librería específicos que la aplicación emplea. Esto puede ofrecer una vista detallada de las vulnerabilidades potenciales. Aquí hay algunas estrategias para identificar el framework OAuth:\n\n- **HTTP Headers and Responses:** Inspecciona los headers HTTP y los bodies de la respuesta en busca de identificadores o comentarios referenciando librerías o frameworks OAuth.\n- **Source Code Analysis:** Si puedes acceder al código fuente de la aplicación, busca palabras clave específicas y afirmaciones importantes que puedan revelar el framework en uso. Por ejemplo, librerías como `django-oauth-toolkit`, `oauthlib`, `spring-security-oauth` o `passport` en `Node.js`, cada uno tiene características y convenciones de nombres únicas.\n- **Authorization and Token Endpoints:** Analiza los endpoints usados para obtener códigos de autorización y tokens de acceso. Diferentes implementaciones OAuth pueden tener patrones o estructuras únicos de endpoints. Por ejemplo, el `Django OAuth Toolkit` normalmente sigue el patrón `/oauth/authorize/` y `/oauth/token/`, mientras que otros frameworks usan rutas diferentes.\n- **Error Messages:** Los mensajes de error y debug personalizados pueden revelar la tecnología subyacente. Los mensajes de error detallados pueden incluir referencias a una librería o framework específicos.",
    "modified": "2025-12-23T00:53:19"
  },
  {
    "title": "6. Exploiting OAuth - CSRF in OAuth",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/4-oauth-vulnerabilities/6-exploiting-oauth-csrf-in-oauth/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/4. OAuth Vulnerabilities/6. Exploiting OAuth - CSRF in OAuth.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 4. OAuth Vulnerabilities",
    "content": "El parámetro state en el framework OAuth protege contra ataque CSRF, que ocurren cuando un atacante engaña a un usuario para que ejecute acciones no deseadas en una aplicación web donde están siendo autentificadas. Esto puede conllevar a la divulgación de información sensible. El parámetro state permite mitigar este riesgo manteniendo la integridad del proceso de autorización.\n\n------------------------------------------------\n<h2>Vulnerabilidad de Parámetro State Débil o Flatante</h2>\nEl parámetro state es una string arbitraria que la aplicación cliente incluye en la petición de autorización. Cuando el servidor de autorización redirige al usuario de vuelta a la aplicación cliente con el código de autorización, también incluye el parámetro state. Entonces la aplicación cliente verifica que el parámetro state en la respuesta coincide con con la mandada originalmente. \n\nPor ejemplo, considera una implementación OAuth donde el parámetro state falta o es predecible. Un atacante puede iniciar un flujo OAuth y ofrecer su URI de redirección maliciosa. Después de que el usuario se autentifique y autorice a la aplicación, el servidor de autorización redirige el código de autorización a la URI controlada por el atacante, como se especifica en el parámetro state débil o faltante.\n\n--------------------------------------\n<h2>Práctica</h2>",
    "modified": "2025-12-23T00:53:19"
  },
  {
    "title": "3. How OAuth Flow Works",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/4-oauth-vulnerabilities/3-how-oauth-flow-works/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/4. OAuth Vulnerabilities/3. How OAuth Flow Works.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 4. OAuth Vulnerabilities",
    "content": "El flujo OAuth 2.0 comienza cuando un usuario (dueño del recurso) interactúa con una aplicación cliente (cliente) y pide acceso a un recurso específico. EL cliente redirige al usuario a un servidor de autorización, donde se le pide al usuario que inicie sesión y otorgar acceso. Si el usuario consiente, el servidor de autorización emite un código de autentificación, el cual el cliente puede intercambiar por un token de acceso. Este token permite al cliente acceder al servidor de recursos y obtener el recurso pedido en nombre del usuario.\n\n![[Pasted image 20251222124900.png]]\n\nVeremos ahora los pasos del flujo de trabajo de OAuth en detalle, considerando el mismo ejemplo de la cafetería.\n\n------------------------------------------\n<h2>Conectarse a la Máquina</h2>\nLe damos a \"Start Machine\" y esperamos 1-2 minutos. Tenemos que ir al archivo `/etc/hosts` y añadir la entrada `<IP_tun0>    cofee.thm bistro.thm`.\n\nUsaremos una versión personalizada de Django OAuth. FactBook el el proveedor OAuth. Puedes visitar http://coffee.thm:8000/admin para ver el panel de inicio de sesión del proveedor OAuth, que seguirá siendo el mismo a lo largo de la sesión.\n\n![[Pasted image 20251222131427.png]]\n\nUsaremos las siguientes credenciales para esta tarea:\n\n- **Víctima:** `victim:victim123`\n- **Atacante:** `attacker:tesla@123`\n\n>[!NOTE] No es necesario que inicies sesión todavía.\n\nUna vez inicies sesión en el proveedor OAuth, puedes iniciar sesión en cualquier otra página web, como harías con `Sign Up with Google` en X, Facebook o cualquier otra página.\n\nAhora visita http://bistro.thm:8000/, la cual usaremos para comprender el flujo de trabajo de OAuth. Entenderemos el flujo consideramdo a una persona llamada Tom, quien quiere iniciar sesión en una página diferente usando su cuenta de `CoffeeShopApp`.\n\n-------------------------------------\n<h2>Petición de Autorización</h2>\nTom visita primero `bistro.thm`, donde quiere iniciar sesión via `CoffeeShopApp`. Cuando hace click en \"Login via OAuth\", `CoffeeShopApp` debe primero obtener su permiso, por lo que la aplicación redirige a su navegador al servidor de autorización con una petición de autorización.\n\n![[Pasted image 20251222133239.png]]\n\nSi haces click en \"Login with OAuth\", serás redirigido al servidor de autorización con la URL `http://coffee.thm:8000/accounts/login/?next=/o/authorize/%3Fclient_id%3Dzlurq9lseKqvHabNqOc2DkjChC000QJPQ0JvNoBt%26response_type%3Dcode%26redirect_uri%3Dhttp%3A//bistro.thm%3A8000/oauthdemo/callback`, como se muestra debajo:\n\n![[Pasted image 20251222133336.png]]\n\nEl sitio web del bistro inicia este proceso redirigiendo a Tom al servidor de autorización con los siguientes parámetros incluidos en la URL:\n\n- `response_type=code`: Esto indica que `CoffeeSopApp` espera un código de autorización como respuesta.\n- `state`: Un token CSRF para asegurar que la petición y respuesta son parte de la misma transacción.\n- `client_id`: Un identificador público para la aplicación del cliente, identificando de forma única a `CoffeeShopApp`.\n- `redirect_uri`: La URL donde el servidor de autorización mandará a Tom después de que otorgue permiso. Debe coincidir con una de las URIs preregistradas para la aplicación del cliente.\n- `scope`: Especifica el nivel de acceso pedido, como ver pedidos de café.\n\nIncluyendo estos parámetros, la app del bistro se asegura de que el servidor de autorización entiende lo que se le está pidiendo y dónde mandar al usuario después. Aquí está el código de Python que redirige al usuario al servidor de autorización.\n\n```python\ndef oauth_login(request):\n    app = Application.objects.get(name=\"CoffeeApp\")\n    redirect_uri = request.GET.get(\"redirect_uri\", \"http://bistro.thm:8000/oauthdemo/callback\")\n    \n    authorization_url = (\n        f\"http://coffee.thm:8000/o/authorize/?client_id={app.client_id}&response_type=code&redirect_uri={redirect_uri}\"\n    )\n    return redirect(authorization_url)\n```\n\n-------------------------------------------\n<h2>Autentificación y Autorización</h2>\nCuando Tom llega al servidor de autorización, se le pide iniciar sesión usando sus credenciales. Este paso asegura que el servidor pueda verificar su identidad. Después de haber iniciado sesión correctamente, el servidor de autorización le pregunta a Tom si accede a permitir a la app del bistro a acceder a sus detalles. Este paso de consentimiento es crucial, ya que le da a Tom transparencia y control sobre qué aplicaciones pueden acceder a su información.\n\nEste proceso típicamente envuelve:\n\n- **User Login:** Tom introduce su nombre de usuario y contraseña en el login del servidor de autorización.\n- **Consent Prompt:** Después de la autentificación, el servidor de autorización le presenta a Tom una pantalla de consentimiento detallando a qué pide acceso `CoffeeShopApp`. Tom debe decidir si acepta o deniega dichos permisos.\n  \n  ![[Pasted image 20251222134716.png]]\n\nEste doble paso asegura que la identidad de Tom esté autentificada y que su consentimiento explícito es obtenido antes de que se otorgue cualquier acceso, manteniendo la seguridad y el control del usuario sobre su información personal.\n\n-----------------------------------------\n<h2>Respuesta de Autorización</h2>\nSi Tom acepta otorgar acceso, el servidor de autorización genera un código de autorización, como le pide la petición. El servidor entonces redirige a Tom al sitio del bistro usando la `redirect_uri` especificada. La redirección incluye el código de autorización y el parámetro `state` original para asegurar la integridad del flujo.\n\nEl servidor de autorización responde con:\n\n- `code`: `CoffeeShopApp` usará el código de autorización para pedir un token de acceso.\n- `state`: El token CSRF previamente mandado por `CoffeeShopApp` para validar la respuesta.\n\nUn ejemplo de respuesta sería: `https://bistro.thm:8000/callback?code=AuthCode123456&state=xyzSecure123`.\n\nEste paso asegura que el proceso de autorización sea seguro y que la respuesta esté ligada a la petición inicial del bistro. El código de autorización es un token temporal que será usado en el próximo paso para obtener un token de acceso, permitiendo a `CoffeeShopApp` acceder a los detalles del perfil de Tom.\n\n-----------------------------------------\n<h2>Petición del Token</h2>\nEl sitio web del bistro intercambia el código de autorización por un token de acceso haciendo una petición POST al endpoint token del servidor de autorización con los siguientes parámetros:\n\n- `grant_type`: Tipo de permiso que se usa, normalmente declarado como `code` para especificar código de autorización como tipo de permiso.\n- `code`: El código de autorización obtenido del servidor de autorización.\n- `redirect_uri`: Debe coincidir con la URI de redirección original dada en la petición de autorización.\n- `client_id` y `client_secret`: Credenciales para autentificar la aplicación del cliente.\n\nUsando los parámetros de arriba, el siguiente código hará una petición de token al endpoint `/o/token`.\n\n```python\ntoken_url = \"http://coffee.thm:8000/o/token/\"\n    client_id = Application.objects.get(name=\"CoffeeApp\").client_id\n    client_secret = Application.objects.get(name=\"CoffeeApp\").client_secret\n    redirect_uri = request.GET.get(\"redirect_uri\", \"http://bistro.thm:8000/oauthdemo/callback\")\n    \n    data = {\n        \"grant_type\": \"authorization_code\",\n        \"code\": code,\n        \"redirect_uri\": redirect_uri,\n        \"client_id\": client_id,\n        \"client_secret\": client_secret,\n    }\n    \n    headers = {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Authorization': f'Basic {base64.b64encode(f\"{client_id}:{client_secret}\".encode()).decode()}',\n    }\n    \n    response = requests.post(token_url, data=data, headers=headers)\n    tokens = response.json()\n```\n\nLa app del bistro intercambia de forma segura el código de autorización por un token de acceso mandando esta petición. El servidor de autorización verificará la información ofrecida, asegurando que la petición es válida y se origina del cliente pidiendo el código de autorización. Si todo es correcto, el servidor de autorización responderá con el token de acceso, permitiendo al sitio del bistro proceder a acceder a los detalles del perfil de Tom.\n\n------------------------------\n<h2>Respuesta del Token</h2>\nEl servidor de autorización autentifica la web del bistro y valida el código de autorización. Al validarse exitosamente, el servidor responde con un `Access Token` y, opcionalmente un `Refresh Token`.\n\nLa respuesta del servidor de autorización incluye lo siguiente:\n\n- `access_token`: Token que será usado para acceder a los detalles de Tom.\n- `token_type`: Típicamente \"Bearer\".\n- `expires_in`: La duración en segundos para la que el token de acceso es válido.\n- `refresh_token (opcional)`: Un token usado para obtener un nuevo token de acceso sin requerir que el usuario vuelva a iniciar sesión.\n\nCon el token de acceso, el sitio web del bistro puede hacer peticiones autentificadas al servidor de recursos para acceder a los detalles de perfil de Tom. El token de refresco opcional puede usarse para pedir un nuevo token de acceso una vez que el actual expira, ofreciendo una mejor experiencia de usuario al hacer que Tom no tenga que volver a iniciar sesión cuando su token expira.",
    "modified": "2025-12-23T00:53:19"
  },
  {
    "title": "5. Exploiting OAuth - Stealing OAuth Token",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/4-oauth-vulnerabilities/5-exploiting-oauth-stealing-oauth-token/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/4. OAuth Vulnerabilities/5. Exploiting OAuth - Stealing OAuth Token.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 4. OAuth Vulnerabilities",
    "content": "Los tokens juegan un rol crítico en el framework OAuth 2.0, actuando como claves digitales que otorgan acceso a recursos protegidos. Estos tokens son emitidos por el servidor de autorización y redirigidos a la aplicación del cliente basándose en el parámetro `redirect_uri`. Esta redirección es crucial en el flujo OAuth, asegurando que los tokens se transmiten de forma segura al receptor. Sin embargo, si el `redirect_uri` no está bien protegido, los atacantes pueden explotarlo para secuestrar tokens.\n\n---------------------------------\n<h2>Rol de Redirect_URI</h2>\nEl parámetro `redirect_uri` se especifica durante el flujo OAuth para redirigir el token desde el servidor de autorización, después de que la autorización se lleve a cabo. Esta URI debe estar preregistrada en los ajustes de la aplicación para prevenir vulnerabilidades de redirección abierta. Durante el proceso OAuth, el servidor comprueba que la `redirect_uri` proporcionada coincide con una de las registradas.\n\n---------------------------------\n<h2>Vulnerability</h2>\nUna `redirect_uri` insegura puede llevar a problemas severos de seguridad. Si los atacantes ganan control sobre cualquier dominio o URI listada en `redirect_uri`, pueden manipular el flujo para interceptar los tokens. Aquí se muestra cómo debería ser explotado:\n\n- Considera una aplicación OAuth con las siguientes URIs de redirección registradas:\n  ![[Pasted image 20251222200934.png]]\n- **Estrategia del Atacante:** Si un atacante gana control sobre `dev.bistro.thm`, pueden explotar el flujo OAuth. Configurando la `redirect_uri` a `http://dev.bistro.thm/callback`, el servidor de autorización mandará el token a este dominio controlado por él.\n- **Ataque Construido:** El atacante inicia un flujo OAuth y asegura que `redirect_uri` apunta a su dominio controlado. Después de que el usuario autorice a la aplicación, el token es mandado a `http://dev.bistro.thm/callback`. El atacante puede ahora capturar este token y usarlo para acceder a recursos protegidos.\n\n--------------------------------\n<h2>Preparando el Payload (Prespectiva del Atacante)</h2>\nAntes de empezar el ejercicio, asegúrate de que tienes la sesión de la víctima cerrada visitando http://coffee.thm:8000/admin/logout.\n\nPara este ejercicio asumimos que el atacante ha comprometido el dominio `dev.bistro.thm:8002` y puede hostear cualquier página HTML en el servidor. Considera a Tom, una víctima a la cual se le mandará el link. El atacante puede construir una página HTML simple (`redirect_uri.html`) con el siguiente código:\n\n```html\n<form action=\"http://coffee.thm:8000/oauthdemo/oauth_login/\" method=\"get\">\n    <input type=\"hidden\" name=\"redirect_uri\" value=\"http://dev.bistro.thm:8002/malicious_redirect.html\">\n    <input type=\"submit\" value=\"Hijack OAuth\">\n</form>\n```\n\nEste formulario manda un parámetro escondido `redirect_uri` con el valor `http://dev.bistro.thm:8002/malicious_redirect.html` y subir la petición a http://coffee.thm:8000/oauthdemo/oauth_login/. La página `malicious_redirect.html` interceptaría el código de autorización de la URL usando el siguiente código:\n\n```html\n<script>\n    // Extract the authorization code from the URL\n    const urlParams = new URLSearchParams(window.location.search);\n    const code = urlParams.get('code');\n    document.getElementById('auth_code').innerText = code;\n    console.log(\"Intercepted Authorization Code:\", code);\n    // code to save the acquired code in database/file etc\n</script>\n```\n\n>[!NOTE] Como el atacante tiene control total del subdominio, una vez que redirige a una víctima, guardará las credenciales en una base de datos/archivo para usarlo después.\n\nEl atacante puede mandarle a Tom el link (http://dev.bistro.thm:8002/redirect_uri.html) mediante ingeniería social o CSRF. La víctima, inocente, hace click en el link, lo que lo lleva a `dev.bistro.thm:8002/redirect_uri.html`.\n\nAbre dicho link en la máquina virtual como \"víctima\". Verás esto:\n\n![[Pasted image 20251222202318.png]]\n\nCuando la víctima hace click en \"Login via OAuth\", el formulario llama a `http://coffee.thm:8000/oauthdemo/oauth_login/` pero con una `redirect_uri` falsificada. Una vez que la víctima introduce sus credenciales (`victim:victim123`) en el proveedor de OAuth, redirige el código de autorización OAuth a la URL (`http://dev.bistro.thm:8002/malicious_redirect.html`) controlada por el atacante, permitiéndole interceptar y usar para sus fines el código de autorización.\n\n![[Pasted image 20251222202750.png]]\n\n--------------------------------------\n<h2>Perspectiva del Atacante</h2>\nDesde la máquina del atacante, pueden utilizar el código de autorización interceptada para llamar al endpoint `/callback` e intercambiarlo por un token válido. Con este token, el atacante gana acceso no autorizado a los recursos protegidos del usuario. Para obtener este token, visita la URL http://bistro.thm:8000/oauthdemo/callbackforflag/?code=xxxx y reemplaza `code` por el código adquirido.\n\n![[Pasted image 20251222202955.png]]",
    "modified": "2025-12-23T00:53:19"
  },
  {
    "title": "1. Key Concepts",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/4-oauth-vulnerabilities/1-key-concepts/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/4. OAuth Vulnerabilities/1. Key Concepts.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 4. OAuth Vulnerabilities",
    "content": "EN esta tarea veremos los conceptos clave para entender OAuth, específicamente OAuth 2.0. Para hacer los conceptos más fáciles de entender, los explicaremos mediante un ejemplo: usar la app de móvil de una cafetería para pedir y pagar un café.\n\n---------------------------------------------\n<h2>Resource Owner</h2>\nEl dueño del recurso es la persona o sistema que controla cierta información y puede autorizar a la aplicación a acceder a dicha información en su nombre. Este concepto es fundamental, ya que se centra en el contenido del usuario y su control. Por ejemplo, eres el dueño del recurso siendo un cliente de la cafetería, ya que puedes controlar la información de tu cuenta y darle permiso a la app para acceder a tus datos.\n\n----------------------------------------\n<h2>Client</h2>\nEl cliente puede ser una app móvil o una aplicación web del lado del servidor. Actúa como intermediario, pidiendo acceso a recursos y realizando las acciones que el dueño del recurso le permite. Por ejemplo, la aplicación web o móvil  de la cafetería es el cliente. El cual necesita tu autorización para acceder a los detalles de tu cuenta, incluyendo la información de pago.\n\n-----------------------------------\n<h2>Servidor de Autorización</h2>\nEl servidor de autorización es responsable de emitir tokens de acceso al cliente después de haber autentificado exitosamente al dueño del recurso y haber obtenido su autorización. El servidor de autorización juega un papel crucial en el proceso OAuth asegurándose de que el cliente recibe el permiso sólo después de que se realice un consentimiento y autorización de usuario legítimos. Por ejemplo, el sistema de backend  de la cafetería que maneja la autentificación y autorización es el servidor de autorización. Verifica tus credenciales y le da permiso (si son correctas) a la app para que acceda a tu cuenta.\n\n----------------------------------------------\n<h2>Servidor de Recursos</h2>\nEl servidor que hostea los recursos protegidos puede aceptar y responder a las peticiones hacia estos recursos usando tokens. Este servidor se asegura de que sólo clientes autentificados y autorizados puedan acceder o manipular la información del dueño del recurso. Por ejemplo, sería la base de datos de la cafetería que guarda tu información de cuenta, historial de compra y detalles de pago. Responde a peticiones de la aplicación permitiéndole recuperar y modificar tu información.\n\n--------------------------------------\n<h2>Authorization Grant</h2>\nEl cliente usa una credencial representando la autorización del dueño del recurso para obtener un token de acceso. Los tipos primarios de permiso son: `Authorization Code`, `Implicit`, `Resource Owner Password Credentials` y `Client Credentials`. Por ejemplo, cuando inicias sesión en la app de la cafetería, se te da un permiso de autorización. La aplicación usa este permiso para darte un token de acceso desde el servidor de autorización.\n\n--------------------------------\n<h2>Refresh Token</h2>\nUna credencial que el cliente puede usar para obtener un nuevo token de acceso sin requerir que el dueño del recurso se re-autentifique. Los tokens de refresco, suelen tener un gran tiempo de vida y ofrecen una forma de mantener las sesiones del usuario sin interrupciones frecuentes de login. Por ejemplo, cuando tu token de acceso vence, la aplicación web usa el token de refresco para obtener un nuevo token de acceso para que no tengas que volver a loguearte.\n\n------------------------------------------\n<h2>Redirect URI</h2>\nLa URI a la que el servidor de autorización redirigirá al user-agent del dueño del recurso después de la aceptación o denegación de la autorización. Comprueba si el cliente para el que se ha pedido la respuesta es correcto. Por ejemplo, después de interactuar con la app de la cafetería e iniciar sesión, serás redirigido al servidor de autorización por la página de la app, conocida como URI de redirección para confirmar que has iniciado sesión exitosamente.\n\n---------------------------------------\n<h2>Scope</h2>\nScopes son un mecanismo para limitar los accesos de una aplicación a la cuenta de un usuario. Permiten al cliente especificar el nivel de acceso necesitado y al servidor de autorización informar al usuario sobre los niveles de acceso que la aplicación pide. El alcance (scope) ayuda a reforzar el concepto de los menos privilegios posibles. Por ejemplo, la app de la cafetería puede pedir diferentes scopes, como acceso a tu historial de compra e información de pago. Como dueño del recurso, puedes ver qué información pide la app y dar o denegar dichos permisos.\n\n-----------------------------------------------\n<h2>State Parameter</h2>\nUn parámetro opcional mantiene el estado entre el cliente u el servidor de autorización. Puede ayudar a prevenir ataques CSRF asegurando que la respuesta coincide con la petición del cliente. El parameter state es una parte crucial de securizar el flujo OAuth. Por ejemplo, cuando inicias el proceso de login, la app de la cafetería manda  un parameter state al servidor de autorización. Este parámetro ayuda a asegurar que la respuesta que recibes está vinculada a tu petición original, protegiendo contra cierto tipo de ataques.\n\n------------------------------------------\n<h2>Token & Authorization Endpoint</h2>\nEl endpoint del servidor de autorización es donde el cliente intercambia el permiso de autorización (o refresh token) por un token de acceso. Por el contrario, el endpoint de autorización es donde el dueño del recurso se autentifica y autoriza al cliente para acceder a recursos protegidos.",
    "modified": "2025-12-22T00:56:16"
  }
]