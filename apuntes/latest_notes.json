[
  {
    "title": "8. Bypassing Server-Side Filtering - File Extensions",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/8-bypassing-server-side-filtering-file-extensions/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/8. Bypassing Server-Side Filtering - File Extensions.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "Los filtros del lado del cliente son fáciles de sobrepasar porque ves el código. Pero ¿qué pasa cuando no puedes verlo? Tenemos que realizar un montón de pruebas para entender qué es lo que está pasando por detrás para poder crear un payload que se ajuste a las restricciones.\n\nPara la primera parte de esta tarea miraremos un sitio web que está usando una blacklist para las extensiones como filtro del lado del servidor. Hay una variedad de formas diferentes en las que esto podría estar programado, y el bypass a utilizar depende de ello. En el mundo real no seríamos capaces de ver el código, pero para este ejemplo usaremos:\n\n```php\n<?php       \n//Get the extension       \n$extension = pathinfo($_FILES[\"fileToUpload\"][\"name\"])[\"extension\"];       \n//Check the extension against the blacklist -- .php and .phtml       \nswitch($extension){           \n\tcase \"php\":           \n\tcase \"phtml\":           \n\tcase NULL:               \n\t\t$uploadFail = True;               \n\t\tbreak;           \n\tdefault:               \n\t\t$uploadFail = False;       \n}   \n?>\n```\n\nEn esta instancia, el código busca el último punto en el nombre del archivo y lo usa para confirmar la extensión, por lo que eso es lo que trataremos de bypassear. Otras formas en las que el código podría funcionar serían: buscar el primer punto en el nombre de archivo o partir el nombre por cada punto y ver si hay extensiones no permitidas.\n\nPodemos ver que el código está filtrando `.php` y `.phtml`, por lo que si queremos subir un script PHP, vamos a tener que encontrar otra extensión. La [página de Wikipedia](https://en.wikipedia.org/wiki/PHP) para PHP nos da unas cuantas extensiones comunes que podemos probar. Sin embargo hay algunas más raras que los servidores pueden reconocer todavía. Estas incluyen `.php3`, `.php4`, `.php5`, `.php7`, `.phps`, `.php-s`, `.pht` y `.phar`. Todos estos bypassean el filtro. Pero parece que el servidor no está configurado para reconocerlos como archivos `php`.\n\n![[Pasted image 20251216211116.png]]\n\nEste es el por defecto para los servidores de Apache2. Sin embargo, el sysadmin debe haber cambiado la configuración por defecto, por lo que merece la pena probar.\n\nEventualmente, encontramos que la extensión `.phar` bypassea el filtro y funciona, dándonos una shell.\n\n![[Pasted image 20251216211454.png]]\n\n--------------------------------\nVeamos otro ejemplo, con un filtro diferente. Esta vez, lo haremos completamente black-box.\n\nUna vez más, tenemos nuestro formulario de subida.\n\n![[Pasted image 20251216211556.png]]\n\nEmpezaremos investigando el alcance con un archivo de subida legítimo. Subiremos `spaniel.jpg`, la imagen de antes.\n\n![[Pasted image 20251216211635.png]]\n\nBien, esto nos dice que los archivos JPEG son aceptados. Vamos a probar una que casi al 100% de seguridad será rechazada (`shell.php`).\n\n![[Pasted image 20251216212211.png]]\n\nEfectivamente.\n\nDesde aquí ya enumeramos, probando técnicas de arriba y tratando, generalmente, de obtener una idea de qué acepta o rechaza el filtro.\n\nEn este caso, hemos encontrado que no hay extensiones shell que se ejecuten y no estén filtradas, por lo que de vuelta a la pizarra.\n\nEn el ejemplo anterior, vimos que el código usaba `pathinfo()` para obtener los últimos caracteres después del punto, pero ¿qué pasa si filtra el input ligeramente diferente?\n\nTrataremos de subir un archivo llamado `shell.jpg.php`. Sabemos que los archivos JPEG son aceptados, por lo que ¿y si el filtro sólo comprueba que la extensión `.jpg` exista?\n\nEl pseudo código de este tipo de filtro podría verse algo como así:\n\n```pseudocode\nACCEPT FILE FROM THE USER \n-- \nSAVE FILENAME IN VARIABLE userInput   \nIF STRING \".jpg\" IS IN VARIABLE userInput:       \n\tSAVE THE FILE   \nELSE:       \n\tRETURN ERROR MESSAGE\n```\n\nCuando probamos a subirlo recibimos un mensaje de éxito. Navegar hasta el directorio `/uploads` confirma que el payload se subió exitosamente.\n\n![[Pasted image 20251216213219.png]]\n\nAl activarlo, recibiremos nuestra shell.\n\n![[Pasted image 20251216213236.png]]\n\n---------------------------------------\nEsto no es una lista exhaustiva de vulnerabilidades de subida de archivos relativo a las extensiones. Como en todo en el hacking, buscamos explotar debilidades del código escrito por otros. Este puede ser extremadamente único para la tarea a realizar. Hay un millón de formas diferentes de implementar la misma funcionalidad cuando se trata de programar.\n\n-------------------------------------------------\nAhora es tu turno, averigua y bypassea el filtro para subir y activar una shell. La flag está en `/var/www/`. Ve al sitio `annex.uploadvulns.thm` y comienza.\n\n>[!IMPORTANT] Por primera vez, se ha implementado un esquema de nombramiento aleatorio, por lo que a partir de ahora puede que no todos los directorios sean indexables.\n\n1. Vamos a la página dada.\n   ![[Pasted image 20251216224705.png]]\n2. Hacemos un escaneo con `gobuster`.\n   ![[Pasted image 20251216231603.png]]\n3. Volviendo a la página, parece curiosa, vamos a ver cómo es la sintaxis:\n   ![[Pasted image 20251216224830.png]]\n4. Primero vamos a seleccionar una imagen legítima.\n   ![[Pasted image 20251216225024.png]]\n5. Lo subimos y obtenemos succesfully.\n   ![[Pasted image 20251216225109.png]]\n6. Vamos a probar con uno que no nos dejará (lo más probable).\n   ![[Pasted image 20251216225327.png]]\n7. Lo subimos y obviamente es inválido.\n   ![[Pasted image 20251216225348.png]]\n8. Vamos a seguir mapeando.\n\t1. Con `.jpg`.\n\t   ![[Pasted image 20251216225613.png]]\n\t2. Parece que ha funcionado.\n\t   ![[Pasted image 20251216225648.png]]\n9. Vamos a ver de qué se trataba ese directorio `/privacy`.\n   ![[Pasted image 20251216231759.png]]\n   Es donde se guardan los archivos subidos.\n10. Nos ponemos en escucha en el puerto que hayamos especificado.\n    ![[Pasted image 20251216231940.png]]\n11. Le damos a la \"imagen\".\n    ![[Pasted image 20251216232031.png]]\n    Vaya, parece que ha fallado.\n12. Vamos a probar con una webshell.\n    ![[Pasted image 20251216232510.png]]\n13. Voy a probar a meterle el null byte, por si cuela.\n    ![[Pasted image 20251216232636.png]]\n14. A ver si hay suerte.\n    ![[Pasted image 20251216232707.png]]\n    ![[Pasted image 20251216232746.png]]\n    No     :(\n15. Después de probar un poco vemos que `.php5` sirve como tipo de archivo.\n    ![[Pasted image 20251216233046.png]]\n    ![[Pasted image 20251216233628.png]]\n16. Ahora vamos a la página, le damos al link y metemos el parámetro `?cmd=pwd`.\n    ![[Pasted image 20251216233927.png]]\n17. Vamos a listar `/var/www/`.\n    ![[Pasted image 20251216234023.png]]\n18. Leemos la flag.\n    ![[Pasted image 20251216234100.png]]",
    "modified": "2025-12-17T00:48:47"
  },
  {
    "title": "12. Conclusion",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/12-conclusion/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/12. Conclusion.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "",
    "modified": "2025-12-17T00:48:47"
  },
  {
    "title": "0. Upload Vulnerabilities",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/0-upload-vulnerabilities/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/0. Upload Vulnerabilities.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "[[1. Getting Started]]\n[[2. Introduction]]\n[[3. General Methodology]]\n[[4. Overwriting Existing Files]]\n[[5. Remote Code Execution]]\n[[6. Filtering]]\n[[7. Bypassing Client-Side Filtering]]\n[[8. Bypassing Server-Side Filtering - File Extensions]]\n[[9. Bypassing Server-Side Filtering - Magic Numbers]]\n[[10. Example Methodology]]\n[[11. Challenge]]\n[[12. Conclusion]]",
    "modified": "2025-12-17T00:48:47"
  },
  {
    "title": "7. Bypassing Client-Side Filtering",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/7-bypassing-client-side-filtering/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/7. Bypassing Client-Side Filtering.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "Empezaremos con la primera (y más débil) linea de defensa: filtrado del lado del cliente.\n\nComo mencionamos previamente, el filtrado del lado del cliente suele ser extremadamente fácil de bypassear. Como ocurre por completo en la máquina que puedes controlar, al tener acceso al código es fácil de modificar.\n\nHay cuatro maneras fáciles de bypassear los típicos filtros de subida del lado del cliente:\n\n1. Deshabilita JavaScript en tu navegador: Esto funcionará si el sitio web no requiere JavaScript para ofrecer funcionaliddades básicas.\n2. Intercepta y modifica la página entrante: Usando Burp Suite, podemos interceptar la página entrante y quitarle el filtro JavaScript antes de que tenga oportunidad de ejecutarse.\n3. Intercepta y modifica el archivo subido: Este método permite que la página se cargue de forma normal pero intercepta el archivo subido después de haber pasado los filtros pero cuando todavía no ha llegado al servidor.\n4. Manda el archivo directamente al punto de subida: Si puedes mandar el archivo directamente al punto de salida, puedes evitar filtros del navegador. El comando para dicho propósito sería algo así: `curl -X POST -F \"submit:<value>\" -F \"<file-parameter>:@<path-to-file>\" <site>`. Para poder usar este método deberías primero interceptar una petición de subida exitosa para ver parámetros, headers y demás.\n\nCubriremos los métodos 2 y 3 en profundidad debajo.\n\n-------------------------------------------------\nAsumamos que hemos encontrado una página de subida.\n\n![[Pasted image 20251215124519.png]]\n\nComo siempre, miraremos el código fuente. Aquí podemos ver una función JavaScript básica que comprueba el tipo MIME de los archivos subidos:\n\n![[Pasted image 20251215124652.png]]\n\nEn esta instancia podemos ver que el filtro está usando una whitelist para excluir cualquier tipo MIME que no sea `image/jpeg`.\n\nEl próximo paso es intentar una subida de archivo. Si seleccionamos JPEG, la función lo acepta y cualquier otra la rechaza.\n\nHabiendo establecido esto, arrancamos BurpSuite y recargamos la página. Veremos nuestra propia petición al sitio web pero lo que realmente queremos es ver es la respuesta del servidor, así que hacemos click derecho en la información interceptada, bajamos hasta \"Do Intercept\" y seleccionamos \"Response to this Request\".\n\n![[Pasted image 20251215124935.png]]\n\nCuando hacemos click en \"Forward\" arriba de la ventana, veremos la respuesta del servidor a nuestra petición. Aquí, podemos borrar, comentar o romper la función JavaScript antes de que tenga oportunidad de cargar.\n\n![[Pasted image 20251215125235.png]]\n\nHabiendo borrado la función, le damos de nuevo a \"Forward\" hasta que veamos que el sitio web ha terminado de cargarse y ahora ya podemos subir cualquier tipo de archivo a la página.\n\n![[Pasted image 20251215125327.png]]\n\n>[!IMPORTANT] Burp Suite no intercepta (por defecto) archivos JavaScript externos que la página cargue. Si necesitas editar un script que no esté en la página principal, necesitas ir a `Options > Intercept Client Requests` y editar la condición de la primera línea para eliminar `^js$|`:\n\n![[Pasted image 20251215125537.png]]\n\n---------------------------------------------------\nYa hemos bypasseado este filtro interceptando y eliminándolo antes de que cargue la página, pero intentémoslo hacer subiendo un archivo con una extensión y tipo MIME legítimos e interceptándolo y corrigiéndolo con BurpSuite.\n\nHabiendo recargado la página web, para poner el filtro en su lugar, tomemos la reverse shell que hemos usado antes y renombrémosla para que se llame \"shell.jpg\". Como el archivo cumple con la condición del tipo MIME, nuestro filtro del lado del cliente deja pasar nuestro payload sin quejas.\n\n![[Pasted image 20251215130752.png]]\n\nUna vez más, activamos Burp Suite y le damos a \"Upload\" para interceptar la petición.\n\n![[Pasted image 20251215130825.png]]\n\nObserva que el tipo MIME de nuestra shell PHP es `image/jpeg`. Cambiaremos esto a `text/x-php`, y la extensión de `.jpg` a `.php` y le daremos a forward.\n\n![[Pasted image 20251215130939.png]]\n\nAhora, al navegar a `http://demo.uploadvulns.thm/uploads/shell.php` habiendo activado un listener, recibiremos una conexión de la shell.\n\n![[Pasted image 20251215131029.png]]\n\n---------------------------------\nHemos cubierto en detalle dos formas de bypassear un filtro de subida de lado del cliente. Ahora es hora de que lo probemos. Ve a `java.uploadvulns.thm` y bypassea el filtro para conseguir una reverse shell. Recuerda escanear el sitio web con `gobuster`.\n\n1. Vamos al sitio web dado.\n   ![[Pasted image 20251215224146.png]]\n2. Escanearemos mientras tanto la página con `gobuster`.\n   ![[Pasted image 20251215225918.png]]\n3. Vamos a interceptar una subida de archivo con Burp Suite.\n\t1. Abrimos Burp Suite y su navegador y vamos al sitio web que nos dan.\n\t   ![[Pasted image 20251215224459.png]]\n\t2. Seleccionamos un archivo y activamos la intercepción.\n\t   ![[Pasted image 20251215224527.png]]\n\t3. Le damos a \"Upload\" y esperamos la petición.\n\t   ![[Pasted image 20251215224611.png]]\n4. El content type parece ser `image/png`.\n   ![[Pasted image 20251215224721.png]]\n5. Le damos a \"Forward\".\n   ![[Pasted image 20251215224812.png]]\n   Parece que se ha subido exitosamente.\n6. Vamos ahora a subir una `shell.php` y a capturar la respuesta.\n\t1. Editamos la shell.\n\t   ![[Pasted image 20251215225158.png]]\n\t2. Nos ponemos en escucha.\n\t   ![[Pasted image 20251215225244.png]]\n\t3. Subimos la shell y la interceptamos con Burp Suite.\n\t   ![[Pasted image 20251215225330.png]]\n\t   Parece que no nos deja.\n\t4. Le cambiamos la extensión a `.png`.\n\t   ![[Pasted image 20251215225504.png]]\n\t5. Ahora sí.\n\t   ![[Pasted image 20251215225523.png]]\n\t6. Vamos a interceptarlo.\n\t   ![[Pasted image 20251215225558.png]]\n\t7. Cambiamos el filename a `reverseshell.php` y content-type a `text/x-php`.\n\t   ![[Pasted image 20251215225716.png]]\n\t8. Le damos a forward hasta que ponga success.\n\t   ![[Pasted image 20251215225828.png]]\n7. Ahora debemos navegar a la shell, que basándonos en nuestro escaneo con `gobuster` seguramente esté en `/images`.\n   ![[Pasted image 20251215230007.png]]\n   La página parece quedarse cargando.\n8. Pero si volvemos al listener:\n   ![[Pasted image 20251215230034.png]]\n9. Ahora vamos al directorio que nos dan y leemos la flag.\n   ![[Pasted image 20251215230112.png]]",
    "modified": "2025-12-16T00:54:19"
  },
  {
    "title": "6. Filtering",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/6-filtering/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/6. Filtering.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "Hasta ahora hemos ignorado las defensas empleadas por los desarrolladores web para defenderse contra las vulnerabilidades de subidas de archivos. Desde ahora miraremos algunos de los mecanismos de defensa usados para prevenir la subida de archivos maliciosos y cómo circunvalarlos.\n\n----------------------------------\nPrimero, veamos las diferencias entre filtrado del lado del cliente y del lado del servidor.\n\nCuando hablamos sobre que un script sea \"Client-Side\", en el contexto de las aplicaciones web, nos referimos a que corre en el navegador del usuario en vez de en el propio servidor. JavaScript es prácticamente omnipresente como lenguaje de scripting del lado del cliente aunque existen alternativas. Sin importar el lenguaje, un script del lado del cliente se ejecuta en el navegador. En el contexto de la subida de archivos, esto significa que el filtrado ocurre antes de que el archivo siquiera se suba. Debido a que el filtrado ocurre en nuestro ordenador, es relativamente trivial bypassearlo.\n\nPor el contrario, un script \"Server-Side\", correrá del lado del servidor. Tradicionalmente, PHP era el lenguaje predominante del lado del servidor. Sin embargo, en los últimos años, otras opciones como C#, Node.js, Python, Ruby y más, se han empezado a usar ampliamente. El filtrado del lado del servidor tiende a ser más complicado de bypassear ya que no tienes el código delante de ti. Por lo general, tendremos que formar un payload que conforme con los filtros pero que nos siga permitiendo ejecutar nuestro código.\n\nCon esto en mente veremos algunos diferentes tipos de filtros.\n\n---------------------------------------------\n<h2>Extension Validation</h2>\nLas extensiones se usan (en teoría) para identificar los contenidos deun archivo. En la práctica son muy fáciles de cambiar, por lo que no significan mucho. Sin embargo, MS Windows los utiliza para identificar tipos de archivos, aunque los sistemas UNIX confían en otros métodos. Los filtros que comprueban las extensiones funcionan de una de dos maneras:\n\n- Meten aquellas extensiones especificadas en una lista negra (blacklist).\n- Meten aquellas extensiones especificadas en una lista blanca (whitelist).\n\n-------------------------------------------------------\n<h2>File Type Filtering</h2>\nDe forma similar, pero más intensiva, este tipo de filtro busca verificar que los contenidos del archivo son aceptables para subir. Veremos doos tipos de validación de archivos:\n\n- **Validación MIME:** Los tipos MIME (Multipurpose Internet Mail Extension) se usan como un identificador para archivos. Originalmente cuando eran transferidos como archivos adjuntos por email, pero ahora también cuando los archivos son transferidos por HTTP(S). El tipo MIME de un archivo subido está adjunto en la cabecera de la petición y se ve así:\n  \n  ![[Pasted image 20251215114336.png]]\n  \n  Los tipos MIME siguen el formato `<type>/<subtype>`. En la petición de arriba, puedes ver que la imagen \"spaniel.jpg\" se subió al servidor. Como es una imagen JPEG legítima, el tipo MIME para esta subida es \"image/jpeg\". El tipo MIME para un archivo puede ser comprobado del lado del cliente y/o del servidor. Sin embargo, como MIME está basado en la extensión del archivo, es extremadamente fácil de sobrepasar.\n- **Validación Magic Number:** Los magic numbers son una forma más precisa de determinar los contenidos de un archivo. Aqunue no son imposibles de falsificar. El \"magic number\" de un archivo es una string de bytes al comienzo del contenido que identifica el contenido. Por ejemplo, un archivo PNG tendría estos bytes arriba del archivo: `89 50 4E 47 0D 0A 1A 0A`.\n  \n  ![[Pasted image 20251215115706.png]]\n  \n  Al contrario que Windows, los sistemas UNIX usan magic numbers para identificar archivos. Sin embargo, al lidiar con archivos subidos, es posible comprobar los magic numbers en el archivo subido para asegurar que es seguro de aceptar. Esto no es ni de cerca una solución garantizada pero es más efectiva que la de arriba.\n\n----------------------------------------------\n<h2>File Length Filtering</h2>\nLos filtros de longitud se usan para prevenir archivos gigantes de ser subidos al servidor via formulario de subida (ya que puede causar starvation a recursos del servidor). Esto no será un problema normalmente al subir shells. Sin embargo, cabe tener en mente que si se espera un archivo muy pequeño puede llegar a serlo.\n\n---------------------------------------\n<h2>File Name Filtering</h2>\nComo ya hemos mencionado, los archivos subidos a un servidor deberían de ser únicos. Esto suele significar añadir algún aspecto random al nombre del archivo. Sin embargom una estrategia alternativa sería comprobar si un archivo con el mismo nombre ya existe en el servidor y dar un error si así es. Además el nombre de los archivos debería ser sanitizado para asegurar que no contienen caracteres \"malos\" que podrían causar problemas en el sistema de ficherors al subirse (null bytes, caracteres de control como `;`, etc.). \n\n>[!NOTE] Si esto ocurre en un sistema, es probable que la shell que subiste no tenga el mismo nombre que antes de subirla.\n\n-----------------------------------------------------\n<h2>File Content Filtering</h2>\nSistemas de filtrado más complejos pueden escanear el contenido entero de un archivo subido para asegurar que no está suplantando la extensión, tipo MIME o Magic Number. Es un proceso bastante más complejo que el de la mayoría de sistemas de filtrado que hay, por lo que no lo cubriremos en esta tarea, pero existen.\n\n---------------------------------------------\nEs importante dejar claro que ninguno de estos filtros es perfecto en sí mismo. Normalmente serán usados en conjunto, ofreciendo un filtro de múltiples capas. Cualquiera de estos puede ser aplicado del lado del cliente, del servidor o ambos.\n\nAdemás, diferentes frameworks y lenguajes vienen con sus propios métodos de filtrado y validación de archivos subidos. Como resultado, es posible que aparezcan exploits de lenguajes específicos, por ejemplo, hasta la versión 5 de PHP era posible bypassear el filtro de extensión mediante el null byte (`%00`) seguido de una extensión válida.",
    "modified": "2025-12-16T00:54:19"
  }
]