[
  {
    "title": "2. The Rust Dance",
    "path": "/apuntes/ctfs/1-talent-arena/2026/3-reverse-engineering/2-the-rust-dance/",
    "src": "content/Ciberseguridad/CTFs/1. Talent Arena/2026/3. Reverse Engineering/2. The Rust Dance.md",
    "breadcrumb": "CTFs > 1. Talent Arena > 2026 > 3. Reverse Engineering",
    "content": "1. Empezamos comprobando el tipo de archivo que tenemos en frente.\n   ![[Pasted image 20260210201613.png]]\n2. Ahora vamos a ejecutar el código una vez para ver su comportamiento.\n   ![[Pasted image 20260210201659.png]]\n   Parece que debemos de introducir el código correcto para que el programa nos devuelva la flag.\n3. Vamos a hacer una serie de comprobaciones para ver qué strings hay dentro del código.\n\t1. Empezamos investigando las strings con `strings ./rust-dance`.\n\t   ![[Pasted image 20260210202014.png]]\n\t   Pero hay demasiadas.\n\t   ![[Pasted image 20260210202041.png]]\n\t2. Así que seremos un poco más selectivos.\n\t   ![[Pasted image 20260210202235.png]]\n\t   Aquí vemos algunas coincidencias, pero (aunque hay más) no vemos nada muy interesante.\n\t3. Vamos a observar trazas dinámicas, para ello usamos `strace` y filtramos después.\n\t   ![[Pasted image 20260210202548.png]]\n\t   ![[Pasted image 20260210202734.png]]\n\t   Como `strace` no revela comparaciones en `libc`, el siguiente paso es usar `ltrace` para ver si `memcmp/strcmp/bcmp` existen. Sin embargo, nos ayuda a conocer el punto en el que introducir un `breakpoint` más adelante.\n\t4. Usamos `ltrace`.\n\t   ![[Pasted image 20260210203610.png]]\n\t   Parece que no hay ninguna llamada típica por lo que parece que NO hay una comprobación directa entre dos strings. Lo más probable es que la validación la haga en el código propio sin acceder a más valores de memoria.\n4. Vamos a descompilar el binario con `ghidra`.\n\t1. Abrimos el archivo en `ghidra` y lo analizamos.\n\t   ![[Pasted image 20260211191947.png]]\n\t2. Buscamos la string de `Unlock code`.\n\t   ![[Pasted image 20260211192435.png]]\n\t   ![[Pasted image 20260211192449.png]]\n\t   Esto nos lleva a la función que lo imprime.\n\t3. Si hacemos doble click sobre la referencia de función que lo imprime:\n\t   ![[Pasted image 20260211192604.png]]\n\t   Nos lleva aquí:\n\t   ![[Pasted image 20260211192646.png]]\n\t   Donde hay otras dos referencias:\n\t   ![[Pasted image 20260211192720.png]]\n\t   Hacemos doble click en la primera\n\t4. Se nos cargará la función en el Decompile (a la derecha) y después de buscar un rato encontramos el bucle que realiza operaciones contra nuestro string. Primero se valida si el input tiene 19 (`0x13`) caracteres exactamente. Si es así comienza las transformaciones.\n\t   ![[Pasted image 20260211202813.png]]\n\t   ![[Pasted image 20260211202838.png]]\n5. Son más de 700 lineas de operaciones, vueltas y comprobaciones, es demasiado para un humano con poco tiempo, por lo que se lo pasaremos a nuestro mejor amigo: `ChatGPT`.\n6. Le pasamos todo el contenido de `.rodata` a ChatGPT.\n   ![[Pasted image 20260211204023.png]]\n7. Con el contenido de `.rodata` y el bucle de comprobación, la IA nos devuelve un código que al ejecutar puede obtener el \"Unlock code\".\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# -------------------------\n# Helpers (rotaciones)\n# -------------------------\ndef rol8(x, r):\n    r &= 7\n    return ((x << r) | (x >> (8 - r))) & 0xFF\n\ndef ror8(x, r):\n    r &= 7\n    return ((x >> r) | (x << (8 - r))) & 0xFF\n\ndef rol4(x):\n    # swap nibbles (su propio inverso)\n    return ((x << 4) | (x >> 4)) & 0xFF\n\n# -------------------------\n# Constantes (sacadas de .rodata, según tu dump)\n# -------------------------\nKEY_00103CF0 = [\n    0x87, 0x9e, 0xb5, 0xcc, 0xe3, 0xfa, 0x11, 0x28,\n    0x3f, 0x56, 0x6d, 0x84, 0x9b, 0xb2, 0xc9, 0xe0\n]\n\nADD_00103D10 = [\n    0x33, 0xCC, 0x35, 0xCA, 0x37, 0xC8, 0x39, 0xC6,\n    0x3B, 0xC4, 0x3D, 0xC2, 0x3F, 0xC0, 0x41, 0xBE\n]\n\n# DWords objetivo tras el nibble-swap (porque el OR da 0 => cada XOR debe ser 0)\n# buf[0:4]  == 0x4694ac0e\n# buf[4:8]  == 0x72be6fc6\n# buf[8:12] == 0xee795db7\n# buf[12:16]== 0xa2edd0e2\nTARGET16_AFTER_NIBBLE = [\n    0x0e, 0xac, 0x94, 0x46,\n    0xc6, 0x6f, 0xbe, 0x72,\n    0xb7, 0x5d, 0x79, 0xee,\n    0xe2, 0xd0, 0xed, 0xa2\n]\n\n# Bytes finales tras rol4 (lo que compara el if)\nPOST16_18_ROL4 = [0xC6, 0x28, 0x8A]\n\n# -------------------------\n# Shift exacto del bucle (según el ensamblado)\n# -------------------------\ndef shift_even(i, c):\n    # ECX = floor(i/7)\n    q7 = i // 7\n    # EDX = ((((i - q7) >> 1) + q7) >> 2)\n    edx = (((i - q7) >> 1) + q7) >> 2\n    # R9D = edx*7\n    r9 = edx * 7\n    # CL = c - r9  (y luego rotate)\n    return (c - r9) & 7\n\ndef shift_odd(i, c):\n    # en ensamblado: (floor(i/5) * 5) y luego c - eso\n    q5 = i // 5\n    edx = q5 * 5\n    return (c - edx) & 7\n\ndef invert_rotation(buf19_after):\n    \"\"\"\n    Invierte el bucle que rota 19 bytes (i=0..18, c=1..19).\n    \"\"\"\n    b = buf19_after[:]\n    for i in range(18, -1, -1):\n        c = i + 1\n        sh = shift_even(i, c) if (i & 1) == 0 else shift_odd(i, c)\n        if (i & 1) == 0:\n            # forward: ROL -> inverse: ROR\n            b[i] = ror8(b[i], sh)\n        else:\n            # forward: ROR -> inverse: ROL\n            b[i] = rol8(b[i], sh)\n    return b\n\n# -------------------------\n# Inversión total\n# -------------------------\ndef recover_unlock():\n    # (1) Invertir nibble-swap de los 16 primeros bytes\n    after_padd = [rol4(x) for x in TARGET16_AFTER_NIBBLE]\n\n    # (2) Invertir PADDB (restar vector ADD_00103D10)\n    after_rotate_0_15 = [(b - k) & 0xFF for b, k in zip(after_padd, ADD_00103D10)]\n\n    # (3) Invertir bytes 16..18:\n    #     forward: b += [0x43,0xBC,0x45] ; rol4(b)\n    #     inverse: ror4(b) ; b -= [0x43,0xBC,0x45]\n    pre_add = [rol4(x) for x in POST16_18_ROL4]  # inverse rol4 == rol4\n    b16 = (pre_add[0] - 0x43) & 0xFF\n    b17 = (pre_add[1] - 0xBC) & 0xFF\n    b18 = (pre_add[2] - 0x45) & 0xFF\n\n    buf_after_rotation = after_rotate_0_15 + [b16, b17, b18]\n\n    # (4) Invertir el bucle de rotaciones para obtener el buffer justo después del shuffle inicial\n    buf_pre_loop = invert_rotation(buf_after_rotation)\n\n    # (5) Invertir el “shuffle SSE”:\n    #     En ensamblado realmente es: out[0..15] = reverse( (in[3..18] ^ KEY) )\n    out0_15 = buf_pre_loop[:16]\n    in_3_18_xored = list(reversed(out0_15))\n    in_3_18 = [b ^ k for b, k in zip(in_3_18_xored, KEY_00103CF0)]\n\n    # (6) Recuperar in[0..2] desde buf[16..18]:\n    #     buf[16] = in[2]^0x70, buf[17] = in[1]^0x59, buf[18]=in[0]^0x42\n    in2 = buf_pre_loop[16] ^ 0x70\n    in1 = buf_pre_loop[17] ^ 0x59\n    in0 = buf_pre_loop[18] ^ 0x42\n\n    unlock = bytes([in0, in1, in2] + in_3_18)\n    return unlock\n\nif __name__ == \"__main__\":\n    code = recover_unlock()\n    print(code.decode(\"latin1\"))\n\n```\n\n8. Si ahora ejecutamos dicho código:\n   ![[Pasted image 20260211204250.png]]\n9. Introducimos dicho código en el programa.\n   ![[Pasted image 20260211204330.png]]",
    "modified": "2026-02-12T01:08:37"
  },
  {
    "title": "1. Introduction",
    "path": "/apuntes/thm/maquinas/2-medium/7-include/1-introduction/",
    "src": "content/Ciberseguridad/THM/Maquinas/2. Medium/7. Include/1. Introduction.md",
    "breadcrumb": "THM > Maquinas > 2. Medium > 7. Include",
    "content": "![[Pasted image 20260211204950.png]]\n\nThis challenge is an initial test to evaluate your capabilities in web pentesting, particularly for server-side attacks. Start the VM by clicking the `Start Machine` button at the top right of the task.\n\nYou will find all the necessary tools to complete the challenge, like Nmap, PHP shells, and many more on the AttackBox.  \n\n_\"Even if it's not accessible from the browser, can you still find a way to capture the flags and sneak into the secret admin panel?\"_",
    "modified": "2026-02-12T01:08:37"
  },
  {
    "title": "0. Include",
    "path": "/apuntes/thm/maquinas/2-medium/7-include/0-include/",
    "src": "content/Ciberseguridad/THM/Maquinas/2. Medium/7. Include/0. Include.md",
    "breadcrumb": "THM > Maquinas > 2. Medium > 7. Include",
    "content": "[[Ciberseguridad/THM/Maquinas/2. Medium/7. Include/1. Introduction]]\n[[Ciberseguridad/THM/Maquinas/2. Medium/7. Include/2. Getting the Flags]]",
    "modified": "2026-02-12T01:08:37"
  },
  {
    "title": "2. Getting the Flags",
    "path": "/apuntes/thm/maquinas/2-medium/7-include/2-getting-the-flags/",
    "src": "content/Ciberseguridad/THM/Maquinas/2. Medium/7. Include/2. Getting the Flags.md",
    "breadcrumb": "THM > Maquinas > 2. Medium > 7. Include",
    "content": "<h2>¿Cuál es la flag después de iniciar sesión en SysMon App?</h2>\n<h4>Escaneo Inicial</h4>\n1. Empezamos realizando un escaneo a todos los puertos de la IP.\n   ![[Pasted image 20260211205256.png]]\n2. Una vez tenemos el escaneo inicial vamos a lanzar un escaneo con todo contra estos puertos.\n   ![[Pasted image 20260211213811.png]]\n   ![[Pasted image 20260211213836.png]]\n   Podemos ver que el puerto 50000 está sirviendo un Apache 2.4.41 y el 4000 un Node.js en http, por lo que como siempre que vemos un servicio web, vamos a ver qué hay.\n\n<h4>Investigación de Puertos</h4>\n1. Vamos a ver qué hay en el puerto 50000.\n   ![[Pasted image 20260211214240.png]]\n2. Y en el puerto 4000.\n   ![[Pasted image 20260211214303.png]]\n\n<h4>Investigación Web</h4>\n1. Empezamos fuzzeando.\n\t1. En el puerto 50000.\n\t   ![[Pasted image 20260211221934.png]]\n\t2. En el puerto 4000.\n\t   ![[Pasted image 20260211222041.png]]\n2. Seguimos intentando SQL Injection.\n\t1. En el puerto 50000.\n\t   ![[Pasted image 20260211222327.png]]\n\t   ![[Pasted image 20260211222350.png]]\n\t   Capturé una petición para usarla con SQLMap (era un formulario POST) pero no había ningún parámetro inyectable.\n\t2. En el puerto 4000 no nos hace falta porque nos han dejado credenciales de acceso.\n\t   ![[Pasted image 20260211221457.png]]\n\n\n--------------------------------------\n<h2>¿Cuál es el contenido del archivo de texto escondido en /var/www/html?</h2>",
    "modified": "2026-02-12T01:08:37"
  },
  {
    "title": "0. Hammer",
    "path": "/apuntes/thm/maquinas/2-medium/6-hammer/0-hammer/",
    "src": "content/Ciberseguridad/THM/Maquinas/2. Medium/6. Hammer/0. Hammer.md",
    "breadcrumb": "THM > Maquinas > 2. Medium > 6. Hammer",
    "content": "[[Ciberseguridad/THM/Maquinas/2. Medium/6. Hammer/1. Introduction]]\n[[Ciberseguridad/THM/Maquinas/2. Medium/6. Hammer/2. Getting the Flags]]",
    "modified": "2026-02-12T01:08:37"
  }
]