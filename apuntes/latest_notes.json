[
  {
    "title": "7. Bypassing Client-Side Filtering",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/7-bypassing-client-side-filtering/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/7. Bypassing Client-Side Filtering.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "Empezaremos con la primera (y más débil) linea de defensa: filtrado del lado del cliente.\n\nComo mencionamos previamente, el filtrado del lado del cliente suele ser extremadamente fácil de bypassear. Como ocurre por completo en la máquina que puedes controlar, al tener acceso al código es fácil de modificar.\n\nHay cuatro maneras fáciles de bypassear los típicos filtros de subida del lado del cliente:\n\n1. Deshabilita JavaScript en tu navegador: Esto funcionará si el sitio web no requiere JavaScript para ofrecer funcionaliddades básicas.\n2. Intercepta y modifica la página entrante: Usando Burp Suite, podemos interceptar la página entrante y quitarle el filtro JavaScript antes de que tenga oportunidad de ejecutarse.\n3. Intercepta y modifica el archivo subido: Este método permite que la página se cargue de forma normal pero intercepta el archivo subido después de haber pasado los filtros pero cuando todavía no ha llegado al servidor.\n4. Manda el archivo directamente al punto de subida: Si puedes mandar el archivo directamente al punto de salida, puedes evitar filtros del navegador. El comando para dicho propósito sería algo así: `curl -X POST -F \"submit:<value>\" -F \"<file-parameter>:@<path-to-file>\" <site>`. Para poder usar este método deberías primero interceptar una petición de subida exitosa para ver parámetros, headers y demás.\n\nCubriremos los métodos 2 y 3 en profundidad debajo.\n\n-------------------------------------------------\nAsumamos que hemos encontrado una página de subida.\n\n![[Pasted image 20251215124519.png]]\n\nComo siempre, miraremos el código fuente. Aquí podemos ver una función JavaScript básica que comprueba el tipo MIME de los archivos subidos:\n\n![[Pasted image 20251215124652.png]]\n\nEn esta instancia podemos ver que el filtro está usando una whitelist para excluir cualquier tipo MIME que no sea `image/jpeg`.\n\nEl próximo paso es intentar una subida de archivo. Si seleccionamos JPEG, la función lo acepta y cualquier otra la rechaza.\n\nHabiendo establecido esto, arrancamos BurpSuite y recargamos la página. Veremos nuestra propia petición al sitio web pero lo que realmente queremos es ver es la respuesta del servidor, así que hacemos click derecho en la información interceptada, bajamos hasta \"Do Intercept\" y seleccionamos \"Response to this Request\".\n\n![[Pasted image 20251215124935.png]]\n\nCuando hacemos click en \"Forward\" arriba de la ventana, veremos la respuesta del servidor a nuestra petición. Aquí, podemos borrar, comentar o romper la función JavaScript antes de que tenga oportunidad de cargar.\n\n![[Pasted image 20251215125235.png]]\n\nHabiendo borrado la función, le damos de nuevo a \"Forward\" hasta que veamos que el sitio web ha terminado de cargarse y ahora ya podemos subir cualquier tipo de archivo a la página.\n\n![[Pasted image 20251215125327.png]]\n\n>[!IMPORTANT] Burp Suite no intercepta (por defecto) archivos JavaScript externos que la página cargue. Si necesitas editar un script que no esté en la página principal, necesitas ir a `Options > Intercept Client Requests` y editar la condición de la primera línea para eliminar `^js$|`:\n\n![[Pasted image 20251215125537.png]]\n\n---------------------------------------------------\nYa hemos bypasseado este filtro interceptando y eliminándolo antes de que cargue la página, pero intentémoslo hacer subiendo un archivo con una extensión y tipo MIME legítimos e interceptándolo y corrigiéndolo con BurpSuite.\n\nHabiendo recargado la página web, para poner el filtro en su lugar, tomemos la reverse shell que hemos usado antes y renombrémosla para que se llame \"shell.jpg\". Como el archivo cumple con la condición del tipo MIME, nuestro filtro del lado del cliente deja pasar nuestro payload sin quejas.\n\n![[Pasted image 20251215130752.png]]\n\nUna vez más, activamos Burp Suite y le damos a \"Upload\" para interceptar la petición.\n\n![[Pasted image 20251215130825.png]]\n\nObserva que el tipo MIME de nuestra shell PHP es `image/jpeg`. Cambiaremos esto a `text/x-php`, y la extensión de `.jpg` a `.php` y le daremos a forward.\n\n![[Pasted image 20251215130939.png]]\n\nAhora, al navegar a `http://demo.uploadvulns.thm/uploads/shell.php` habiendo activado un listener, recibiremos una conexión de la shell.\n\n![[Pasted image 20251215131029.png]]\n\n---------------------------------\nHemos cubierto en detalle dos formas de bypassear un filtro de subida de lado del cliente. Ahora es hora de que lo probemos. Ve a `java.uploadvulns.thm` y bypassea el filtro para conseguir una reverse shell. Recuerda escanear el sitio web con `gobuster`.\n\n1. Vamos al sitio web dado.\n   ![[Pasted image 20251215224146.png]]\n2. Escanearemos mientras tanto la página con `gobuster`.\n   ![[Pasted image 20251215225918.png]]\n3. Vamos a interceptar una subida de archivo con Burp Suite.\n\t1. Abrimos Burp Suite y su navegador y vamos al sitio web que nos dan.\n\t   ![[Pasted image 20251215224459.png]]\n\t2. Seleccionamos un archivo y activamos la intercepción.\n\t   ![[Pasted image 20251215224527.png]]\n\t3. Le damos a \"Upload\" y esperamos la petición.\n\t   ![[Pasted image 20251215224611.png]]\n4. El content type parece ser `image/png`.\n   ![[Pasted image 20251215224721.png]]\n5. Le damos a \"Forward\".\n   ![[Pasted image 20251215224812.png]]\n   Parece que se ha subido exitosamente.\n6. Vamos ahora a subir una `shell.php` y a capturar la respuesta.\n\t1. Editamos la shell.\n\t   ![[Pasted image 20251215225158.png]]\n\t2. Nos ponemos en escucha.\n\t   ![[Pasted image 20251215225244.png]]\n\t3. Subimos la shell y la interceptamos con Burp Suite.\n\t   ![[Pasted image 20251215225330.png]]\n\t   Parece que no nos deja.\n\t4. Le cambiamos la extensión a `.png`.\n\t   ![[Pasted image 20251215225504.png]]\n\t5. Ahora sí.\n\t   ![[Pasted image 20251215225523.png]]\n\t6. Vamos a interceptarlo.\n\t   ![[Pasted image 20251215225558.png]]\n\t7. Cambiamos el filename a `reverseshell.php` y content-type a `text/x-php`.\n\t   ![[Pasted image 20251215225716.png]]\n\t8. Le damos a forward hasta que ponga success.\n\t   ![[Pasted image 20251215225828.png]]\n7. Ahora debemos navegar a la shell, que basándonos en nuestro escaneo con `gobuster` seguramente esté en `/images`.\n   ![[Pasted image 20251215230007.png]]\n   La página parece quedarse cargando.\n8. Pero si volvemos al listener:\n   ![[Pasted image 20251215230034.png]]\n9. Ahora vamos al directorio que nos dan y leemos la flag.\n   ![[Pasted image 20251215230112.png]]",
    "modified": "2025-12-16T00:54:19"
  },
  {
    "title": "6. Filtering",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/6-filtering/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/6. Filtering.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "Hasta ahora hemos ignorado las defensas empleadas por los desarrolladores web para defenderse contra las vulnerabilidades de subidas de archivos. Desde ahora miraremos algunos de los mecanismos de defensa usados para prevenir la subida de archivos maliciosos y cómo circunvalarlos.\n\n----------------------------------\nPrimero, veamos las diferencias entre filtrado del lado del cliente y del lado del servidor.\n\nCuando hablamos sobre que un script sea \"Client-Side\", en el contexto de las aplicaciones web, nos referimos a que corre en el navegador del usuario en vez de en el propio servidor. JavaScript es prácticamente omnipresente como lenguaje de scripting del lado del cliente aunque existen alternativas. Sin importar el lenguaje, un script del lado del cliente se ejecuta en el navegador. En el contexto de la subida de archivos, esto significa que el filtrado ocurre antes de que el archivo siquiera se suba. Debido a que el filtrado ocurre en nuestro ordenador, es relativamente trivial bypassearlo.\n\nPor el contrario, un script \"Server-Side\", correrá del lado del servidor. Tradicionalmente, PHP era el lenguaje predominante del lado del servidor. Sin embargo, en los últimos años, otras opciones como C#, Node.js, Python, Ruby y más, se han empezado a usar ampliamente. El filtrado del lado del servidor tiende a ser más complicado de bypassear ya que no tienes el código delante de ti. Por lo general, tendremos que formar un payload que conforme con los filtros pero que nos siga permitiendo ejecutar nuestro código.\n\nCon esto en mente veremos algunos diferentes tipos de filtros.\n\n---------------------------------------------\n<h2>Extension Validation</h2>\nLas extensiones se usan (en teoría) para identificar los contenidos deun archivo. En la práctica son muy fáciles de cambiar, por lo que no significan mucho. Sin embargo, MS Windows los utiliza para identificar tipos de archivos, aunque los sistemas UNIX confían en otros métodos. Los filtros que comprueban las extensiones funcionan de una de dos maneras:\n\n- Meten aquellas extensiones especificadas en una lista negra (blacklist).\n- Meten aquellas extensiones especificadas en una lista blanca (whitelist).\n\n-------------------------------------------------------\n<h2>File Type Filtering</h2>\nDe forma similar, pero más intensiva, este tipo de filtro busca verificar que los contenidos del archivo son aceptables para subir. Veremos doos tipos de validación de archivos:\n\n- **Validación MIME:** Los tipos MIME (Multipurpose Internet Mail Extension) se usan como un identificador para archivos. Originalmente cuando eran transferidos como archivos adjuntos por email, pero ahora también cuando los archivos son transferidos por HTTP(S). El tipo MIME de un archivo subido está adjunto en la cabecera de la petición y se ve así:\n  \n  ![[Pasted image 20251215114336.png]]\n  \n  Los tipos MIME siguen el formato `<type>/<subtype>`. En la petición de arriba, puedes ver que la imagen \"spaniel.jpg\" se subió al servidor. Como es una imagen JPEG legítima, el tipo MIME para esta subida es \"image/jpeg\". El tipo MIME para un archivo puede ser comprobado del lado del cliente y/o del servidor. Sin embargo, como MIME está basado en la extensión del archivo, es extremadamente fácil de sobrepasar.\n- **Validación Magic Number:** Los magic numbers son una forma más precisa de determinar los contenidos de un archivo. Aqunue no son imposibles de falsificar. El \"magic number\" de un archivo es una string de bytes al comienzo del contenido que identifica el contenido. Por ejemplo, un archivo PNG tendría estos bytes arriba del archivo: `89 50 4E 47 0D 0A 1A 0A`.\n  \n  ![[Pasted image 20251215115706.png]]\n  \n  Al contrario que Windows, los sistemas UNIX usan magic numbers para identificar archivos. Sin embargo, al lidiar con archivos subidos, es posible comprobar los magic numbers en el archivo subido para asegurar que es seguro de aceptar. Esto no es ni de cerca una solución garantizada pero es más efectiva que la de arriba.\n\n----------------------------------------------\n<h2>File Length Filtering</h2>\nLos filtros de longitud se usan para prevenir archivos gigantes de ser subidos al servidor via formulario de subida (ya que puede causar starvation a recursos del servidor). Esto no será un problema normalmente al subir shells. Sin embargo, cabe tener en mente que si se espera un archivo muy pequeño puede llegar a serlo.\n\n---------------------------------------\n<h2>File Name Filtering</h2>\nComo ya hemos mencionado, los archivos subidos a un servidor deberían de ser únicos. Esto suele significar añadir algún aspecto random al nombre del archivo. Sin embargom una estrategia alternativa sería comprobar si un archivo con el mismo nombre ya existe en el servidor y dar un error si así es. Además el nombre de los archivos debería ser sanitizado para asegurar que no contienen caracteres \"malos\" que podrían causar problemas en el sistema de ficherors al subirse (null bytes, caracteres de control como `;`, etc.). \n\n>[!NOTE] Si esto ocurre en un sistema, es probable que la shell que subiste no tenga el mismo nombre que antes de subirla.\n\n-----------------------------------------------------\n<h2>File Content Filtering</h2>\nSistemas de filtrado más complejos pueden escanear el contenido entero de un archivo subido para asegurar que no está suplantando la extensión, tipo MIME o Magic Number. Es un proceso bastante más complejo que el de la mayoría de sistemas de filtrado que hay, por lo que no lo cubriremos en esta tarea, pero existen.\n\n---------------------------------------------\nEs importante dejar claro que ninguno de estos filtros es perfecto en sí mismo. Normalmente serán usados en conjunto, ofreciendo un filtro de múltiples capas. Cualquiera de estos puede ser aplicado del lado del cliente, del servidor o ambos.\n\nAdemás, diferentes frameworks y lenguajes vienen con sus propios métodos de filtrado y validación de archivos subidos. Como resultado, es posible que aparezcan exploits de lenguajes específicos, por ejemplo, hasta la versión 5 de PHP era posible bypassear el filtro de extensión mediante el null byte (`%00`) seguido de una extensión válida.",
    "modified": "2025-12-16T00:54:19"
  },
  {
    "title": "5. Remote Code Execution",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/5-remote-code-execution/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/5. Remote Code Execution.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "RCE nos permitiría ejecutar código de manera arbitraria en el servidor. Aunque esto es más probable que pase con un usuario con bajos privilegios como `www-data`, sigue siendo una vulnerabilidad muy seria. Tiende a ser explotado subiendo un programa en el mismo lenguaje que el backend. Este solía ser PHP, sin embargo, en tiempos más modernos, otros lenguajes backend se han impuesto (como Python Django y JavaScript en forma de Node.js).\n\n>[!IMPORTANT] En routed applications (aquellas donde las rutas de archivos son generadas dinámicamente) es más difícil para los atacantes explotar este tipo de vulnerabilidades ya que no pueden predecir el path de los archivos.\n\nHay dos manera principales de conseguir una RCE en un servidor web: webshells y reverse/bind shells. Idealmente, bind/reverse shells es el escenario perfecto para un atacante. Sin embargo, puede que tu única opción sea una webshell. Primero subimos el archivo y luego lo intentamos ejecutar, ya sea navegando directamente hacia él si el servidor lo permite o forzando a al app a que lo cargue.\n\n-------------------------------------------\n<h2>WebShells</h2>\nAsumamos que hemos encontrado una página con un formulario de subida:\n\n![[Pasted image 20251214170645.png]]\n\n¿Qué hacemos ahora? Bien empezaremos con un escaneo de `gobuster`:\n\n![[Pasted image 20251214170714.png]]\n\nParece que tenemos dos directorios: `uploads` y `assets`. Parece que cualquier archivo que subamos se subirá al directorio `/uploads`. Intentaremos subir la imagen del perrito de la tarea anterior.\n\n![[Pasted image 20251214170838.png]]\n\n![[Pasted image 20251214170845.png]]\n\nAhora, si vamos a `http://demo.uploadvulns.thm/uploads`, deberíamos ver que la imagen se ha subido.\n\n![[Pasted image 20251214170922.png]]\n\n![[Pasted image 20251214170941.png]]\n\nVale, podemos subir imágenes. Intentémoslo con una webshell ahora.\n\nSabemos que este servidor web corre con un backend PHP, por lo que podemos empezar con la creación de la shell, en un entorno real puede que tengamos que realizar más enumeración.\n\nUna webshell simple funciona tomando un parámetro y ejecutándolo como comando de sistema. En PHP, la sintaxis sería:\n\n```php\n<?php\necho system($_GET[\"cmd\"]);\n?>\n```\n\nEste código toma el parámetro GET cmd y lo ejecuta como comando. Luego muestra el output por pantalla. Probemos a subirla y a ejecutar algún comando.\n\n![[Pasted image 20251214171444.png]]\n\nHa funcionado, por lo que ahora podríamos usar esta webshell para leer archivos en el sistema o para mejorarla a una reverse shell.\n\n>[!NOTE] Cuando tenemos una webshell, muchas veces es más legible mirar el código fuente de la página.\n\n----------------------------------\n<h2>Reverse Shells</h2>\nEl proceso de subir una reverse shell es casi idéntico al de subir una webshell. Usaremos la reverse shell de Pentest Monkey que viene por defecto en Kali, aunque también la puedes descargar [aquí](https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php).\n\nNecesitas editar la línea 49, que ahora mismo dice `$ip = '127.0.0.1'; //CHANGE THIS`. Lo siguiente que debemos hacer es arrancar un listener en el puerto que elijamos.\n\n![[Pasted image 20251214172414.png]]\n\nAhora subimos la shell y la activamos navegando a ella: `http://demo.uploadvulns.thm/uploads/shell.php`. El nombre de la shell será el que nosotros le pongamos (`php-reverse-shell.php` por defecto).\n\n![[Pasted image 20251214172528.png]]\n\n---------------------------------------\nAhora navega a `shell.uploadvulns.thm` y completa esta tarea.\n\n1. Vamos a la página.\n   ![[Pasted image 20251214175129.png]]\n2. Hacemos un escaneo con `gobuster`.\n   ![[Pasted image 20251214180746.png]]\n   Podemos intuir que lo que subimos se está guardando en `/resources`.\n3. Hacemos una webshell en php.\n   ![[Pasted image 20251214180958.png]]\n4. La subimos.\n   ![[Pasted image 20251214181029.png]]\n   ![[Pasted image 20251214181055.png]]\n   Se ha subido exitosamente.\n5. Navegamos hasta la shell y le metemos un comando (`whoami`) para comprobar que funciona.\n   ![[Pasted image 20251214181154.png]]\n6. Vamos a leer el contenido de `/var/www` con `ls /var/www`.\n   ![[Pasted image 20251214181239.png]]\n7. Leemos el contenido de la flag con `cat /var/www/flag.txt`.\n   ![[Pasted image 20251214181319.png]]",
    "modified": "2025-12-15T00:55:45"
  },
  {
    "title": "3. General Methodology",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/3-general-methodology/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/3. General Methodology.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "Bien, ya tenemos un punto de subida de archivos en una página web. ¿Cómo lo explotamos?\n\nComo con cualquier tipo de hacking, la enumeración es clave. Cuanto más entendamos sobre nuestro entorno, más seremos capaces de hacer con esa información. Algunas buenas ideas son:\n\n- Mirar el código fuente de la página.\n- Escanear directorios con fuerza bruta (`gobuster`, por ejemplo).\n- Interceptar peticiones de subida de archivos con BurpSuite.\n- Extensiones como Wappalyzer pueden ofrecer información valiosa en un vistazo.\n\nCon un entendimiento básico de cómo la web trata nuestro input, podemos tratar de tocar por algunos sitios y ver qué y qué no podemos subir. Si el sitio web usa filtros del lado del cliente, podemos buscar estos filtros e intentar bypassearlos. Si usa filtros del lado del servidor, debemos adivinar qué busca el filtro e intentar algo ligeramente diferente. Subir archivos destinados a provocar errores puede ser muy útil. Herramientas como Burp Suite u OWASP Zap pueden ser de gran ayuda en esta fase.",
    "modified": "2025-12-14T00:57:26"
  },
  {
    "title": "4. Overwriting Existing Files",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/4-overwriting-existing-files/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/4. Overwriting Existing Files.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "Cuando se suben archivos a un servidor, se deberían de hacer un número de comprobaciones para asegurar que el archivo no sobrescribirá nada que ya exista en el servidor. Una práctica común es asignar un nombre al archivo ya sea aleatorio o con la fecha y hora de subida. Si un archivo con el mismo nombre ya existe, el servidor debe mandar un mensaje de error conforme ese nombre ya existe. También son relevantes los permisos ya que un archivo que contenga la web no debería ser escribible por el usuario.\n\nSi no se toman dichas precauciones, podemos ser capaces de sobrescribir archivos existentes en el servidor. \n\n>[!CAUTION] Usaremos `demo.uploadvulns.thm` para todas las demostraciones. Es puramente para propósitos demostrativos y no está disponible en la máquina virtual.\n\nEn la siguiente imagen tenemos una página web con un formulario de subida.\n\n![[Pasted image 20251213142409.png]]\n\nPuede que necesites enumerar más que esto para un reto real. Sin embargo, por esta vez, miraremos el código fuente de la página.\n\n![[Pasted image 20251213142556.png]]\n\nAquí podemos ver el código responsable de representar la imagen que vemos. Sale de un archivo llamado `spaniel.jpg` dentro de un directorio llamado `images`.\n\nLa pregunta aquí es: ¿podemos sobrescribirlo?\n\nVamos a descargarnos una imagen diferente y a llamarla `spaniel.jpg`.\n\n![[Pasted image 20251213142900.png]]\n\nAhora la subimos a ver qué pasa.\n\n![[Pasted image 20251213142914.png]]\n\nNuestro ataque ha sido exitoso. Hemos conseguido sobrescribir el archivo `images/spaniel.jpg` con nuestra propia copia.\n\n-------------------------------------------\nAhora pongámoslo a prueba. Abre el navegador y navega a `http://overwrite.uploadvulns.thm`. Tu objetivo es sobrescribir el archivo con uno tuyo.\n\n1. Navegamos a la dirección dada.\n   ![[Pasted image 20251213143124.png]]\n2. Inspeccionamos el código fuente con `Ctrl + U`.\n   ![[Pasted image 20251213143158.png]]\n   Aquí podemos ver que el fondo cargado es una imagen llamada `mountains.jpg` cargada desde el directorio `images`.\n3. Vamos a descargarnos una imagen y a llamarla de la misma forma.\n   ![[Pasted image 20251213143334.png]]\n4. Le damos a `Select File`, seleccionamos la imagen que nos acabamos de descargar y le damos a `Upload`.\n   ![[Pasted image 20251213143448.png]]\n5. Obtenemos la flag.\n   ![[Pasted image 20251213143507.png]]",
    "modified": "2025-12-14T00:57:26"
  }
]