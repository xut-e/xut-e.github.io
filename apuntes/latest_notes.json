[
  {
    "title": "1. Windows Privilege Escalation",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/3-windows-privilege-escalation/1-windows-privilege-escalation/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/3. Windows Privilege Escalation/1. Windows Privilege Escalation.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 3. Windows Privilege Escalation",
    "content": "Dicho de manera simple, la escalada de privilegios consiste en usar el acceso dado a un host con el usuario A para ganar acceso al usuario B para, eventualmente, obtener permisos de administrador. Aunque queremos llegar a root, puede que tengamos que escalar a otras cuentas intermedias (sin privilegios) antes de encontrar un vector de escalada a root.\n\nGanar acceso a las diferentes cuentas puede ser tan simple como encontrar credenciales en archivos de texto u hojas de cálculo, pero ese no siempre será el caso.\n\nDependiendo de la situación podemos necesitar abusar alguna de las siguientes debilidades:\n\n- Malas configuraciones en servicios de Windows o tareas programadas.\n- Privilegios excesivos otorgados a nuestra cuenta.\n- Software vulnerable.\n- Perderse parches de seguridad de Windows.\n\nAntes de ver las técnicas, echemos un vistazo a diferentes tipos de cuenta en un sistema Windows.\n\n---------------------------------------------\n<h2>Usuarios de Windows</h2>\nLos sistemas Windows tienen principalmente 2 tipos de usuarios. Dependiendo del nivel de acceso, podemos categorizarlos en:\n\n| Usuario            | Explicación                                                                                                                                                                                              |\n| ------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Administrators** | Estos usuarios tienen los mayores privilegios. Pueden cambiar cualquier parámetro de configuración y acceder a cualquier archivo del sistema.                                                            |\n| **Standard Users** | Estos usuarios pueden acceder al ordenador pero sólo realizar tareas limitadas. Típicamente estos usuarios no pueden hacer cambios permanentes o esenciales al sistema y están limitados a sus archivos. |\n\nCualquier usuario con privilegios administrativos, será parte del grupo **Administrators**.",
    "modified": "2025-11-28T00:48:12"
  },
  {
    "title": "8. Privilege Escalation - Cron Jobs",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/2-linux-privilege-escalation/8-privilege-escalation-cron-jobs/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/2. Linux Privilege Escalation/8. Privilege Escalation - Cron Jobs.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 2. Linux Privilege Escalation",
    "content": "La tareas Cron se usan para ejecutar scripts o binarios en momentos específicos. Por defecto, corren con los privilegios de sus dueños y no del usuario actual. Mientras que las tareas cron bien configuradas no son vulnerables, pueden ofrecer un vector de escalada de privilegios bajo ciertas condiciones. La idea es simple, si hay una tarea programada que corre con permisos de administrador y podemos cambiar el script que se ejecuta, entonces nuestro script correrá con permisos de administrador.\n\nLas configuraciones de las tareas cron se guardan como \"crontabs\" (cron tables) para ver cuándo será la próxima vez que correrá una tarea.\n\nCada usuario del sistema tiene su archivo crontab y puede correr tareas específicas estén logueados o no. Como puedes esperar, nuestra meta es encontrar una tarea cron configurada por root que lea nuestro script.\n\nCualquier usuario puede leer el archivo haciendo `cat /etc/crontab`.\n\nAunque algunos entornos CTF tengan tareas cron cada minuto o cada 5 minutos, más normalmente verás tareas ejecutándose cada día, semana o mes.\n\n![[Pasted image 20251127152548.png]]\n\nPuedes ver el script `backup.sh` configurado para ejecutarse cada minuto. El contenido del archivo muestra un script simple que crea un backup del archivo `prices.xls`.\n\n![[Pasted image 20251127152727.png]]\n\nComo nuestro usuario puede acceder a este script, podemos modificarlo para crear una reverse shell.\n\nEl script usará herramientas disponibles en el sistema para establecerla por lo que es importante saber qué opciones hay disponibles. En nuestro caso, el archivo se verá así:\n\n![[Pasted image 20251127152910.png]]\n\nDespués ejecutamos un listener en nuestra máquina:\n\n![[Pasted image 20251127152932.png]]\n\nSiempre merece la pena comprobar crontab ya que a veces puede llevar a vectores de escalada de privilegios fácilmente. Este escenario no es raro en empresas:\n\n1. Los sysadmins necesitan ejecutar un script regularmente.\n2. Crean un trabajo cron para hacerlo.\n3. Después de un tiempo, el script se vuelve inútil y lo borran.\n4. No limpian la tarea cron.",
    "modified": "2025-11-28T00:48:12"
  },
  {
    "title": "9. Privilege Escalation - PATH",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/2-linux-privilege-escalation/9-privilege-escalation-path/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/2. Linux Privilege Escalation/9. Privilege Escalation - PATH.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 2. Linux Privilege Escalation",
    "content": "Si un archivo, para el que tu usuario tiene permisos de escritura, está situado en el PATH, podrías, potencialmente, secuestrar una aplicación para correr un script. PATH en Linux, es una variable de entorno que le dice al sistema operativo dónde buscar ejecutables. Para cualquier comando que no esté construido en la shell o definido en el PATH, Linux empezará a buscar en directorios bajo el PATH.\n\nEl PATH se ve así:\n\n![[Pasted image 20251127161215.png]]\n\nEsto podemos usarlo en nuestro favor de la siguiente manera:\n\nPrimero debemos responder a las siguientes preguntas:\n\n1. ¿Qué directorios están bajo el $PATH?\n2. ¿Tiene permisos de escritura en alguno de estos nuestro usuario actual?\n3. ¿Puedes modificar el $PATH?\n4. ¿Hay algún script/aplicación que puedas arrancar que sea afectada por esta vulnerabilidad?\n\nCon propósitos de demostración, usaremos el siguiente script:\n\n![[Pasted image 20251127162230.png]]\n\n>[!CAUTION] Añade: `#include <stdlib.h> // PARA system()` (para que no pete).\n\nEste script intenta lanzar un binario de sistema llamado `thm` pero se puede replicar con cualquier binario.\n\nCompilamos este en un ejecutable con bit SUID configurado.\n\n![[Pasted image 20251127162322.png]]\n\nNuestro usuario ahora tiene acceso al script \"path\" con SUID.\n\n![[Pasted image 20251127162406.png]]\n\nSi ejecutamos \"path\", este buscará un archivo ejecutable llamado \"thm\" en todos los directorios listados en PATH. Si alguno de los directorios listados en PATH es escribible, podríamos crear un binario \"thm\" y el script \"path\" lo ejecutaría. Como tiene configurado el SUID, correría con permisos de root.\n\nPara encontrar estos directorios usamos: `find / -writable 2>/dev/null | cut -d \"/\" -f 2 | sort -u`\n\n![[Pasted image 20251127163015.png]]\n\nAlgunos escenarios CTF pueden presentar diferentes directorios pero un sistema normal mostraría algo similar a lo que vemos arriba. Si lo comparamos al path podemos ver cuáles son.\n\n![[Pasted image 20251127163546.png]]\n\nComo vemos directorios como `/usr/local/bin`, podemos ajustar nuestro comando de búsqueda de la siguiente manera: `find / -writable 2>/dev/null | cut -d \"/\" -f 2,3 | grep -v proc | sort -u`\n\n![[Pasted image 20251127164219.png]]\n\nPor desgracia, no son escribibles.\n\nEl directorio más fácilmente escribible es `/tmp`. Pero este no es un directorio de PATH, por lo que necesitamos añadirlo: `export PATH=/tmp:$PATH`. \n\n![[Pasted image 20251127164429.png]]\n\nAhora ya buscará en `/tmp` por lo que si creamos el binario allí se ejecutará.\n\n![[Pasted image 20251127164436.png]]\n\nLo que hace que esta escalada de privilegios funcione es que el script path se ejecuta con permisos de administrador.\n\n![[Pasted image 20251127164939.png]]",
    "modified": "2025-11-28T00:48:12"
  },
  {
    "title": "7. Privilege Escalation - Capabilities",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/2-linux-privilege-escalation/7-privilege-escalation-capabilities/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/2. Linux Privilege Escalation/7. Privilege Escalation - Capabilities.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 2. Linux Privilege Escalation",
    "content": "Otro método que los sysadmins pueden usar para incrementar el nivel de privilegios de un proceso o binario son las \"Capabilities\". Las capabilities ayudan a manejar privilegios a un nivel más granular. Por ejemplo, si el analista SOC necesita usar una herramienta que necesite iniciar conexiones socket, un usuario normal no debería ser capaz de hacerlo. Si el sysadmin no quiere darle privilegios elevados a este usuario, pueden cambiar las capabilities del binario. Como resultado, el binario podría ejecutar el proceso sin la necesidad de un usuario con privilegios superiores.\n\nPodemos usar la herramienta `getcap` para listar capabilities habilitadas.\n\n![[Pasted image 20251127130635.png]]\n\nCuando se ejecuta como usuario no privilegiado, `getcap -r /` genera una cantidad inmensa de errores por lo que conviene redirigirlos a la basura (`2>/dev/null`).\n\nNi vim ni su copia tienen el bit SUID configurado por lo que este vector no es descubrible listando archivos en busca de SUID.\n\n![[Pasted image 20251127130928.png]]\n\nGTFOBins tiene una buena lista de binarios que pueden ser usados para la escalada de privilegios si encontramos alguna capability configurada.\n\nNotamos que vim puede ser usada con el siguiente comando y payload:\n\n![[Pasted image 20251127131036.png]]\n\nEsto lanzará una shell root:\n\n![[Pasted image 20251127131056.png]]\n\n>[!TIP] Esto funciona: `./vim -c ':py3 import os; os.setuid(0); os.execl(\"/bin/sh\", \"sh\", \"-c\", \"exec /bin/bash -p\")'` y después `python3 -c 'import pty; pty.spawn(\"/bin/bash\")'` para estabilizarla.",
    "modified": "2025-11-28T00:48:12"
  },
  {
    "title": "11. Capstone Challenge",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/2-linux-privilege-escalation/11-capstone-challenge/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/2. Linux Privilege Escalation/11. Capstone Challenge.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 2. Linux Privilege Escalation",
    "content": "A estas alturas deberíamos tener un buen entendimiento de los vectores de escalada de privilegios en Linux por lo que este reto debería ser fácil.\n\nHas ganado acceso a una gran instalación científica por SSH. Intenta elevar tus privilegios hasta ser root.\n\nNo te dejes ningún método por comprobar, la escalada de privilegios suele ser más a menudo un arte que una ciencia.\n\n-------------------------------\n<h2>Challenge</h2>\n1. Entramos por SSH con las credenciales otorgadas.\n   ![[Pasted image 20251127193448.png]]\n2. Empezaremos por el primer método estudiado: Kernel Exploits.\n\t1. Listamos el kernel.\n\t   ![[Pasted image 20251127193611.png]]\n\t2. Buscamos en Github (no hay nada) y buscamos en Exploit-DB, donde encontramos lo siguiente.\n\t   ![[Pasted image 20251127194047.png]]\n\t   No hay ninguna verificada, por lo que de momento no nos la vamos a jugar. \n3. Seguimos con el siguiente método: sudo.\n\t1. Probamos con `sudo -l`.\n\t   ![[Pasted image 20251127194334.png]]\n\t   No podemos, pasamos al siguiente método.\n4. El siguiente método es SUID.\n\t1. Empezamos buscando los archivos con los bits SUID y/o SGID configurados.\n\t   ![[Pasted image 20251127194721.png]]\n\t   Vamos a compararlos en GTFOBins.\n\t2. Hemos encontrado que base64 con SUID nos permite leer archivos.\n\t   ![[Pasted image 20251127194831.png]]\n\t3. Vamos a leer `/etc/shadow`.\n\t   ![[Pasted image 20251127195115.png]]\n\t   Hemos encontrado los hashes de root y missy.\n\t4. Veamos que grupos/id tiene missy.\n\t   ![[Pasted image 20251127195236.png]]\n\t   Nada muy interesante.\n\t5. Intentaremos crackear los hashes con John the Ripper.\n\t\t1. Metemos los archivos shadow y passwd y los combinamos con `unshadow`.\n\t\t   ![[Pasted image 20251127195921.png]]\n\t\t2. Investigamos que hash son las contraseñas en nuestros propios apuntes.\n\t\t   ![[Pasted image 20251127195854.png]]\n\t\t3. Usamos John para crackearlos.\n\t\t   ![[Pasted image 20251127202448.png]]\n\t\t   De momento parece que hemos encontrado la contraseña de missy.\n5. Vamos a probar con el siguiente método: Capabilities.\n\t1. Usamos `getcap -r / 2>/dev/null` para obtener las capabilities.\n\t   ![[Pasted image 20251127201310.png]]\n\t2. Comparamos en GTFOBins.\n\t   ![[Pasted image 20251127201439.png]]\n\t   Ninguno coincide.\n6. Vamos a probar el siguiente método: Cron Jobs.\n\t1. Miramos el archivo `/etc/crontab`.\n\t   ![[Pasted image 20251127201553.png]]\n\t   No hay nada.\n7. Seguimos con el siguiente método: PATH.\n\t1. Listamos el PATH.\n\t   ![[Pasted image 20251127201737.png]]\n\t   Parece interesante la ruta `/home/leonard/scripts`.\n\t2. No existe esa ruta. Podríamos intentar escalar creando el directorio y metiendo algún binario dentro más adelante.\n\t   ![[Pasted image 20251127201927.png]]\n8. Vamos a seguir con el siguiente y último método: NFS.\n\t1. Listamos `/etc/exports`.\n\t   ![[Pasted image 20251127202245.png]]\n\t   Está vacío, así que nada.\n9. De momento lo más prometedor que hemos encontrado es la contraseña de missy, así que seguiremos por ahí. Nos logueamos con missy.\n   ![[Pasted image 20251127202532.png]]\n   Vamos a repetir los pasos con missy, a ver qué encontramos.\n10. Vaya, resulta que con missy sí podemos ejecutar ciertos comandos como sudo.\n    ![[Pasted image 20251127202729.png]]\n11. Vamos a ver qué podemos conseguir en GTFOBins.\n    ![[Pasted image 20251127202831.png]]\n    Parece que sí que es útil heheh.\n12. Seguimos los pasos.\n    ![[Pasted image 20251127202918.png]]\n13. Buscamos la flag.\n    ![[Pasted image 20251127203033.png]]\n    Por el directorio donde está podemos intuir que la flag era leíble sin permisos de root desde la cuenta de missy. Por lo que seguramente también podamos leer ya la flag2.\n14. Buscamos la flag 2.\n    ![[Pasted image 20251127203215.png]]\n\n>[!SUCCESS] Hemos conseguido escalar privilegios y obtener las dos flags.",
    "modified": "2025-11-28T00:48:12"
  }
]