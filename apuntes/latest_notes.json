[
  {
    "title": "4. Practical - OTP Leakage",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/5-multi-factor-authentication/4-practical-otp-leakage/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/5. Multi-Factor Authentication/4. Practical - OTP Leakage.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 5. Multi-Factor Authentication",
    "content": "<h2>Filtración OTP</h2>\nLa filtración OTP en la respuesta XHR (XMLHttpRequest), típicamente ocurre debido a la implementación pobre de 2FA o programación insegura. Algunas razones comunes por lo que esto ocurre son:\n\n<h4>Validación del Lado del Servidor y Devolución de Información Sensible</h4>\nEn algunas aplicaciones diseñadas pobremente, el servidor valida el OTP y más que sólo confirmar el éxito o fracaso, devuelve el OTP en la respuesta. Esto es comúnmente hecho no intencionalmente, como parte del debugging, registro o prácticas pobres de manejo de respuestas.\n<h4>Falta de Prácticas de Seguridad Adecuadas</h4>\nLos desarrolladores pueden pasar por alto las implicaciones de seguridad de exponer información sensible como los OTP en las respuestas API. Esto suele pasar cuando los desarrolladores están concentrados en hacer la aplicación funcional sin considerar cómo los atacantes podrían explotar estas respuestas.\n<h4>Información de Depuración Dejada en Producción</h4>\nDurante el desarrollo o la fase de pruebas, los desarrolladores pueden incluir depuración detallada en las respuestas para ayudar a diagnosticar errores. Si estas no se eliminan en producción, pueden revelar información sensible para los atacantes.\n\n------------------------------------------------------\n<h2>Explotación</h2>\nVamos a http://mfa.thm/labs/first.\n\n![[Pasted image 20251225204437.png]]\n\nVamos a las herramientas del desarrollador y a \"Network\" e iniciamos sesión en la aplicación usando:\n\n- **Username:** `thm@mail.thm`\n- **Password:** `test123`\n\n![[Pasted image 20251225205724.png]]\n\nUna vez introducidas las credenciales, podemos observar que hay una respuesta llamada token de 16B.\n\n![[Pasted image 20251225205920.png]]\n\nSi navegamos hasta el apartado de \"Response\" dentro de la petición XHR, podemos ver el valor del token.\n\n![[Pasted image 20251225210013.png]]\n\nCogemos el token y lo introducimos como OTP.\n\n![[Pasted image 20251225210107.png]]\n\nY efectivamente así entramos.\n\n![[Pasted image 20251225210127.png]]",
    "modified": "2025-12-26T00:53:51"
  },
  {
    "title": "1. How MFA Works",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/5-multi-factor-authentication/1-how-mfa-works/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/5. Multi-Factor Authentication/1. How MFA Works.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 5. Multi-Factor Authentication",
    "content": "En la era de la tecnología, conservar nuestra información sensible y sistemas seguros es más importante que nunca. La Autentificación Multi Factor (MFA) añade protección extra para las cuentas de usuario requiriendo que ofrezcas dos o más métodos de verificación.\n\n>[!NOTE] 2FA es un subtipo de MFA.\n\n----------------------------------\n<h2>Tipos de Factores de Autentificación</h2>\nMFA típicamente combina dos o más tipos de credenciales de las categorías:\n\n- Algo que sabes.\n- Algo que tienes.\n- Algo que eres.\n- Algún sitio donde estás.\n- Algo que haces.\n\n![[Pasted image 20251223201529.png]]\n\n<h4>Algo que Sabes</h4>\nPodría ser una contraseña, PIN o cualquier otra pieza de información que tengas que recordar. Forma la base de la mayoría de sistemas de autentificación pero puede ser vulnerable usada individualmente.\n<h4>Algo que Tienes</h4>\nPodría ser tu teléfono con una aplicación de autentificación, un token de seguridad o incluso una tarjeta. Últimamente se están viendo más certificados de clientes, que son como IDs digitales para dispositivos.\n<h4>Algo que Eres</h4>\nInvolucra las medidas biométricas, como huellas, reconocimiento facial o de iris. Está ganando popularidad porque es difícil falsificarla. \n<h4>Algún Sitio en el que Estás</h4>\nInvolucra tu dirección IP de origen o geolocalización. Algunas aplicaciones como la banca online, restringen la actividad si detectan que estás haciendo la petición desde una dirección IP desconocida.\n<h4>Algo que Haces</h4>\nEs normalmente usada en aplicaciones que restringen la interacción de bots, como páginas de registro. La app analiza la forma en la que el usuario introduce credenciales o mueve su ratón.\n\n----------------------------------------------\n<h2>Tipos de 2FA</h2>\n2FA requiere exactamente 2 tipos de los anteriores, por lo que todo 2FA es un MFA pero no cualquier MFA es un 2FA. Algunos de los métodos más comunes incluyen:\n\n<h4>Time-Based One-Time Passwords</h4>\nSon contraseñas temporales que cambian cada 30 segundos o así. Aplicaciones como Google Authenticator, Microsoft Authenticator y Authy los usan, haciéndolo duro para los hackers de interceptar o reutilizar.\n<h4>Notificaciones Push</h4>\nAplicaciones como Duo o Google Prompt mandan una petición de inicio de sesión directamente a tu teléfono. Puedes aprobar o denegar el acceso correctamente desde tu dispositivo, añadiendo una capa de seguridad que verifica la posesión del dispositivo registrado.\n\nUn ataque sobre las notificaciones push (ataque de fatiga MFA) permitió a un atacante comprometer la cuenta de un empleado de Uber. Investiga más sobre ello [aquí](https://www.uber.com/newsroom/security-update).\n<h4>SMS</h4>\nLa mayoría de aplicaciones actualmente usan este método. El sistema manda un mensaje con un código de un solo uso al móvil registrado del usuario. Aunque conveniente, es menos segura debido a vulnerabilidades asociadas con la intercepción de mensajes de texto.\n<h4>Tokens de Hardware</h4>\nDispositivos como las YubiKeys generan un código de un uso o usan NFC para autentificarse. Son geniales porque no necesitan red o batería, por lo que generalmente funcionan offline.\n\n----------------------------------------\n<h2>Acceso Condicional</h2>\nEl acceso condicional es usado típicamente por compañías para ajustar sus requerimientos de autentificación basado en diferentes contextos. Es como un árbol de decisiones que dispara medidas extra de seguridad dependiendo de ciertos factores.\n\n<h4>Basado en Localización</h4>\nSi un usuario inicia sesión desde su ubicación actual, pude que sólo tengan que aportar credenciales. Pero si inician sesión desde un litio nuevo o desconocido, el sistema podría pedir verificación biométrica u OTP.\n<h4>Basado en Tiempo</h4>\nDurante las horas regulares de trabajo, los usuarios pueden entrar con sus credenciales, pero fuera de esas horas puede que se les pida una capa extra de seguridad como un OTP o token de seguridad.\n<h4>Análisis de Comportamiento</h4>\nSi el comportamiento de un usuario cambia abruptamente, el sistema puede pedir autentificación adicional para confirmar que realmente es el usuario.\n<h4>Específico de Dispositivo</h4>\nEn algunos casos, las compañías no permiten a los empleados usar sus propios dispositivos para acceder a recursos de la compañía. En estas situaciones, el sistema puede bloquear al usuario después del inicio de sesión si están en un dispositivo no autorizado.\n\n-------------------------------------\n<h2>Adopción Global e Impulso Regulatorio</h2>\nLa adopción de MFA se está expandiendo rápidamente a lo largo de varios sectores debido a su efectividad en proteger contra varias amenazas de seguridad como phishing, ingeniería social y ataques de contraseña.\n\nPor ejemplo, los gobiernos e industrias como la de la sanidad están implementando MFA para cumplir con ciertas regulaciones como la GDPR en Europa, HIPAA en EE.UU. y PCI-DSS para sistemas de pago globales.",
    "modified": "2025-12-26T00:53:51"
  },
  {
    "title": "5. Practical - Insecure Coding",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/5-multi-factor-authentication/5-practical-insecure-coding/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/5. Multi-Factor Authentication/5. Practical - Insecure Coding.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 5. Multi-Factor Authentication",
    "content": "<h2>¿Error de Lógica o Programación Insegura?</h2>\nEn algunas aplicaciones, los fallos de lógica o prácticas de programación insegura pueden conducir a una situación donde las partes críticas de la aplicación pueden ser accedidas sin completar de forma total el proceso de autentificación. Específicamente, un atacante puede ser capaz de bypassear los mecanismos 2FA de forma total y ganar acceso a áreas sensibles del usuario sin introducir la OTP. Esto suele deberse a manejo de sesiones inadecuado, controles de acceso pobres o implementación de lógica que no consigue reforzar el requerimiento 2FA.\n\n----------------------------------------\n<h2>Explotación</h2>\nVamos a http://mfa.thm/labs/second/ y nos registramos con las mismas credenciales que antes.\n\n![[Pasted image 20251225212016.png]]\n\nTípicamente, el atacante necesita entender cómo el login y el proceso 2FA de la aplicación funcionan. En este caso, después de introducir las credenciales, al usuario se le pide que introduzca un OTP.\n\n![[Pasted image 20251225212122.png]]\n\nEn lugar de introducir el OTP, el atacante puede intentar manipular la URL o bypassear el paso OTP todo junto. Por ejemplo, el atacante puede buscar acceder directamente a la URL del dashboard (`http://mfa.thm/labs/second/dashboard`) sin completar los pasos de autentificación requeridos.\n\nSi la aplicación no comprueba correctamente el estado de la sesión u obligación de 2FA o la lógica de la aplicación es errónea o débil, el atacante puede ganar acceso al dashboard.\n\n![[Pasted image 20251225212343.png]]\n\n----------------------------------------\n<h2>Profundizando en el Código</h2>\nEl código de abajo es parte del código usado en la página `/mfa`. Como puedes ver, el `$_SESSION['authenticated']` es emitido después de completar el proceso 2FA.\n\n```php\n# Function that verifies the submitted 2FA token\nfunction verify_2fa_code($code) {\n    if (!isset($_SESSION['token']))\n    return false;\n\n    return $code === $_SESSION['token'];\n}\n\n# Function called in the /mfa page\nif (verify_2fa_code($_POST['code'])) { #If successful, the user will be redirected to the dashboard.\n    $_SESSION['authenticated'] = true; # Session that is used to check if the user completed the 2FA\n    header('Location: ' . ROOT_DIR . '/dashboard');\n    return;\n}\n```\n\nConsiderando que la implementación de arriba es segura, algunas instancias de emisión de `$_SESSION['authenticated']` después del primer paso de autentificación, omitirán el código anterior como se muestra a continuación.\n\n```php\nfunction authenticate($email, $password){\n  $pdo = get_db_connection();\n  $stmt = $pdo->prepare(\"SELECT `password` FROM users WHERE email = :email\");\n  $stmt->execute(['email' => $email]);\n  $user = $stmt->fetch(PDO::FETCH_ASSOC);\n\n  return $user && password_verify($password, $user['password']);\n}\n\nif (authenticate($email, $password)) {\n    $_SESSION['authenticated'] = true; # This flag should only be issued after the MFA completion\n    $_SESSION['email'] = $_POST['email'];\n    header('Location: ' . ROOT_DIR . '/mfa');\n    return;\n}\n```\n\nComo el dashboard de la aplicación sólo comprueba el valor de `$_SESSION['authenticated']`, sin importar si es true o false, el atacante puede sobrepasarlo fácilmente considerando que tiene conocimiento previo de los endpoints de la aplicación.\n\nPara remediar esto podría partirse la cookie en dos, usando la primera parte para verificar las credenciales correctas y la segunda para el 2FA.",
    "modified": "2025-12-26T00:53:51"
  },
  {
    "title": "6. Practical Beating the Auto-Logout Feature",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/5-multi-factor-authentication/6-practical-beating-the-auto-logout-feature/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/5. Multi-Factor Authentication/6. Practical Beating the Auto-Logout Feature.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 5. Multi-Factor Authentication",
    "content": "En algunas aplicaciones, fallar el reto 2FA puede causar que la aplicación revierta al usuario de vuelta a la primera parte de autentificación del proceso. Este comportamiento ocurre normalmente debido a medidas de seguridad para prevenir la fuerza bruta.\n\n-------------------------------------\n<h2>Razones Comunes para este Comportamiento</h2>\n<h4>Invalidación de Sesión</h4>\nSi fallas la autentificación 2FA, la aplicación puede que invalide la sesión del usuario como medida de seguridad, forzando al usuario a que comience de nuevo el proceso de autentificación.\n<h4>Limitación de Frecuencia y Políticas de Bloqueo</h4>\nPara prevenir que los atacantes intenten bypassear el 2FA repetidamente, la aplicación puede tener un límite de frecuencia o mecanismos de bloqueo que se disparan después de un número de intentos fallidos.\n<h4>Redirección por Seguridad</h4>\nAlgunas aplicaciones están diseñadas para redirigir a los usuarios de vuelta a la página de login después de un número de intentos fallidos, revirtiendo al usuario al paso inicial.\n\n-------------------------------------\n<h2>La Automatización es Clave</h2>\nLa automatización hace la vida más fácil al atacar estos tipos de protección porque:\n\n<h4>Rapidez</h4>\nIniciar sesión manualmente cada vez que te cierran la sesión es lento y tedioso. La automatización lo puede hacer mucho más rápido.\n<h4>Consistencia</h4>\nLa automatización evita errores que pueden pasar si estás haciendo acciones repetitivas una y otra vez. Es confiable.\n<h4>Recuperarse de los Cierres de Sesión</h4>\nSi la aplicación te cierra la sesión después de unos cuantos intentos fallidos, el script puede iniciar sesión de vuelta y seguir intentándolo. Esto ahorra el proceso de tener que hacerlo manualmente cada vez.\n<h4>Personalización</h4>\nCrear un script de automatización manualmente para el ataque ofrece más flexibilidad que usar una única herramienta como ZAP o Burp Suite. Puedes personalizar tus scripts para comprobar escenarios específicos como usar diferentes IPs o user-agents o variar  los tiempos entre peticiones.\n\n--------------------------------\n<h2>Explotación</h2>",
    "modified": "2025-12-26T00:53:51"
  },
  {
    "title": "3. Common Vulnerabilities in MFA",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/5-multi-factor-authentication/3-common-vulnerabilities-in-mfa/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/5. Multi-Factor Authentication/3. Common Vulnerabilities in MFA.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 5. Multi-Factor Authentication",
    "content": "<h2>Algoritmos de Generación de OTPs Débiles</h2>\nLa seguridad de una OTP (One-Time Password) sólo es tan fuerte como el algoritmo usado para crearla. Si el algoritmo es débil o predecible, puede hacer que el trabajo del atacante sea más sencillo. Si un algoritmo no usa valores verdaderamente aleatorios, el OTP generado puede seguir un patrón haciéndolo predecible.\n\n---------------------------------------\n<h2>Filtración del Token 2FA por la Aplicación </h2>\nSi una aplicación maneja la información pobremente o tiene vulnerabilidades como endpoints API inseguros, puede filtrar accidentalmente el token 2FA en la respuesta HTTP de la aplicación.\n\nDebido a la programación insegura, algunas aplicaciones pueden filtrar el token 2FA en la respuesta. Un escenario común es cuando un usuario llega a la página 2FA y la aplicación dispara una petición XHR a un endpoint que emite el OTP. A veces, esta petición devuelve el OTP al usuario dentro de la respuesta HTTP.\n\n----------------------------------------\n<h2>BruteForceando el OTP</h2>\nAunque los OTPs se diseñan para un sólo uso, no son inmunes a los ataques de fuerza bruta. Si un atacante puede adivinar ilimitadamente, eventualmente obtendrán el OTP correcto.\n<h4>Falta de Limitación de Frecuencia</h4>\nSi una limitación de frecuencia adecuada, una aplicación queda abierta a que un atacante siga intentando diferentes OTPs. Si el atacante pude subir varias peticiones en un corto periodo de tiempo, aumenta la posibilidad de que el atacante sea capaz de obtener el OTP correcto.\n\n---------------------------------------\n<h2>Uso de Evilginx</h2>\n[Evilginx](https://github.com/kgretzky/evilginx2) es una herramienta usada típicamente en engagements de red team ya que puede ser usada para ejecutar ataques de phishing sofisticados, bypasseando el MFA de forma efectiva. Opera como un proxy MITM que puede interceptar y redirigir OTPs intencionados para usuarios legítimos originalmente.\n\n![[Pasted image 20251225193547.png]]\n\nEvilginx funciona capturando usuario contraseña y OTP antes de redirigirlos al sitio real, de tal manera que le da a los atacantes acceso usando tus cookies sin necesidad de romper la MFA.",
    "modified": "2025-12-26T00:53:51"
  }
]