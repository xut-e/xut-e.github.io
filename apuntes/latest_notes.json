[
  {
    "title": "3. How it Works",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/5-prototype-pollution/3-how-it-works/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/5. Prototype Pollution/3. How it Works.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 5. Prototype Pollution",
    "content": "Ahora que entendemos el JavaScript necesario, profundizaremos en la contaminación de prototipo usando el mismo ejemplo de la red social. \n\n>[!IMPORTANT] **Prototype Pollution** por sí misma no siempre presenta una amenaza explotable directamente. Sin embargo, su potencal de dañar se vuelve pronunciado cuando se une con otro tipo de vulnerabilidades como XSS y CSRF.\n\n---------------------------------------\n<h2>Un Ejemplo Común</h2>\nAsumamos que tenemos un prototipo básico para `Person` con un método `introduce`. El atacante apunta a manipular el comportamiento del método `introduce` en todas las instancias alterando el prototipo.\n\n```javascript\n//Base Prototype for Persons\nlet personPrototype = {\n  introduce: function() {\n    return `Hi, I'm ${this.name}.`;\n  }\n};\n\n// Person Constructor Function\nfunction Person(name) {\n  let person = Object.create(personPrototype);\n  person.name = name;\n  return person;\n}\n\n// Creating an instance\nlet ben = Person('Ben');\n```\n\nCopia el código, cópialo en la consola y presiona enter. Cuando creamos un nuevo objeto, `ben`, y llamamos al método `introduce`, muestra `Hi, I'm Ben`, como se muestra en la siguiente figura.\n\n![[Pasted image 20260204172007.png]]\n\nSi un atacante inyecta contenido malicioso en el método `introduce` para todas las instancias usando la propiedad `__proto__`. En JavaScript, la propiedad `__proto__` es un método común para acceder al prototipo del objeto, esencialmente apuntando al objeto desde el cual hereda las propiedades y métodos. Si el atacante consigue ejecutar el siguiente código usando cualquier vector de ataque:\n\n```javascript\n// Attacker's Payload\nben.__proto__.introduce=function(){console.log(\"You've been hacked, I'm Bob\");}\nconsole.log(ben.introduce()); \n```\n\nVeamos qué está pasando en el backgorund:\n\n- **Prototype Definition:** El prototipo `Person` se define inicialmente con un método `introduce` inocuo.\n- **Object Instantiation:** Una instancie de `Person` es creada con el nombre `'Ben' (let ben = Person('Ben');)`.\n- **Prototype Pollution Attack:** El atacante inyecta un payload malicioso en el método `introduce` del prototipo, cambiando su comportamiento para mostrar un mensaje dañino. Hemos contaminado usando la propiedad `__proto__`.\n- **Impact on Existing Instances:** Como resultado, incluso la instancia ya existente (`ben`) es afectada, y llamar a `ben.introduce()` ahora muestra el mensaje del atacante.",
    "modified": "2026-02-05T01:05:07"
  },
  {
    "title": "4. Exploitation - XSS",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/5-prototype-pollution/4-exploitation-xss/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/5. Prototype Pollution/4. Exploitation - XSS.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 5. Prototype Pollution",
    "content": "<h2>Acercamiento Estándar</h2>\nComo ya sabemos, numerosas propiedades están presentes de forma heredada en el prototipo de un objeto en JavaScript. Entre estas, las propiedades `constructor` y `__proto__` destacan como objetivos de explotación. La propiedad `constructor` apunta a la función que construye el prototipo del objeto, mientras que `__proto__` es una referencia al objeto prototipo del que actualmente el objeto hereda directamente.\n\n--------------------------------\n<h2>Regla de Oro</h2>\nEl concepto orbita entorno a la habilidad del atacante para influenciar ciertos parámetros clave, como `x` y `val`, en expresiones similares a `Person[x][y] = val`. Supón que un atacante asigna `__proto__` a `x`. En dicho caso, el atributo identificado por `y`, es configurado universalmente a lo largo de todos los objetos que comparten la misma clase que el objeto con el valor denotado por `val`.\n\nEn un escenario más complejo, cuando un atacante tiene control sobre `x`, `y` y `val` en una estructura como `Person[x][y][z] = val`, asignar `x` como `constructor` e `y` como `prototype` conlleva a que una nueva propiedad definida por `z` se establezca a lo largo de todos los objetos en la aplicación con el `val` asignado. Este acercamiento necesita una organización de las propiedades de un objeto más complejas, haciéndolo menos relevante en la práctica.\n\n----------------------------\n<h2>Algunas Funciones Importantes</h2>\nCuando se trata de identificar vulnerabilidades potenciales de contaminación de prototipos, los pentesters deberían enfocarse en vectores/funciones comúnmente susceptibles a la contaminación de prototipos. Es crucial realizar una investigación concienzuda de cómo gestiona la aplicación la manipulación de objetos. Entenderemos unas cuantas funciones que un atacante puede explotar y entonces realizamos la explotación.\n\n- **Property Definition by Path:** Las funciones que configuran propiedades de objetos basadas en una ruta dada (como `object[a][b][c] = value`) pueden ser peligrosas si los componentes de la ruta son controlados por el usuario. Estas funciones deberían ser inspeccionadas para asegurar que no modifican el prototipo de objeto sin avisar. Considera un endpoint que permite a los usuarios actualizar reseñas sobre cualquier amigo.\n\n<h4>Estructura de Objeto Inicial</h4>\n\n\n-----------------------------------\n<h2>Ejemplo Práctico</h2>",
    "modified": "2026-02-05T01:05:07"
  },
  {
    "title": "2. Essential Recap",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/5-prototype-pollution/2-essential-recap/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/5. Prototype Pollution/2. Essential Recap.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 5. Prototype Pollution",
    "content": "Antes de pasar a conceptos avanzados necesitamos entender cosas básicas en JavaScript. Piensa en los **objetos** como bloques de construcción que contienen información. La **herencia** es como pasar atributos de un objeto a otro.Las **funciones** son herramientas que pueden usarse individualmente o como parte de estos objetos. Por último, las **clases** son como planos que nos ayudan a hacer cosas iguales fácilmente.\n\n---------------------------------------------\n<h2>Objetos</h2>\nEn JavaScript los objetos son contenedores que pueden contener diferentes piezas de información. Imagina un perfil de una red social como un objeto, donde cada perfil tiene propiedades como nombre, edad, y seguidores. Puedes representar esto usando `{}` y pares de clave-valor.\n\n```javascript\nlet user = {\n  name: 'Ben S',\n  age: 25,\n  followers: 200,\n  DoB: '1/1/1990'\n};\n```\n\nAquí, `user` es un objeto con propiedades como `name`, `age` y `followers`. Estas propiedades almacenan información específica sobre el usuario. Los objetos en JavaScript nos permiten organizar y gestionar información relacionada.\n\nPara testearlo, abrimos el navegador, hacemos click derecho e `Inspect` y nos vamos a `Console`, lo que abrirá una ventana. Si copias el código de arriba y lo pegas en la consola, creará un objeto `user`. Puedes acceder a sus propiedades usando `console.log`.\n\n![[Pasted image 20260130111755.png]]\n\n------------------------------------------------\n<h2>Clases</h2>\nEn JavaScript, las clases son como planos que nos ayudan a crear múltiples objetos con estructuras o comportamientos similares. Siguiendo con nuestro ejemplo de una red social, podemos usar una clase para definir un usuario genérico y creador de contenido. Las clases ofrecen una forma conveniente de organizar e instanciar objetos con características compartidas.\n\n```javascript\n// Class for User \nclass UserProfile {\n  constructor(name, age, followers, dob) {\n    this.name = name;\n    this.age = age;\n    this.followers = followers;\n    this.dob = dob; // Adding Date of Birth\n  }\n}\n\n// Class for Content Creator Profile inheriting from User \nclass ContentCreatorProfile extends UserProfile {\n  constructor(name, age, followers, dob, content, posts) {\n    super(name, age, followers, dob);\n    this.content = content;\n    this.posts = posts;\n  }\n}\n\n// Creating instances of the classes\nlet regularUser = new UserProfile('Ben S', 25, 1000, '1/1/1990');\nlet contentCreator = new ContentCreatorProfile('Jane Smith', 30, 5000, '1/1/1990', 'Engaging Content', 50);\n```\n\nAhora, la clase `User` incluye la fecha de nacimiento `dob` como parte de sus propiedades y la clase `ContentCreatorProfile` hereda esta propiedad. Al crear instancias de estas clases, podemos dar la fecha de nacimiento y otros detalles. Como podemos ver, incluir la DoB mejora el perfil del usuario con información adicional.\n\n-------------------------------------------------\n<h2>Prototipo</h2>\nEn JavaScript, cada objeto está relacionado con un objeto prototipo y estos prototipos forman una cadena comúnmente conocida como **cadena de prototipo**. El prototipo sirve como plantilla o plano para objetos. Cuando creas un objeto usando una función constructor o una clase, JavaScript automáticamente configura un link entre el objeto y su prototipo. En el contexto de nuestra red social, ilustremos cómo funcionan los prototipos:\n\n```javascript\n// Prototype for User \nlet userPrototype = {\n  greet: function() {\n    return `Hello, ${this.name}!`;\n  }\n};\n\n// User Constructor Function\nfunction UserProfilePrototype(name, age, followers, dob) {\n  let user = Object.create(userPrototype);\n  user.name = name;\n  user.age = age;\n  user.followers = followers;\n  user.dob = dob;\n  return user;\n}\n\n// Creating an instance\nlet regularUser = UserProfilePrototype('Ben S', 25, 1000, '1/1/1990');\n\n// Using the prototype method\nconsole.log(regularUser.greet());\n```\n\nEste código imprime: `Hello, Ben S`.\n\n-----------------------------------------------------\n<h2>Diferencia entre Clase y Prototipo</h2>\nLas clases y los prototipos en JavaScript son dos maneras de conseguir un objetivo similar: crear objetos con comportamientos y características. Imagina que estás construyendo modelos de coches. Usar clases es como tener un plano detallado o un conjunto de instrucciones para cada modelo de coche que quieres desarrollar. Todos los coches hechos con el mismo plano tienen de forma garantizada las mismas funcionalidades y comportamientos. Las clases en JavaScript funcionan así.\n\nPor otro lado, los prototipos es como tener un modelo de coche básico y después personalizarlo añadiendo o modificando funcionalidades directamente en el propio coche. Con los prototipos empiezas con un objeto sencillo y vas añadiendo comportamientos relacionando el objeto a un objeto prototipo que ya tiene esos comportamientos. Los objetos creados de esta manera están relacionados a través de la cadena de prototipos permitiéndoles heredar comportamientos de otros objetos. Este método es más dinámico y flexible pero puede ser más difícil de controlar y entender que las clases.\n\n-------------------------------------------\n<h2>Herencia</h2>\nEn JavaScript la herencia permite a un objeto heredar las propiedades de otro, creando una jerarquía de objetos relacionados. Continuando con nuestro ejemplo de una red social, consideremos un perfil más específico para un creador de contenido. Este nuevo objeto puede heredar propiedades desde un usuario normal, como `name` y `followers` y añadir propiedades particulares como `content` o `posts`.\n\n```javascript\nlet user = {\n  name: 'Ben S',\n  age: 25,\n  followers: 1000,\nDoB: '1/1/1990'\n};\n\n// Content Creator Profile inheriting from User \nlet contentCreatorProfile = Object.create(user);\ncontentCreatorProfile.content = 'Engaging Content';\ncontentCreatorProfile.posts = 50;\n```\n\nAquí, `contentCreatorProfile` hereda las propiedades de `user` usando `Object.create()`. Ahora tiene propiedades específicas como `content` y `posts` y hereda `name`, `age` y `followers` del usuario general.\n\n![[Pasted image 20260131212052.png]]\n\nDe esta manera, la herencia ayuda a crear un objeto más especializado al reutilizar propiedades comunes del objeto padre. JavaScript soporta herencias basadas tanto en clases como en prototipos.\n\n- **Herencia basada en Prototipos:** En JavaScript cada objeto tiene un prototipo y cuando creas un nuevo objeto puedes especificar su prototipo. Los objetos heredan propiedades y métodos de su propio prototipo. Puedes usar el método `Object.create()` para crear un nuevo objeto con un prototipo especificado o puedes modificar directamente el prototipo de un objeto existente usando su propiedad de prototipo.\n- **Herencia basada en Clases:** JavaScript también soporta las clases, las cuales ofrecen una sintaxis más familiar para definir objetos y herencia. Las clases en JavaScript son una mejora sintáctica sobre la herencia basada en prototipos existente. Sin embargo, en esencia, las clases también usan prototipos.\n\nEl siguiente diagrama representa la herencia basada en prototipos en JavaScript:\n\n![[Pasted image 20260131212319.png]]\n\n- **Definir el Objeto UserProfile:** Empezamos definiendo el objeto genérico `UserProfile` que representa propiedades comunes compartidas por diferentes tipos de perfiles. En este ejemplo, `UserProfile` incluye propiedades como `email` y `password`, las cuales pueden ser comunes de todos los perfiles.\n- **Crear ContentCreatorProfile:** Creamos un perfil especializado llamado `ContentCreatorProfile`. Este perfil es específico de los creadores de contenido y puede tener propiedades o comportamientos adicionales. Conseguimos esto creando `ContentCreatorProfile` usando `Object.create(UserProfile)`, lo que configura `UserProfile` como prototipo de `ContentCreatorProfile`.\n- **Añadir Propiedades Adicionales:** Después de crear `ContentCreatorProfile` añadimos propiedades específicas como `posts`. Esta propiedad es única de `ContentCreatorProfile` y no se hereda de `UserProfile`.\n- **Acceder a Propiedades:** Cuando accedemos a las propiedades de `ContentCreatorProfile`, JavaScript primero comprueba si la propiedad existe directamente en `ContentCreatorProfile`. Si no encuentra la propiedad ahí, busca en la cadena de prototipos. Por lo que `ContentCreatorProfile` hereda las propiedades `email` y `password` de `UserProfile` mientras también tiene su propiedad única del número de posts. Esto permite una estructura jerárquica donde los perfiles especializados heredan propiedades de aquellos más genéricos.\n\n![[Pasted image 20260201130706.png]]",
    "modified": "2026-02-02T01:07:37"
  },
  {
    "title": "1. Introduction",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/5-prototype-pollution/1-introduction/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/5. Prototype Pollution/1. Introduction.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 5. Prototype Pollution",
    "content": "En el apasionante mundo de la ciberseguridad, donde los hackers y pentesters vagan en busca de vulnerabilidades, hay un concepto en evolución conocido como contaminación de prototipo. Esto permite a los actores maliciosos manipular y explotar el funcionamiento interno de las aplicaciones JavaScript y habilita a los atacantes a ganar acceso a información sensible y al backend.\n\nMientras que prototype pollution se ve en el contexto de JavaScript, el concepto puede extrapolarse a cualquier sistema que use un [modelo de herencia basado en prototipo](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain).\n\nSin embargo, el amplio uso de JavaScript, particularmente en el desarrollo web y su modelo de objetos flexible y dinámico hacen el protorype pollution un problema más prominente  y relevante en este lenguaje. En contraste, los lenguajes con [herencia basada en clases](https://en.wikipedia.org/wiki/Class-based_programming) suelen ser estáticosy alterar una clase durante el periodo de ejecución no es una práctica común.\n\n--------------------------------\n<h2>Objetivos de Aprendizaje</h2>\nA lo largo de esta unidad aprenderemos los siguientes conceptos:\n\n- Cómo funciona la contaminación de prototipos.\n- Riesgos potenciales de las aplicaciones web.\n- Técnicas de explotación (del lado del cliente y del servidor).\n- Técnicas de mitigación.\n\n--------------------------------------\n<h2>Pre-requisitos</h2>\n- [[Ciberseguridad/THM/0. Pre Career/1. Pre Security/3. How the Web Works/3. How Websites Work/0. How Websites Work]]\n- [[0. Protocols and Servers]]\n- [[Ciberseguridad/THM/0. Pre Career/2. Cyber Security 101/8. Web Hacking/5. OWASP Top 10 - 2021/0. OWASP Top 10 - 2021]]",
    "modified": "2026-01-28T00:56:07"
  },
  {
    "title": "5. LFI2RCE - Session Files",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/3-file-inclusion-and-path-traversal/5-lfi2rce-session-files/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/3. File Inclusion and Path Traversal/5. LFI2RCE - Session Files.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 3. File Inclusion and Path Traversal",
    "content": "<h2>Archivos de Sesión PHP</h2>\nLos archivos de sesión PH también pueden ser usados en un ataque LFI, llevando a RCE, particularmente si un atacante puede manipular la información de sesión. En una aplicación web típica, la información de sesión se guarda en archivos en el servidor. Si un atacante puede inyectar código malicioso en estos archivos de sesión y si la aplicación incluye estos archivos mediante una vulnerabilidad LFI, esto puede llevar a RCE.\n\nPor ejemplo, la aplicación vulnerable hosteada en `http://IP/sessions.php` contiene el siguiente código:\n\n```php\nif(isset($_GET['page'])){\n    $_SESSION['page'] = $_GET['page'];\n    echo \"You're currently in\" . $_GET[\"page\"];\n    include($_GET['page']);\n}\n```\n\nUn atacante podría explotar esta vulnerabilidad inyectando código PHP en su variable de sesión usando `<? echo phpinfo(); ?>` en el parámetro de la página.\n\n![[Pasted image 20260126130003.png]]\n\nEl código es guardado en el archivo de sesión del servidor. Por ello, el atacante puede usar la vulnerabilidad LFI para incluir este archivo de sesión. Como los IDs de sesión son hasheados, el ID puede ser encontrado en las cookies del navegador.\n\n![[Pasted image 20260126130114.png]]\n\nAcceder a la URL `sessions.php?page=/var/lib/php/sessions/sess_[sessionID]` ejecutará el código PHP inyectado en el archivo de sesión.\n\n![[Pasted image 20260126130501.png]]",
    "modified": "2026-01-27T00:59:05"
  }
]