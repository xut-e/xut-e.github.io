[
  {
    "title": "10. Practical Challenge",
    "path": "/apuntes/thm/1-career/2-penetration-tester/1-jr-penetration-tester/4-burp-suite/3-burp-suite-intruder/10-practical-challenge/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/4. Burp Suite/3. Burp Suite - Intruder/10. Practical Challenge.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 4. Burp Suite > 3. Burp Suite - Intruder",
    "content": "Habiendo ganado acceso al sistema de soporte, tenemos ahora la oportunidad de explorar sus funcionalidades y ver qué acciones podemos realizar.\n\nAl acceder a la interfaz de **home** se nos muestra una tabla que enseña los diferentes tickets. Haciendo click en cualquier fila, nos redirige a una página donde podemos ver el ticket completo. Examinando la estructura de la URL, observamos que estas páginas están numeradas usando el formato:\n\n`http://10.10.101.156/support/ticket/NUMBER`\n\nEl sistema de numeración indica que a los tickets se les asigna un entero para su ID. Esto nos da dos escenarios posibles:\n\n1. **Access Control:** El endpoint puede estar configurado para restringir el acceso sólo a los tickets asignados a nuestro usuario actual. En este caso sólo podemos ver tickets asociados con nuestra cuenta.\n2. **IDOR Vulnerability:** Alternativamente, puede estar mal configurado conllevando a una vulnerabilidad llamada **Insecure Direct Object Reference (IDOR)**. Si este es el caso, podríamos potencialmente explotar el sistema y leer los tickets existentes, sin importar el usuario asignado.\n\nPara investigarlo más, usaremos la herramienta del Intruder para fuzzear el endpoint `/support/ticket/NUMBER`. \n\n--------------------------------\n<h2>Challenge</h2>\n1. Vamos a la página dada.\n   ![[Pasted image 20251116170930.png]]\n2. Iniciamos sesión con los resultados obtenidos de la última práctica.\n   ![[Pasted image 20251116171101.png]]\n3. Si nos metemos en uno de los tickets vemos el endpoint.\n   ![[Pasted image 20251116171146.png]]\n4. Capturamos una petición en Burp Suite y la mandamos al Intruder. Seleccionamos Sniper attack y configuramos el número como la parte a fuzzear:\n   ![[Pasted image 20251116171352.png]]\n5. Creamos una lista con números del 1 al 100.\n   ![[Pasted image 20251116171540.png]]\n6. Cargamos esa lista en el payload set.\n   ![[Pasted image 20251116171618.png]]\n7. Comenzamos el ataque y esperamos. Al terminar nos fijaremos en aquellas solicitudes con código de respuesta 200.\n   ![[Pasted image 20251116172035.png]]\n8. Haciendo click en las peticiones correspondientes y fijándonos en la respuesta llegamos hasta la flag.\n   ![[Pasted image 20251116172318.png]]",
    "modified": "2025-11-17T00:57:12"
  },
  {
    "title": "11. Extra-mile Challenge",
    "path": "/apuntes/thm/1-career/2-penetration-tester/1-jr-penetration-tester/4-burp-suite/3-burp-suite-intruder/11-extra-mile-challenge/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/4. Burp Suite/3. Burp Suite - Intruder/11. Extra-mile Challenge.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 4. Burp Suite > 3. Burp Suite - Intruder",
    "content": "En este ejercicio, afrontaremos una variante un poco más difícil del ataque de credential-stuffing llevado a cabo antes. Sin embargo, esta vez se han implementado nuevas medidas para hacer la fuerza bruta más complicada.\n\n-----------------------------------\n<h2>Capturar la Petición</h2>\nEmpezaremos capturando la petición de `http://10.10.101.156/admin/login/` y la revisaremos. Aquí un ejemplo:\n\n```python\nHTTP/1.1 200 OK\nServer: nginx/1.18.0 (Ubuntu)\nDate: Fri, 20 Aug 2021 22:31:16 GMT\nContent-Type: text/html; charset=utf-8\nConnection: close\nSet-Cookie: session=eyJ0b2tlbklEIjoiMzUyNTQ5ZjgxZDRhOTM5YjVlMTNlMjIzNmI0ZDlkOGEifQ.YSA-mQ.ZaKKsUnNsIb47sjlyux_LN8Qst0; HttpOnly; Path=/\nVary: Cookie\nFront-End-Https: on\nContent-Length: 3922\n---\n<form method=\"POST\">\n    <div class=\"form-floating mb-3\">\n        <input class=\"form-control\" type=\"text\" name=username  placeholder=\"Username\" required>\n        <label for=\"username\">Username</label>\n    </div>\n    <div class=\"form-floating mb-3\">\n        <input class=\"form-control\" type=\"password\" name=password  placeholder=\"Password\" required>\n        <label for=\"password\">Password</label>\n    </div>\n    <input type=\"hidden\" name=\"loginToken\" value=\"84c6358bbf1bd8000b6b63ab1bd77c5e\">\n    <div class=\"d-grid\"><button class=\"btn btn-warning btn-lg\" type=\"submit\">Login!</button></div>\n</form>\n```\n\nEn esta respuesta podemos notar que junto a los campos de nombre de usuario y contraseña, hay ahora un set de cookies, un CSRF (Cross-Site Request Forgery) token en forma de campo oculto. Recargar la página revela que la cookie de sesión y el loginToken cambian en cada petición. Esto significa que por cada intento de login, necesitamos extraer valores válidos de la cookie de sesión y el loginToken, reemplazándolos en cada petición de ataque.\n\n-------------------------------\n<h2>Challenge</h2>\n1. Vamos a la página dada.\n   ![[Pasted image 20251116173639.png]]\n2. Activamos la intercepción y nos logueamos con test test, por ejemplo. Mandamos la petición al Intruder.\n   ![[Pasted image 20251116173803.png]]\n3. Configuramos Pitchfork attack, limpiamos las posiciones asignadas y seleccionamos username y password.\n   ![[Pasted image 20251116174100.png]]\n4. En los payloads sets cargamos las mismas listas que usamos para el otro ataque.\n   ![[Pasted image 20251116174248.png]]\n   ![[Pasted image 20251116174308.png]]\n5. Como no podemos usar grep para seleccionar la cookie cambiante debido a la redirección, necesitaremos configurar una macro. Las macros nos permiten realizar la misma acción repetidamente. En este caso sólo queremos mandar una petición `GET` a `/admin/login/`. Para hacerlo:\n\t1. Volvemos a la pestaña Settings.\n\t   ![[Pasted image 20251116174845.png]]\n\t2. Hacemos click en la categoría \"Sessions\", vamos hasta abajo y seleccionamos \"Macros\" y le damos a \"Add\".\n\t   ![[Pasted image 20251116174941.png]]\n\t3. El menú que aparece nos mostrará nuestro historial de peticiones. Con la petición seleccionada haz click en OK.\n\t   ![[Pasted image 20251116175018.png]]\n\t4. Finalmente dale a la macro un nombre acorde.\n\t   ![[Pasted image 20251116175042.png]]\n6. Ahora que tenemos una macro definida, necesitamos configurar las reglas de manejo de sesiones que definen cómo deberíamos usar la macro.\n\t1. En la categoría de \"Sessions\" de los ajustes principales ve arriba hasta \"Session Handling Rules\" y dale a \"Add\".\n\t   ![[Pasted image 20251116175732.png]]\n\t2. Saltará una nueva ventana con dos pestañas: \"Details\" y \"Scope\". Rellena una descripción adecuada y cambia a la pestaña \"Scope\".\n\t   ![[Pasted image 20251116175844.png]]\n\t3. Desmarca todas las opciones menos \"Intruder\" ya que no necesitamos que esta macro se aplique en ningún otro sitio.\n\t   ![[Pasted image 20251116175910.png]]\n\t4. En la sección \"URL Scope\", selecciona \"Use suite scope\". Esto selecciona la macro para que sólo opere en sitios que hayan sido añadidos al scope global. Si no has seleccionado un scope global selecciona \"Use custom scope\" y añade `http://10.10.101.156/` al scope en esta sección.\n\t   ![[Pasted image 20251116175938.png]]\n\t   ![[Pasted image 20251116180009.png]]\n7. Ahora debemos volver a la pestaña \"Details\" y seleccionar \"Rule Actions\". Le damos a \"Add\", seleccionamos \"Run a Macro\" de esta lista y selecciona la macro que creamos antes.\n   ![[Pasted image 20251116180219.png]]\n   ![[Pasted image 20251116180317.png]]\n8. Ahora, la macro meterá las cookies directamente en nuestras peticiones. Sin embargo, debemos restringir qué parámetros van a ser actualizados entre peticiones.\n\t1. Seleccionamos \"Update only the following parameters and headers\" y le damos a \"Edit\".\n\t2. Escribimos \"loginToken\" en el campo \"Enter a new item\".\n\t3. Seleccionamos \"Update only the following cookies\" y le damos a \"Edit\".\n\t4. Escribimos \"session\" en el campo \"Enter a new item\".\n\t   ![[Pasted image 20251116180800.png]]\n9. Le damos a OK y estamos listos. Comenzamos el ataque.\n   ![[Pasted image 20251116181030.png]]\n10. Ahora tenemos una macro definida que sustituye en cada petición la cookie de \"session\" y \"loginToken\" por una válida que obtiene de realizar una petición `GET` a login.\n11. Como ya nos pasó en el último ataque, todas las respuestas son 302 (redirección) por lo que debemos ordenarlas por longitud de respuesta.\n    ![[Pasted image 20251116181418.png]]\n12. Con las credenciales obtenidas nos logueamos:\n    ![[Pasted image 20251116181526.png]]",
    "modified": "2025-11-17T00:57:12"
  },
  {
    "title": "1. Decoder - Overview",
    "path": "/apuntes/thm/1-career/2-penetration-tester/1-jr-penetration-tester/4-burp-suite/4-burp-suite-other-modules/1-decoder-overview/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/4. Burp Suite/4. Burp Suite - Other Modules/1. Decoder - Overview.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 4. Burp Suite > 4. Burp Suite - Other Modules",
    "content": "El módulo Decoder de Burp Suite le da al usuario capacidad de manipulación de datos. Como implica su nombre, no sólo decodea datos interceptados durante un ataque sino que también ofrece la función de encodear nuestra propia información, preparándola para la transmisión al objetivo. También nos permite crear hashsums de datos, como ofrecer una funcionalidad de Decodeo Inteligente que intenta decodear la información recursivamente hasta que vuelve a ser texto plano (como la función Magic de Cyberchef).\n\nPara acceder al Decoder, navega a la pestaña Decoder en el menú de arriba y mira las opciones disponibles:\n\n![[Pasted image 20251116182217.png]]\n\nEsta interfaz muestra bastantes opciones.\n\n1. Esta caja sirve como espacio de trabajo para introducir o pegar información que requiere encoding o decoding. La información puede ser movida entre módulos con \"**Send to Decoder**\" si haces click derecho en ella.\n2. Arriba de la lista de la derecha, hay una opción para tratar el input como texto o valor hexadecimal.\n3. Al movernos hacia abajo en la lista, los menús desplegables se presentan para encodear, decodear, o hashear el input.\n4. La funcionalidad de **Smart Decode**, localizada al final, intenta auto-decodear el input.\n   ![[Pasted image 20251116182626.png]]\nAl introducir información en el campo input, la interfaz se replica para presentar el output de nuestra operación. Podemos elegir entonces aplicar más transformaciones usando las mismas opciones.\n\n![[Pasted image 20251116182727.png]]",
    "modified": "2025-11-17T00:57:12"
  },
  {
    "title": "8. Sequencer - Analysis",
    "path": "/apuntes/thm/1-career/2-penetration-tester/1-jr-penetration-tester/4-burp-suite/4-burp-suite-other-modules/8-sequencer-analysis/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/4. Burp Suite/4. Burp Suite - Other Modules/8. Sequencer - Analysis.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 4. Burp Suite > 4. Burp Suite - Other Modules",
    "content": "Ahora que tenemos un reporte generado para el análisis de entropía del token toca analizarlo.\n\nEl reporte del análisis de entropía se divide en 4 partes.\n\n![[Pasted image 20251116225740.png]]\n\n- **Overall result:** Muestra una evaluación amplia de la seguridad del mecanismo de generación del token.\n- **Effective entropy:** Mide la aleatoriedad de los tokens. Cuanto más alta mejor.\n- **Reliability:** El nivel de significancia de 1% implica que hay un 99% de certeza en la precisión de los resultados.\n- **Sample:** Ofrece detalles sobre los ejemplos de tokens analizados durante el proceso de análisis de entropía, incluyendo el número de tokens y sus características.\n\nMientras que el resumen del reporte normalmente ofrece suficiente información, es importante recordar que puede ser necesaria una investigación más profunda en algunos casos. El análisis a nivel de carácter y de bit puede ofrecer una vista más detallada de la randomización de tokens.\n\nMientra que el reporte de entropía puede ofrecer un indicador de seguridad alto para el mecanismo de generación del token, debe haber pruebas más definitivas. Dicho esto, una entropía efectiva de 109 bits y nivel de significancia de 1% sugiere un proceso de generación de tokens robusto.",
    "modified": "2025-11-17T00:57:12"
  },
  {
    "title": "3. Decoder - Hashing",
    "path": "/apuntes/thm/1-career/2-penetration-tester/1-jr-penetration-tester/4-burp-suite/4-burp-suite-other-modules/3-decoder-hashing/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/4. Burp Suite/4. Burp Suite - Other Modules/3. Decoder - Hashing.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 4. Burp Suite > 4. Burp Suite - Other Modules",
    "content": "Además de su funcionalidad de Encodear/Decodear, el Decoder también ofrece la habilidad de generar hashsums para la información.\n\n--------------------------------\n<h2>Teoría</h2>\nHashing es un proceso de una dirección que transforma la información en una firma única. Para que una función se clasifique como un algoritmo de hashing, el output que genera debe ser irreversible. Un algoritmo bueno asegura que cada input de información tenga un único hash. Es por esto que generalmente se utilizan para confirmar la integridad de un archivo.\n\n>[!CAUTION] El algoritmo MD5 está deprecado y no debe usarse para aplicaciones contemporáneas.\n\nAdemás los hashes se usan para almacenar contraseñas de forma segura ya que como es un proceso unidireccional no puede ser descifrado y por lo tanto las hace \"seguras\" aunque se filtre la base de datos. Lo que pasa para que esto ocurra es:\n\n1. Intentas entrar con una contraseña. \n2. Se hashea y se comprueba ese hash con el guardado.\n3. Si es igual te permite entrar y si no, no.\n\n--------------------------------\n<h2>Hashear en el Decoder</h2>\nEl Decoder nos permite crear hashsums de información directamente en Burp Suite. Opera de manera similar al encoder/decoder. Hacemos click en el menú desplegable `Hash` y seleccionamos el que queramos.\n\n![[Pasted image 20251116210530.png]]\n\nEs una lista bastante larga.\n\nEl output de un algoritmo de hasheo no es ASCII/Unicode por lo que compete encodearlo aplicando ASCII Hex:\n\n![[Pasted image 20251116210858.png]]",
    "modified": "2025-11-17T00:57:12"
  }
]