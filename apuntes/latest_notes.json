[
  {
    "title": "3. Operator Injection - Bypassing the Login Screen",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/2-nosql-injection/3-operator-injection-bypassing-the-login-screen/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/2. NoSQL Injection/3. Operator Injection - Bypassing the Login Screen.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 2. NoSQL Injection",
    "content": "<h2>Bypassear la Pantalla de Login</h2>\nPrimero vamos a la página que nos dan y mandamos un usuario y contraseña incorrectos para capturar la petición con Burp Suite.\n\n![[Pasted image 20260111120955.png]]\n\nLa petición original se ve así:\n\n![[Pasted image 20260111121114.png]]\n\nAhora vamos a probar otro login y modificamos la petición para mandar arrays en `user` y `pass`:\n\n![[Pasted image 20260111121332.png]]\n\nEsto fuerza a la base de datos a devolver todos los documentos y como resultado iniciamos sesión en la aplicación.\n\n![[Pasted image 20260111121959.png]]",
    "modified": "2026-01-12T00:57:54"
  },
  {
    "title": "4. Operator Injection - Logging in as Other Users",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/2-nosql-injection/4-operator-injection-logging-in-as-other-users/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/2. NoSQL Injection/4. Operator Injection - Logging in as Other Users.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 2. NoSQL Injection",
    "content": "<h2>Iniciar Sesión como Otros Usuarios</h2>\nHemos conseguido bypassear la pantalla de login de la aplicación, pero con la técnica anterior, sólo podemos loguearnos como el primer usuario que sea devuelto por la base de datos. Haciendo uso del operador `$nin`, vamos a modificar nuestro payload para que podamos controlar qué usuario queremos obtener.\n\nPrimero, el operador `$nin` nos permite crear un filtro donde el documento deseado tenga un campo, que no esté en una lista de valores (not in = nin). Por lo que si queremos loguearnos como cualquier usuario excepto el admin, podemos modificar nuestro payload así:\n\n![[Pasted image 20260111130530.png]]\n\nEsto se traduciría a un filtro con la siguiente estructura:\n\n`['username'=>['$nin'=>['admin']], 'password'=>['$ne'=>'aweasdf']]`\n\nLo que le dice a la base de datos que devuelva cualquier usuario para el que el username no sea admin y la contraseña no sea aweasdf. Como resultado se nos da acceso a otra cuanta.\n\nPodemos seguir expandiendo la lista de valores a ignorar ajustando el payload.\n\n![[Pasted image 20260111130846.png]]\n\nEsto resultaría en el siguiente filtro:\n\n`['username'=>['$nin'=>['admin', 'jude']], 'password'=>['$ne'=>'aweasdf']]`\n\nEsto puede ser repetido cuantas veces necesites hasta ganar acceso a todas las cuentas disponibles.",
    "modified": "2026-01-12T00:57:54"
  },
  {
    "title": "5. Operator Injection - Extracting Users Passwords",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/2-nosql-injection/5-operator-injection-extracting-users-passwords/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/2. NoSQL Injection/5. Operator Injection - Extracting Users Passwords.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 2. NoSQL Injection",
    "content": "<h2>Extraer Contraseñas de Usuarios</h2>\nAhora tenemos acceso a todas las cuentas en la aplicación. Sin embargo, es importante intentar extraer la contraseña usada ya que puede haber sido reutilizada. Para conseguirlo, abusaremos el operador `$regex` para preguntar una serie de preguntas al servidor que nos permitan recuperar las contraseñas vía un proceso que se asemeja jugar al ahorcado.\n\nPrimero, tomaremos uno de los usuarios descubiertos antes y trataremos de adivinar la longitud de la contraseña. Usaremos el siguiente payload para hacerlo:\n\n![[Pasted image 20260111200719.png]]\n\nDate cuenta de que estamos preguntándole a la base de datos si hay un usuario con el nombre `admin` y una contraseña que coincida con la regex `^.{7}$`. Esto representa una string de 7 caracteres. Como responde con error sabemos que la longitud no es 7. Después de probar un poco encontramos la longitud.\n\n![[Pasted image 20260111200903.png]]\n\nSabemos que la longitud es 5. Ahora toca averiguar el contenido real, para lo cual modificaremos el payload de la siguiente manera:\n\n![[Pasted image 20260111202751.png]]\n\nAhora estamos trabajando con una expresión regular de 5 caracteres (una `c` más 4 puntos), coincidiendo con la longitud descubierta y preguntando si coincide con `^c....$`, lo que significa que empieza por `c`. Como la respuesta es `invalid login`, sabemos que no empieza por `c`. Es por esto que probamos otra.\n\n![[Pasted image 20260111203133.png]]\n\nEsto confirma que la primera letra de la contraseña es `a`. Repetiremos el proceso para el resto de letras hasta dar con la contraseña.",
    "modified": "2026-01-12T00:57:54"
  },
  {
    "title": "6. Syntax Injection - Identification and Data Extraction",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/2-nosql-injection/6-syntax-injection-identification-and-data-extraction/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/2. NoSQL Injection/6. Syntax Injection - Identification and Data Extraction.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 2. NoSQL Injection",
    "content": "<h2>Encontrar Inyección de Sintaxis</h2>\nAhora que hemos cubierto la inyección de operadores, echaremos un vistazo al ejemplo de inyección de sintaxis. Una aplicación python te permite recibir la dirección de correo electrónico de cualquier usuario que se de. Para usar la aplicación autentifícate vía SSH usando `ssh syntax@IP` y las credenciales:\n\n- Username: `syntax`\n- Password: `syntax`\n\nUna vez autentificado, puedes dar el nombre de usuario como input. Empezaremos poniendo `admin`:\n\n```bash\nssh syntax@10.66.162.204\nsyntax@10.66.162.204's password: \nPlease provide the username to receive their email:admin\nadmin@nosql.int\nConnection to 10.66.162.204 closed.\n```\n\nPodemos empezar a comprobar en busca de inyección de sintaxis simplemente añadiendo `'`, lo que puede resultar en la respuesta de error de abajo:\n\n```shell\nsyntax@10.66.162.204's password: \nPlease provide the username to receive their email:admin'\nTraceback (most recent call last):\n  File \"/home/syntax/script.py\", line 17, in <module>\n    for x in mycol.find({\"$where\": \"this.username == '\" + username + \"'\"}):\n  File \"/usr/local/lib/python3.6/dist-packages/pymongo/cursor.py\", line 1248, in next\n    if len(self.__data) or self._refresh():\n  File \"/usr/local/lib/python3.6/dist-packages/pymongo/cursor.py\", line 1165, in _refresh\n    self.__send_message(q)\n  File \"/usr/local/lib/python3.6/dist-packages/pymongo/cursor.py\", line 1053, in __send_message\n    operation, self._unpack_response, address=self.__address\n  File \"/usr/local/lib/python3.6/dist-packages/pymongo/mongo_client.py\", line 1272, in _run_operation\n    retryable=isinstance(operation, message._Query),\n  File \"/usr/local/lib/python3.6/dist-packages/pymongo/mongo_client.py\", line 1371, in _retryable_read\n    return func(session, server, sock_info, read_pref)\n  File \"/usr/local/lib/python3.6/dist-packages/pymongo/mongo_client.py\", line 1264, in _cmd\n    sock_info, operation, read_preference, self._event_listeners, unpack_res\n  File \"/usr/local/lib/python3.6/dist-packages/pymongo/server.py\", line 134, in run_operation\n    _check_command_response(first, sock_info.max_wire_version)\n  File \"/usr/local/lib/python3.6/dist-packages/pymongo/helpers.py\", line 180, in _check_command_response\n    raise OperationFailure(errmsg, code, response, max_wire_version)\npymongo.errors.OperationFailure: Failed to call method, full error: {'ok': 0.0, 'errmsg': 'Failed to call method', 'code': 1, 'codeName': 'InternalError'}\nConnection to 10.66.162.204 closed.\n```\n\nLa siguiente linea en el mensaje de error muestra que hay inyección de comandos:\n\n`for x in mycol.find({\"$where\": \"this.username == '\" + username + \"'\"}):`\n\nPodemos ver que la variable del nombre de usuario está directamente concatenada a la query string y que una función JavaScript se está ejecutando en el comando de búsqueda, permitiéndonos inyectar en la sintaxis. En este caso, tenemos mensajes de verbose de error para darnos indicaciones de que la inyección es posible. Sin embargo, incluso sin mensajes de verbose de error, podemos comprobar la inyección de sintaxis dando una condición true y una false y viendo cómo difiere el output como podemos ver a continuación:\n\n```bash\nssh syntax@10.66.162.204\nsyntax@10.66.162.204's password: \nPlease provide the username to receive their email:admin' && 0 && 'x\nConnection to 10.66.162.204 closed.\n\nssh syntax@10.66.162.204\nsyntax@10.66.162.204's password: \nPlease provide the username to receive their email:admin' && 1 && 'x\nadmin@nosql.int\nConnection to 10.66.162.204 closed.\n```\n\n--------------------------------------------\n<h2>Explotando la Inyección de Sintaxis</h2>\nAhora que hemos confirmado la inyección de sintaxis, podemos usar este punto de inyección para obtener las direcciones de correo. Para hacerlo, queremos asegurarnos de que el statement de testing de la condición siempre de true. Al inyectar en el JavaScript, podemos usar el payload `'||1||'`. Usémoslo:\n\n```bash\nssh syntax@10.66.162.204\nsyntax@10.66.162.204's password: \nPlease provide the username to receive their email:admin'||1||'\nadmin@nosql.int\npcollins@nosql.int\njsmith@nosql.int\n[...]\nConnection to 10.66.162.204 closed.\n```\n\n-----------------------------\n<h2>La Excepción a la Regla</h2>\nEs importante apuntar que para que ocurra la inyección de sintaxis, el desarrollador tiene que crear queries JavaScript personalizadas. La misma función podría ser realizada usando las funciones de filtrado preinstaladas donde `['username' : username]` devolvería el mismo resultado pero no sería vulnerable a la inyección. Como tal es rara de encontrar, ya que significaría que los desarrolladores no están usando las funciones y filtros incrustados. El ejemplo de arriba es exclusivo de MongoDB. Para otras soluciones NoSQL puede existir pero la sintaxis cambiar á.",
    "modified": "2026-01-12T00:57:54"
  },
  {
    "title": "8. Automation",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/1-advanced-sql-injection/8-automation/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/1. Advanced SQL Injection/8. Automation.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 1. Advanced SQL Injection",
    "content": "La inyección SQL sigue siento una amenaza común debido a la implementación inadecuada de medidas de seguridad y la complejidad de diferentes frameworks web. La identificación de automatizaciones y la explotación de estas vulnerabilidades puede ser retador, pero hay varias herramientas y técnicas que han sido desarrolladas para ayudar a simplificar este proceso.\n\n-----------------------------------------------\n<h2>Mayores Problemas Durante la Identificación</h2>\nIdentificar vulnerabilidades de inyección SQL involucra varios retos, similar a identificar cualquier otro tipo de vulnerabilidad del lado del servidor. Aquí están los problemas clave:\n\n- **Naturaleza dinámica de las queries SQL:** Las queries SQL pueden ser construidas dinámicamente, haciendo difícil detectar puntos de inyección. las queries complejas con múltiples capas de lógica pueden ocultar vulnerabilidades potenciales.\n- **Variedad de puntos de inyección:** La inyección SQL puede ocurrir en diferentes partes de la aplicación, incluyendo campos de input, headers HTTP y parámetros URL. Identificar todos los puntos de inyección SQL requiere una comprobación a conciencia y entendimiento de la aplicación.\n- **Uso de medidas de seguridad:** Las aplicaciones pueden usar statements preparados, queries parametrizadas, y frameworks ORM, los cuales pueden prevenir las inyecciones SQL. Las herramientas automatizadas deben ser capaces de diferenciar entre construcciones de query seguras y no seguras.\n- **Detección específica del contexto:** El contexto en el que se usan los inputs del usuario en queries SQL puede variar ampliamente. Las herramientas deben adaptarse a diferentes contextos para identificar vulnerabilidades de forma precisa.\n\n---------------------------------------\n<h2>Algunas Herramientas Importantes</h2>\nAlgunas herramientas importantes que han sido desarrolladas por la comunidad para ayudar en la búsqueda automática de vulnerabilidades de inyección SQL son:\n\n- **[SQLMap](https://github.com/sqlmapproject/sqlmap):** Herramienta de código abierto que automatiza el proceso de detectar y explotar vulnerabilidades SQLi en aplicaciones web.\n- **[SQLNinja](https://github.com/xxgrunge/sqlninja):** Específicamente diseñada para explotar vulnerabilidades SQLi en aplicaciones web que usan Microsoft SQL server como base de datos en el backend.\n- **[JSQL Injection](https://github.com/ron190/jsql-injection):** Librería Java focalizada en detectar vulnerabilidades SQLi en aplicaciones Java.\n- **[BBQSQL](https://github.com/CiscoCXSecurity/bbqsql):** Es un framework de Blind SQLi diseñado para ser simple y efectivo para este tipo de explotación.",
    "modified": "2026-01-11T01:00:33"
  }
]