[
  {
    "title": "8. Mitigation Measures",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/5-prototype-pollution/8-mitigation-measures/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/5. Prototype Pollution/8. Mitigation Measures.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 5. Prototype Pollution",
    "content": "Mitigar los riesgos asociados con la contaminación de prototipos es crucial tanto para los pentesters como para los desarrolladores. Aquí algunas medidas de mitigación para:\n\n-----------------------------------------------\n<h2>Pentesters</h2>\n- **Manipulación y Fuzzeo de Input:** Interactúa con el input del usuario y fuzzéalos con una variedad de payloads. Busca escenarios donde información no confiable pueda llevar a PP.\n- **Análisis de Contexto e Inyección de Payloads:** Analiza el código de la aplicación para entender cómo el input del usuario se usa en las estructuras. Inyecta payloads en estos contextos para comprobar vulnerabilidades de PP.\n- **Bypasseo CSP e Inyección de Payloads:** Evalúa la efectividad de los headers de seguridad como CSP (Cloud Service Provider). Intenta bypassear las restricciones del CSP e inyecta payloads para manipular prototipos.\n- **Análisis y Explotación de Dependencias:** Realiza un análisis exhaustivo de librerías de terceros y dependencias usadas por la aplicación. Identifica librerías anticuadas que puedan introducir vulnerabilidades PP y explótalas.\n- **Análisis Estático de Código:** Usa herramientas de análisis de código estático para identificar vulnerabilidades durante la fase de desarrollo.\n\n----------------------------------------\n<h2>Secure Code Developers</h2>\n- **Evitar Usar __proto__:** Restringe el uso de `__proto__` en la medida de lo posible ya que es susceptible de PP. En su lugar usa `Object.getPrototypeOf()` para acceder al prototipo de un objeto de forma más segura.\n- **Objetos Inmutables:** Diseña objetos inmutables cuando sea posible. Este previene modificaciones no intencionadas del prototipo.\n- **Encapsulación:** Encapsula objetos y sus funcionalidades, exponiendo sólo interfaces necesarias.\n- **Usar Valores por Defecto Seguros:** Al crear objetos, establece valores seguros por defecto y evita confiar en el input del usuario para configurar propiedades del prototipo.\n- **Sanitizar el Input:** Sanitiza y valida el input del usuario exhaustivamente.\n- **Gestión de Dependencias:** Actualiza y monitoriza regularmente las dependencias. Elige librerías no deprecadas.\n- **Headers de Seguridad:** Implementa headers de seguridad como CSP (Content Security Policy) para controlar las fuentes desde las cuales se cargan.",
    "modified": "2026-02-09T01:09:24"
  },
  {
    "title": "7. Automating the Process",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/5-prototype-pollution/7-automating-the-process/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/5. Prototype Pollution/7. Automating the Process.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 5. Prototype Pollution",
    "content": "<h2>Mayores Problemas durante la Indentificación</h2>\nIdentificar PP es un problema en cualquier lenguaje, especialmente en JavaScript debido a la forma con la que este permite que un objeto comparta sus funcionalidades con otro. Detectar este problema automáticamente con software es muy complicado porque no es preciso. Cada web o aplicación es diferente e intuir dónde puede ocurrir PP puede requerir que alguien examine de cerca el código.\n\nAl contrario que otros problemas de seguridad que pueden ser encontrados buscando patrones específicos requiere que un pentester o desarrollador eche un vistazo exhaustivo al código.\n\n----------------------------------------\n<h2>Algunos Scripts Importantes</h2>\nMuchas herramientas y proyectos han sido desarrollados por comunidades open source para ayudar en la identificación de estas vulnerabilidades. Aquí algunas cuantas con renombre en GitHub:\n\n- **[NodeJsScan](https://github.com/ajinabraham/nodejsscan):** Es un escáner estático de código para aplicaciones Node.js. Incluye comprobaciones de varias vulnerabilidades, incluyendo PP. \n- **[Prototype Pollution Scanner](https://github.com/KathanP19/protoscan):** Es una herramienta diseñada para escanear código JavaScript en busca de vulnerabilidades de PP. Puede ser usada para analizar código en busca de patrones que son susceptibles de ella.\n- **[PPFuzz](https://github.com/dwisiswant0/ppfuzz):** Es un fuzzer diseñado para automatizar el proceso de detectar PP en aplicaciones web. Fuzzeando vectores de input que puedan interactuar con propiedades de objetos, `PPFuzz` puede ayudar a identificar vectores de ataque.\n- **[BlackFan](https://github.com/BlackFan/client-side-prototype-pollution):** Está enfocada en identificar vulnerabilidades de PP en el lado del cliente. Incluye ejemplos de cómo puede ser explotada en navegadores para realizar ataques XSS, por ejemplo.\n\nAl identificar prototype pollution, el pentester debería buscar instancias donde el input controlado por el usuario pueda influir las claves o propiedades para que se mezclen, definan o clonen.",
    "modified": "2026-02-09T01:09:24"
  },
  {
    "title": "5. Exploitation - Property Injection",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/5-prototype-pollution/5-exploitation-property-injection/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/5. Prototype Pollution/5. Exploitation - Property Injection.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 5. Prototype Pollution",
    "content": "<h2>Algunas Funciones Importantes</h2>\n- **Object Recursive Merge:** Esta función involucra combinar propiedades de forma recursiva de un objeto \"fuente\" hacia un objeto \"objetivo\". Un atacante puede explotar esta funcionalidad si la función de combinar no valida los inputs y permite mezclar propiedades en la cadena del prototipo. Considerando el mismo código de una red social, supón que la aplicación tiene una función para combinar ajustes de usuario.\n\n```javascript\n// Vulnerable recursive merge function\nfunction recursiveMerge(target, source) {\n    for (let key in source) {\n        if (source[key] instanceof Object) {\n            if (!target[key]) target[key] = {};\n            recursiveMerge(target[key], source[key]);\n        } else {\n            target[key] = source[key];\n        }\n    }\n}\n\n// Endpoint to update user settings\napp.post('/updateSettings', (req, res) => {\n    const userSettings = req.body; // User-controlled input\n    recursiveMerge(globalUserSettings, userSettings);\n    res.send('Settings updated!');\n});\n```\n\nUn atacante manda una petición con un objeto anidado que contiene `__proto__`:\n\n```javascript\n{\"__proto__\": { \"newProperty\": \"value\" } } \n```\n\n- **Object Clone:** La clonación de objetos es una funcionalidad similar que permite que operaciones profundas de clonación copien propiedades de una cadena de prototipos a otra sin avisar. Estas funciones sólo deberían clonar las propiedades definidas por el usuario de un objeto y filtrar las palabras especiales como `__proto__`, `constructor`, etc.\n\n-------------------------------------------\n<h2>Ejemplo Práctico</h2>\nAhora veremos de forma práctica cómo los atacantes explotan esta vulnerabilidad. Exploraremos la funcionalidad de clonar álbum. Esta permite a los usuarios clonar un álbum dando un nuevo nombre.\n\n![[Pasted image 20260205193518.png]]\n\nExploraremos el código del lado del cliente y del servidor.\n\n```html\n<form action=\"/clone-album/1\" method=\"post\" class=\"mb-4\">\n\t<h2 class=\"mb-3\">Clone Album of Josh</h2>\n\t<div class=\"form-group\">\n\t\t<label for=\"selectedAlbum\">Select an Album to Clone:</label>\n\t\t<select class=\"form-control\" name=\"selectedAlbum\" id=\"selectedAlbum\">\n\t\t\t\t<option value=\"Trip to US\">\n\t\t\t\t\tTrip to US\n\t\t\t\t</option>\n\t\t</select>\n\t</div>\n\t<div class=\"form-group\">\n\t\t<label for=\"newAlbumName\">New Album Name:</label>\n\t\t<input type=\"text\" class=\"form-control\" name=\"newAlbumName\" id=\"newAlbumName\"\n\t\t\tplaceholder=\"Enter new album name\">\n\t</div>\n\t<button type=\"submit\" class=\"btn btn-primary\">Clone Album</button>\n</form>\n```\n\nEl código del lado del cliente toma el nombre como input y llama al endpoint de la API `/clone-album/{album_ID}` para clonarlo. Como hemos visto, PP es raramente explotable por sí sola. Sin embargo, al combinarse con otros vectores de ataque puede resultar en una mayor superficie de ataque. Veamos ahora el código del lado del servidor.\n\n```javascript\napp.post(\"/clone-album/:friendId\", (req, res) => {\n  const { friendId } = req.params;\n  const { selectedAlbum, newAlbumName } = req.body;\n  const friend = friends.find((f) => f.id === parseInt(friendId));\n  if (!friend) {\n    console.log(\"Friend not found\");\n    return res.status(404).send(\"Friend not found\");\n  }\n  const albumToClone = friend.albums.find(\n    (album) => album.name === selectedAlbum\n  );\n  if (albumToClone && newAlbumName) {\n    let clonedAlbum = { ...albumToClone };\n    try {\n      const payload = JSON.parse(newAlbumName);\n      merge(clonedAlbum, payload);\n    } catch (e) {\n    }\n\nfunction merge(to, from) {\n  for (let key in from) {\n    if (typeof to[key] == \"object\" && typeof from[key] == \"object\") {\n      merge(to[key], from[key]);\n    } else {\n      to[key] = from[key];\n    }\n  }\n  return to;\n}\n```\n\nEn el código de arriba, los servidores reciben un objeto JSON con el nombre del álbum, copian dicho álbum en otro objeto y cambian el nombre del álbum recién creado llamando a la función `merge`.\n\nSabemos que la función `merge` es un candidato ideal para PP si copia los objetos y propiedades sin sanitizar el input. ¿Que pasaría por lo tanto si mandamos una petición que contenga `__proto__` con `newProperty`?\n\n```javascript\n{\"__proto__\": {\"newProperty\": \"hacked\"}}\n```\n\nLa función `merge` considerará `__proto__` como una propiedad y llamará a `obj.__proto__.newProperty=value`. Haciendo esto, `newProperty` no se añade directamente al objeto `friend`. En su lugar, se añade al prototipo del objeto. Esto significa que `newProperty` no es visiblemente parte de las propiedades de `friend` (como sí lo son `name`, `age`, etc) pero sigue siendo accesible. Clonemos un álbum visitando el perfil de Josh y usando el payload de arriba como nombre del álbum.\n\n![[Pasted image 20260205201432.png]]\n\n¡Ahí está! Tenemos una nueva propiedad para todos los objetos `friend`.\n\n- **Efecto sobre todos los objetos del mismo tipo:** Como todos los objetos `frind` se crean del mismo prototipo, añadir `newProperty` al prototipo significa que todos los objetos `friend` ahora tienen acceso a `newProperty`.\n- **Observar el cambio:** Aunque `newProperty` no es visible directamente al imprimir el objeto `friend`, está ahí. Puedes acceder a él llamando a `friend.newProperty`, lo que mostrará `testValue`.\n- **Cómo se vuelve visible newProperty:** Cuando añades `newProperty` vía el prototipo, no existe directamente en los objetos individuales. Sin embargo, cuando accedes a una propiedad del objeto, JavaScript busca primero entre las propiedades del objeto y si no la encuentra busca en las propiedades del prototipo. Si no lo encuentra mira en la cadena de prototipos hasta que lo encuentra o llega al final.\n- **Renderizado en pantalla:** En la plantilla [EJS](https://ejs.co/), cuando ciclas todas las propiedades de un objeto `friend` usando un bucle `for...in` (`<% for (let key in friend) { %> ...<% } %>`) y las muestra, este bucle itera sobre todas las propiedades enumerables de un objeto, incluyendo aquellas heredadas del prototipo.\n\nEn esta tarea hemos aprendido cómo añadir nuevas propiedades al prototipo de un objeto para contaminar la estructura general. En la siguiente tarea veremos como crashear una aplicación si el desarrollador no toma las medidas necesarias",
    "modified": "2026-02-06T01:03:26"
  },
  {
    "title": "6. Exploitation - Denial of Service",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/5-prototype-pollution/6-exploitation-denial-of-service/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/5. Prototype Pollution/6. Exploitation - Denial of Service.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 5. Prototype Pollution",
    "content": "<h2>Denegación de Servicio</h2>\nPrototype pollution, una vulnerabilidad crítica en aplicaciones JavaScript, puede llevar a DoS, entre otras consecuencias. Esto ocurre cuando un atacante manipula el prototipo de un objeto ampliamente utilizado, causando que la aplicación se comporte inesperadamente o que incluso crashee. En JavaScript, los objetos heredan propiedades y métodos de los prototipos, y alterar estos prototipos afecta directamente a los objetos.\n\nPor ejemplo, si un atacante contamina el método `Object.prototype.toString`, cada llamada posterior a este método por parte de cualquier objeto ejecutará el comportamiento alterado. En una aplicación compleja donde `toString` es frecuentemente usada, esto puede llevar a resultados inesperados, potencialmente causando que la aplicación funcione mal. El método `toString` es usado universalmente en JavaScript. \n\nSi el método contaminado lleva a un procesamiento ineficiente o a un bucle infinito, puede agotar los recursos del sistema causando un DoS. Además, puede interferir con la lógica de negocio.\n\n---------------------------------------\n<h2>Ejemplo Práctico</h2>\n- De nuevo, visitaremos `http://IP:5000` y veremos si podemos crashear el servidor. Como ya hemos hablado, tenemos el método `Object.prototype.toString`.\n- Visitamos la página del perfil de cualquier amigo y podemos ver que así es como se comporta el cliente:\n\n```html\n<form action=\"/clone-album/1\" method=\"post\" class=\"mb-4\">\n\t<h2 class=\"mb-3\">Clone Album of Josh</h2>\n\t<div class=\"form-group\">\n\t\t<label for=\"selectedAlbum\">Select an Album to Clone:</label>\n\t\t<select class=\"form-control\" name=\"selectedAlbum\" id=\"selectedAlbum\">\n\t\t\t\t<option value=\"Trip to US\">\n\t\t\t\t\tTrip to US\n\t\t\t\t</option>\n\t\t</select>\n\t</div>\n\t<div class=\"form-group\">\n\t\t<label for=\"newAlbumName\">New Album Name:</label>\n\t\t<input type=\"text\" class=\"form-control\" name=\"newAlbumName\" id=\"newAlbumName\"\n\t\t\tplaceholder=\"Enter new album name\">\n\t</div>\n\t<button type=\"submit\" class=\"btn btn-primary\">Clone Album</button>\n</form>\n```\n\n- Vemos que esta función lama a la función `merge`. ¿Qué pasa si intentamos mandar un payload que sobrescriba una función existente como `toString()` y luego la llamamos desde un objeto?\n- Para preparar el payload tomaremos un simple JSON:\n\n```javascript\n{\"__proto__\": {\"toString\": \"Just crash the server\"}}\n```\n\n- Vamos al perfil e introducimos el payload en lugar del nombre del álbum.\n  ![[Pasted image 20260205210406.png]]\n- Decodearemos el payload una vez que `app.js` reciba la petición, parsee el JSON y asigne el valor de la función `toString` en la propiedad `__proto__` del objeto `friend`.\n- Esto crea un comportamiento abrupto ya que `toString` es ampliamente utilizada por diferentes objetos. Podemos hacer click en clonar el álbum y pasa lo siguiente:\n  ![[Pasted image 20260205211006.png]]\n- El `TypeError` que obtenemos es `Object.prototype.toString.call` is not a function, ya que hemos sobrescrito la función usando PP.\n- Puedes sobrescribir muchas otras funciones incrustadas como `toJSON`, `valueOf`, `constructor`, etc, pero la aplicación no crasheará siempre. Depende de cuánto se use la función que sobrescribes.",
    "modified": "2026-02-06T01:03:26"
  },
  {
    "title": "4. Exploitation - XSS",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/5-prototype-pollution/4-exploitation-xss/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/5. Prototype Pollution/4. Exploitation - XSS.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 5. Prototype Pollution",
    "content": "<h2>Acercamiento Estándar</h2>\nComo ya sabemos, numerosas propiedades están presentes de forma heredada en el prototipo de un objeto en JavaScript. Entre estas, las propiedades `constructor` y `__proto__` destacan como objetivos de explotación. La propiedad `constructor` apunta a la función que construye el prototipo del objeto, mientras que `__proto__` es una referencia al objeto prototipo del que actualmente el objeto hereda directamente.\n\n--------------------------------\n<h2>Regla de Oro</h2>\nEl concepto orbita entorno a la habilidad del atacante para influenciar ciertos parámetros clave, como `x` y `val`, en expresiones similares a `Person[x][y] = val`. Supón que un atacante asigna `__proto__` a `x`. En dicho caso, el atributo identificado por `y`, es configurado universalmente a lo largo de todos los objetos que comparten la misma clase que el objeto con el valor denotado por `val`.\n\nEn un escenario más complejo, cuando un atacante tiene control sobre `x`, `y` y `val` en una estructura como `Person[x][y][z] = val`, asignar `x` como `constructor` e `y` como `prototype` conlleva a que una nueva propiedad definida por `z` se establezca a lo largo de todos los objetos en la aplicación con el `val` asignado. Este acercamiento necesita una organización de las propiedades de un objeto más complejas, haciéndolo menos relevante en la práctica.\n\n----------------------------\n<h2>Algunas Funciones Importantes</h2>\nCuando se trata de identificar vulnerabilidades potenciales de contaminación de prototipos, los pentesters deberían enfocarse en vectores/funciones comúnmente susceptibles a la contaminación de prototipos. Es crucial realizar una investigación concienzuda de cómo gestiona la aplicación la manipulación de objetos. Entenderemos unas cuantas funciones que un atacante puede explotar y entonces realizamos la explotación.\n\n- **Property Definition by Path:** Las funciones que configuran propiedades de objetos basadas en una ruta dada (como `object[a][b][c] = value`) pueden ser peligrosas si los componentes de la ruta son controlados por el usuario. Estas funciones deberían ser inspeccionadas para asegurar que no modifican el prototipo de objeto sin avisar. Considera un endpoint que permite a los usuarios actualizar reseñas sobre cualquier amigo.\n\n<h4>Estructura de Objeto Inicial</h4>\nAntes de ninguna actualización, tenemos un array `friends` inicial que contiene un objeto que representa el perfil de un amigo. Cada perfil incluye propiedades como `id`, `name`, `reviews` y `albums`.\n\n```javascript\nlet friends = [ { id: 1, name: \"testuser\", age: 25, country: \"UK\", reviews: [], albums: [{ }], password: \"xxx\", } ]; _.set(friend, input.path, input.value);\n```\n\n<h4>Input Recibido del Usuario</h4>\nEl usuario quiere añadir una review a su amigo. Ofrecen un payload que contiene la ruta donde la review debería ser añadida (`review.content`) y el contenido de la review (`<script>alert(anycontent</script>`) .\n\nUn atacante actualiza al ruta para apuntar al prototipo:\n\n```javascript\n{ \"path\": \"reviews[0].content\", \"value\": \"&#60;script&#62;alert('anycontent')&#60;/script&#62;\" };\n```\n\nUsamos la función `_set` de lodash para aplicar el payload y añadir el contenido de la review a la ruta especificada en el objeto del perfil del amigo.\n\n<h4>Estructura de Objeto Resultante</h4>\nDespués de ejecutar el código, el array `friends` será modificado para incluir la review del usuario. Sin embargo, debido a la falta de correcta validación, el contenido de la review dado por el usuario (`<script>alert('anycontent')</script>`) fue directamente añadido al objeto de perfil sin la sanitización adecuada.\n\n```javascript\nlet friends = [\n  {\n    id: 1,\n    name: \"testuser\",\n    age: 25,\n    country: \"UK\",\n    reviews: [\n      \"<script>alert('anycontent')</script>\"\n    ],\n    albums: [{}],\n    password: \"xxx\",\n  }\n];\n```\n\nDe forma similar, supón que el atacante quiere insertar una propiedad maliciosa en el perfil del amigo. En dicho caso, ofrecen un payload que contiene la ruta donde la propiedad debería ser añadida (`isAdmin`) y el valor de la propiedad maliciosa (`true`).\n\n```javascript\nconst payload = { \"path\": \"isAdmin\", \"value\": true };\n```\n\nDespués de ejecutar el código, el array `friends` será modificado para incluir la propiedad maliciosa `isAdmin` en el objeto del perfil del amigo. El objeto `friends` tendrá la siguiente estructura:\n\n```javascript\nlet friends = [\n  {\n    id: 1,\n    name: \"testuser\",\n    age: 25,\n    country: \"UK\",\n    reviews: [],\n    albums: [],\n    password: \"xxx\",\n    isAdmin: true // Malicious property inserted by the attacker\n  }\n];\n```\n\n-----------------------------------\n<h2>Ejemplo Práctico</h2>\nAhora veremos de forma práctica cómo los atacantes pueden explotar esta vulnerabilidad. Supón que estás trabajando como pentester en una firma encargado de auditar una plataforma de red social. Puedes acceder a la aplicación en `http://IP:5000` con las siguientes credenciales:\n\n- Username: `bob`\n- Password: `bob@123`\n\nDespués de iniciar sesión, verás un dashboard así:\n\n![[Pasted image 20260205105243.png]]\n\nPara identificar la prototype pollution, exploraremos diferentes funcionalidades de la aplicación, como añadir álbumes, mandar solicitudes de amistad, añadir reviews, etc. Una vez que hayas iniciado sesión, otros amigos pueden ser añadidos a tu lista de amigos. Visita el perfil de cualquier amigo (digamos Sabalenka en este caso). Una vez que visites la página, verás diferentes opciones como añadir una opinión, clonar un álbum, etc.\n\nExploremos la funcionalidad de subida.\n\n![[Pasted image 20260205105510.png]]\n\nLa funcionalidad de subida de opiniones permite a los usuarios subir cualquier review, la cual será guardada en la base de datos. Exploremos el lado del cliente y el del servidor para analizar varias posibilidades de explotación.\n\n```html\n<form action=\"/submit-friend-review\" method=\"post\" class=\"mb-4\">\n    <h2 class=\"mb-3\">Submit a Review</h2>\n    <input type=\"hidden\" name=\"friendId\" value=\"1\">\n    <div class=\"form-group\">\n        <textarea class=\"form-control\" name=\"reviewContent\" placeholder=\"Write your review here\" rows=\"3\"></textarea>\n    </div>\n    <button type=\"submit\" class=\"btn btn-primary\">Submit Review</button>\n</form>\n```\n\nEl código del lado del cliente toma la review como parámetro de input y llama al endpoint API `/submit-friend-review` para añadir y revisar junto con el parámetro oculto `friendId`. COmo vimos en tareas previas, la contaminación de prototipo sóla es raramente explotable. Sin embargo, cuando es combinada con otros vectores de ataque como XSS, puede ofrecer una superficie de ataque mayor.\n\nVeamos ahora el código del lado del servidor.\n\n```javascript\nlet friends = [\n  {\n    id: 1,\n    name: \"Sabalenka\",\n    age: 25,\n    country: \"UK\",\n    reviews: [],\n    albums: [{ name: \"USA Trip\", photos: \"git.thm\" }],\n    password: \"xxx\",\n  },\n...\n...\napp.post(\"/submit-friend-review\", (req, res) => {\n  if (!req.session.user) {\n    return res.redirect(\"/signin\");\n  }\n  const { friendId, reviewContent } = req.body;\n  const friend = friends.find((f) => f.id === parseInt(friendId));\n  if (!friend) {\n    return res.status(404).send(\"Friend not found\");\n  }\n  try {\n    const input = JSON.parse(reviewContent);\n    _.set(friend, input.path, payload.value);\n  } catch (e) { }\n  res.redirect(`/friend/${friendId}`);\n});\n```\n\nEste código realiza las siguientes acciones:\n\n- Primero, valida si el usuario ha iniciado sesión. Si no, lo redirige a la página de login.\n- Entonces, el código extrae el parámetro y valida la conexión entre el usuario con sesión iniciada y el `friendId` recibido como parámetro de petición.\n- Después de verificar la conexión del amigo, el código inserta la review en el objeto amigo.\n- El código usa la función `_.set` de la utilidad Lodash que permite configurar el valor de una propiedad en una ruta dada. Es una forma conveniente de configurar valores en objetos sin tener que comprobar si cada nivel de ruta existe. Si una porción no existe, `_set` la crea.\n- El análisis del código muestra que es una buena oportunidad para realizar el ataque de definición de propiedad mediante ruta.\n- Siguiendo, añadiremos una amigo y visitaremos su perfil para añadir una simple review y ver si funciona.\n\n![[Pasted image 20260205111105.png]]\n\n- La review es añadida exitosamente. Basado en el conocimiento que obtenemos del código fuente, preparemos un payload para mandar a la review que disparará una alerta. Sabemos que el objeto `friends` tiene un array `reviews` donde las reviews de cada usuario se guardan. La funcionalidad para añadir una review funciona sólo en el perfil de un amigo.\n\n```javascript\n{\"path\": \"reviews[0].content\", \"value\": \"<script>alert('Hacked')</script>\"}\n```\n\n![[Pasted image 20260205111348.png]]\n\nAhora, cada vez que alguien visite el perfil de este usuario, el ataque XSS seguirá ocurriendo. En dichos escenarios, el atacante puede incluso manipular otras propiedades que pueden permitir acceso admin al usuario, como `isAdmin`, `isLoggedIn`, etc.\n\nEn esta tarea, hemos aprendido cómo el atacante puede lanzar ataques de prototype pollution y XSS usando la técnica de propiedad por definición.",
    "modified": "2026-02-06T01:03:26"
  }
]