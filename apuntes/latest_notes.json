[
  {
    "title": "6. Samesite Cookie Bypass",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/4-advanced-client-side-attacks/2-csrf/6-samesite-cookie-bypass/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/4. Advanced Client-Side Attacks/2. CSRF/6. Samesite Cookie Bypass.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 4. Advanced Client-Side Attacks > 2. CSRF",
    "content": "<h2>Vista Previa</h2>\nProfundicemos en el mecanismo crucial de defensa conocido como cookies SameSite. Estas cookies vienen con un atributo especial diseñado para controlar cuándo se mandan con peticiones cross-site. Implementar esta propiedad es una manera confiable de protegerse contra filtraciones de información de cross-origin, CSRF y XSS. Dependiendo del contexto de la petición, le dice al navegador cuándo transmitir la cookie. Los tres valores potenciales son **Strict**, **Lax** y **None**.\n\nEl nivel de protección más alto es strict, que garantiza que la cookie sólo se manda si la petición viene del mismo origen que la cookie. Lax permite el uso de la cookie en orígenes cruzados por especificación.\n\n------------------------------------\n<h2>Diferentes Tipos de Cookies SameSite</h2>\n- **Lax:** Las cookies SameSite Lax son como un vecindario amigable. Ofrecen un nivel de protección moderado permitiendo cookies ser mandadas en niveles altos de navegación y métodos HTTP seguros, como GET, HEAD y OPTIONS. Esto implica que no serán mandadas en peticiones cross-origin con POST, ayudando a mitigar cierto tipo de ataques CSRF. Sin embargo, siguen estando presentes en peticiones GET iniciadas por sitios web externos, lo que puede suponer un riesgo si se guarda información sensible en las cookies.\n- **Strict:** Las cookies SameSite Strict actúan como guardias de seguridad. Ofrecen el nivel más alto de protección restringiendo las cookies para que sólo se puedan mandar por el propietario. Esto significa que las cookies sólo se mandan con peticiones que se originan del mismo sitio que configuró la cookie, previniendo efectivamente los ataques CSRF.\n- **None:** Las cookies SameSite None se comportan como trotamundos sin responsabilidades. Se mandan tanto como por el propietario como en peticiones cross-site, haciéndolas convenientes para escenarios donde las cookies necesitan ser accesibles a lo largo de diferentes orígenes. Sin embargo, para prevenir riesgos de seguridad potenciales asociados con esta configuración, las cookies None requieren del atributo Secure en true para que la petición se haga a través de HTTPS. Esto asegura que las cookies sólo se mandan en conexiones seguras.\n\n-------------------------------------\n<h2>La Aventura de Explotación Lax</h2>\n- Ahora que el atacante puede acceder a la cuenta del banco de Josh, su objetivo principal es cerrale su sesión para que no pueda hacer más transacciones.\n- Ha visto una cookie logout que se configura una vez que hace login, esta cookie está configurada como Lax, lo que significa que se mandará en todas las navegaciones de alto nivel con peticiones como GET.\n\n![[Pasted image 20260217125527.png]]\n\n- Aquí está el código del lado del servidor que valida la cookie y comprueba su valor. Basado en ese valor, el código cierra la sesión del usuario.\n\n```php\n<?php\n$cookieNames = array_keys($_COOKIE);\nif($_COOKIE[\"logout\"] == \"xxxxxxx\"){\n\t// Loop through each cookie and delete it\nforeach ($cookieNames as $cookieName) {\n// If it's desired to kill the session, also delete the session cookie.\nsession_destroy();\n..\n...\n}\n```\n\n\n\n--------------------------------------\n<h2>¿Cuál es el Link Faltante?</h2>\n\n\n-----------------------------------------\n<h2>Escenario Lax con POST - Encadenando el Exploit</h2>",
    "modified": "2026-02-18T01:10:02"
  },
  {
    "title": "5. Double Submit Cookie Bypass",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/4-advanced-client-side-attacks/2-csrf/5-double-submit-cookie-bypass/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/4. Advanced Client-Side Attacks/2. CSRF/5. Double Submit Cookie Bypass.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 4. Advanced Client-Side Attacks > 2. CSRF",
    "content": "<h2>Vista Previa</h2>\nHemos observado que sin tokens CSRF, la aplicación web del banco era susceptible a vulnerabilidades, exponiéndolo a potencial explotación. Sin embargo, la introducción de tokens CSRF mejora significativamente la seguridad.\n\nUn token CSRF es un valor único e impredecible asociado a la sesión de un usuario, asegurando que cada petición viene de una fuente legítima. Una implementación efectiva es la técnica de subida doble de cookies, donde un valor de cookie corresponde a un valor en un campo de formulario hidden. Cuando el servidor recibe una petición, comprueba que el valor de la cookie coincida con el del campo, dando una capa de seguridad extra.\n\n---------------------------------------\n<h2>¿Cómo Funciona?</h2>\n- **Generación de Token:** Cuando un usuario inicia sesión, el servidor genera un token CSRF único. Este token es mandado al navegador del usuario como cookie y campo hidden del formulario web donde se realiza la acción.\n- **Acción del Usuario:** El usuario rellena el formulario, el cual contiene el campo escondido con el token CSRF.\n- **Subida de Formulario:** Al subir el formulario dos versiones del token CSRF son mandadas, una en la cookie y la otra como parte de la información del formulario.\n- **Validación de Servidor:** El servidor comprueba que el token CSRF en la cookie coincide con el mandado en el formulario. Si coincide, la petición se considera legítima y se procesa; si no, se rechaza.\n\n---------------------------------\n<h2>Escenarios Posiblemente Vulnerables</h2>\nA pesar de su efectividad, es crucial reconocer que los hackers son persistentes y han identificado varios métodos para bypassear el Double Submit Cookies:\n\n- **Secuestro de Cookie de Sesión (MITM Attack):** Si el token CSRF no está aislado correctamente y guardado de la sesión, un atacante podría acceder a él de alguna forma.\n- **Subversión de la Política del Mismo Origen (Subdominio Controlado por el Atacante):** Un atacante puede configurar una situación donde la política de same origin del navegador se rompa.\n- **Explotar Vulnerabilidades XSS:** Un atacante puede obtener el token CSRF de una cookie o página si la aplicación web es susceptible de XSS.\n- **Predecir o Interferir con la Generación de Tokens:** Un atacante puede adivinar o modificar el token CSRF si los tokens no se generan de forma segura y son predecibles o si pueden alterar el proceso de generación de tokens.\n- **Inyección de Cookies de Subdominio:** Inyectar cookies en el navegador de un usuario desde un subdominio relacionado es otra técnica sofisticada que puede ser usada.\n\n--------------------------------------\n<h2>¿Cómo Funciona?</h2>\nAhora veremos cómo funciona el ataque, conectándolo al ejemplo anterior. Esta técnica encadena dos escenarios vulnerables invirtiendo la generación de token e inyectando una cookie a través de un subdominio controlado por el atacante.\n\n- El atacante ha transferido de forma exitosa la cantidad de dinero de la cuenta de Josh pero es más avaricioso y quiere tomar control completo de otra cuenta de banco.\n- Para explotar la cuenta, el atacante debe acceder a la cuenta, ¿pero cómo? Requiere la contraseña de la cuenta de Josh.\n- Explotar una vulnerabilidad como CSRF requiere bastante entendimiento de código y funcionalidad de la lógica del servidor desde el punto de vista del desarrollador. El atacante inicia sesión en su cuenta de banco y nota que el formulario de subida para actualizar contraseñas está protegido por un token CSRF.\n\n```html\n<form method=\"post\" action=\"\">\n        <label for=\"password\">Password:</label>\n        <input type=\"password\" id=\"password\" name=\"new_password\" required>\n\n        <label for=\"confirm_password\">ConfirmPassword:</label>\n        <input type=\"password\" id=\"confirm_password\" name=\"confirm_password\" required>\n\t\t<input type=\"hidden\" id=\"csrf_token\" name=\"csrf_token\" value=\"<?php echo $_COOKIE['csrf-token']; ?>\">\n        <button type=\"submit\" name=\"password_submit\" >Update Password</button>\n    </form>submit\">\n</form> \n```\n\n- Pero ¿resuelve eso el problema? Un atacante sólo puede bypassear esta medida de seguridad si encuentra una manera de hacerle ingeniería inversa al token.\n- Abre la consola de `Inspeccionar elemento` del navegador para verificar cookies creadas localmente por la web.\n\n![[Pasted image 20260216121529.png]]\n\n- Los atacantes identificaron dos cookies relevantes en el navegador: `csrf-token` y `PHPSESSID`. Típicamente, `PHPSESSID` se genera aleatoriamente por el motor de PHP y no es fácil de revertirlo. Por eso el atacante coge el csrf-token y lo intenta con él.\n- Usa Cyberchef para ver si puede decodearlo, y sorprendentemente sí puede.\n\n![[Pasted image 20260216121751.png]]\n\n- Nota que la string decodeada era su número de cuenta, significando que el desarrollador de la aplicación web necesitaba haber implementado tokens csrf mejor para evitar la explotación.\n\nSabemos que el atacante ya tiene accedo a `mybank.thm` por lo que puede inyectar la cookie falsa, es hora de preparar el payload.\n\n<h4>Preparando el Payload</h4>\n- Para que el ataque funcione, el atacante debería usar una técnica de ingeniería social para hacer que la víctima haga click en un link.\n- El atacante preparará un email para hacer que el usuario cambie su contraseña. Preparó un email citando un intento de login sospechoso al email de Josh y se lo mandó.\n\n![[Pasted image 20260216122354.png]]\n\n- El email contenía un link a un subdominio controlado por el atacante (`attacker.mybank.thm`) con un formulario de actualización de contraseña similar al del banco. El formulario también tenía un token CSRF configurado como parámetro hidden.\n\n```html\n<form method=\"post\" action=\"http://mybank.thm:8080//changepassword.php\" id=\"autos\">\n    <label for=\"password\">Password:</label>\n    <input type=\"password\" id=\"password\" name=\"current_password\" value=\"<?php echo \"GB82MYBANK5697\" ?>\" required>\n\n    <label for=\"confirm_password\">ConfirmPassword:</label>\n    <input type=\"password\" id=\"confirm_password\" name=\"confirm_password\" value=\"Attacker Unique Password\" required>\n\t<input type=\"hidden\" id=\"csrf_token\" name=\"csrf_token\" value=\"Decrypted Token Value\">\n\t\t\n\n\t<button type=\"submit\" name=\"password_submit\"  id=\"password_submit\" >Update Password</button>\n</form>\n\t\n</div>\n\t<script>\n\t\tdocument.getElementById('password_submit').click(); \n\t</script>\n        \n```\n\n- En el código de arriba, el atacante actualizará el payload y añadirá el valor en base64 de la cuenta del banco de Josh como nuevo token CSRF.\n- Navega hasta el correo de Josh (`mailbox.thm:8081`) para ver el nuevo email del payload CSRF.\n\n![[Pasted image 20260216122716.png]]\n\n- Una vez que hagas click en el link, te redirigirá al subdominio controlado por el atacante. El atacante contiene un código similar al de cambiar la contraseña de `mybank.thm`. Sin embargo, también está configurando una cookie con el siguiente código para que sea redirigido al dominio principal.\n\n```php\n<?php\n...\nsetcookie(\n    'csrf-token',               \n    base64_encode(\"GB82MYBANK5699\"),            \n    [\n        'expires' => time() + (365 * 24 * 60 * 60), \n        'path' => '/',                         \n        'domain' => 'mybank.thm',                          \n        'secure' => false,                      \n        'httponly' => false,                 \n        'samesite' => 'Lax' \n    ]\n);\n?>\n```\n\n- El atacante sabe el parámetro hidden y el formulario subirá la información, incluyendo los campos hidden, a la página original de cambio de contraseña. Veamos qué pasa del lado del servidor.\n\n```php\n<?php\nif (base64_decode($_POST[\"csrf_token\"]) == base64_decode($_COOKIE['csrf-token'])) { \n// Retrieve form data\n$currentPassword = $_POST[\"current_password\"];\n$newPassword = $_POST[\"confirm_password\"];\n// Update Password\n...;\n```\n\n- Como vemos arriba, el servidor decodea el token CSRF y lo compara con el valor de la cookie. El servidor considera la petición legítima si viene de un usuario logueado y el token CSRF es válido.\n\n![[Pasted image 20260216123345.png]]\n\n----------------------------------\n<h2>¿Cuál es el Link Faltante?</h2>\nEl script del lado del servidor validó correctamente al usuario. Sin embargo, el token CSRF era  fácil de predecir y por lo tanto el atacante pudo lanzar un ataque de CSRF construido.\n\n----------------------------------\n<h2>Securizando la Brecha</h2>\n- Desde la perspectiva del pentester, es esencial validar el flujo completo de petición/respuesta, comprobar por doble partida si los parámetros tienen alguna vulnerabilidad como tokens fácilmente adivinables.\n- Desde la perspectiva del desarrollador, asegurar que los métodos de generación de tokens sean únicos y difíciles de adivinar.\n- El equipo IT del banco rápidamente identificó el problema y actualizó la generación de tokens para que fueran único y difíciles de adivinar.\n- Abre la bandeja de entrada de Josh y ve hasta el email con la insignia verde.\n\n![[Pasted image 20260216124039.png]]\n\n- Usar el mismo payload no funcionará porque el servidor ha implementado correctamente tokens CSRF seguros e impredecibles.\n\n![[Pasted image 20260216124124.png]]",
    "modified": "2026-02-17T01:07:28"
  },
  {
    "title": "2. Overview of CSRF Attack",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/4-advanced-client-side-attacks/2-csrf/2-overview-of-csrf-attack/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/4. Advanced Client-Side Attacks/2. CSRF/2. Overview of CSRF Attack.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 4. Advanced Client-Side Attacks > 2. CSRF",
    "content": "<h2>¿Qué es CSRF?</h2>\nCSRF es un tipo de vulnerabilidad de seguridad donde un atacante engaña al navegador de un usuario para que realice acciones no intencionadas en un sitio web de confianza del usuario donde este está autentificado. Se consigue explotando el hecho de que el navegador incluye cualquier cookie relevante (credenciales) automáticamente, permitiendo al atacante suplantar y subir peticiones no autorizadas en nombre del usuario (a través del navegador). El sitio web del atacante puede contener formularios HTML o código JavaScript que está intencionado para mandar queries a la aplicación web objetivo.\n\n-------------------------------------\n<h2>Ciclo de CSRF</h2>\nUn ataque CSRF tiene tres fases esenciales:\n\n1. El atacante sabe el formato de las peticiones de la aplicación web para realizar una tarea particular y manda un link malicioso al usuario.\n2. La identidad de la víctima se verifica en la web, típicamente por cookies transmitidas automáticamente con cada petición y hace click en el link compartido por el atacante. Esta interacción podría ser un click, mouse over o cualquier otra acción.\n3. Medidas de seguridad insuficientes previenen a la aplicación web de distinguir peticiones auténticas de aquellas falsificadas.\n\n![[Pasted image 20260215113846.png]]\n\n----------------------------\n<h2>Efectos de CSRF</h2>\nEntender el impacto de CSRF es crucial para mantener las actividades online seguras. Aunque los ataques CSRF no exponen directamente la información de los usuarios, puede seguir causando mucho daño cambiando las contraseñas, cuentas de correo o haciendo transacciones financieras. Los riesgos asociados a CSRF incluyen:\n\n- **Acceso no autorizado:** Los atacantes pueden acceder y controlar las acciones de un usuario suponiendo un riesgo de pérdida de dinero, daño de su reputación y enfrentarse a consecuencias legales.\n- **Explotación de confianza:** CSRF explota la confianza que los sitios web ponen en los usuarios.\n- **Explotación sigilosa:** Funciona silenciosamente sin necesidad de malware avanzado. Los usuarios pueden no sospechar de un ataque, haciéndolos más vulnerables a explotación repetida.",
    "modified": "2026-02-16T01:08:34"
  },
  {
    "title": "3. Types of CSRF Attack",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/4-advanced-client-side-attacks/2-csrf/3-types-of-csrf-attack/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/4. Advanced Client-Side Attacks/2. CSRF/3. Types of CSRF Attack.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 4. Advanced Client-Side Attacks > 2. CSRF",
    "content": "<h2>CSRF Tradicional</h2>\nLos ataques CSRF convencionales suelen concentrarse en acciones de estado cambiante llevadas a cabo subiendo formularios. La víctima es engañada para subir un formulario sin darse cuenta de las cookies asociadas, los parámetros de la URL, etc. El servidor web de la víctima manda una petición HTTP a la aplicación web donde la víctima ya está autentificada. Estas suelen ser para transferir dinero, modificar información de la cuenta o alterar una dirección de correo electrónico.\n\n![[Pasted image 20260215113909.png]]\n\nEl diagrama de arriba muestra los pasos tradicionales de un ataque CSRF:\n\n- La víctima ya está autentificada en su sitio de banco online. Los atacantes crean un link malicioso y se lo mandan a la víctima.\n- La víctima abre el email en el mismo navegador.\n- Una vez hecho click, el link malicioso permite la autotransferencia de dinero del navegador de la víctima a la cuenta del atacante.\n\n----------------------------------------\n<h2>CSRF XMLHttpRequest</h2>\nLa explotación CSRF asíncrona ocurre cuando las operaciones se inician sin un ciclo completo de página petición-respuesta. Esto es típico de las apps online contemporáneas que aprovechan la comunicación asíncrona con el servidor (via XMLHttpRequest o Fetch API) y JavaScript para producir interfaces de usuario más dinámicas.\n\nConsidera un cliente de email online, por ejemplo, cuando un usuario puede cambiar sus preferencias de email sin recargar la página. Si esta aplicación es vulnerable a CSRF, un hacker puede crear una petición asíncrona falsa y alterar las preferencias de la víctima, autoreenviando toda su correspondencia a una dirección maliciosa.\n\nEsta es una vista simplificada de los pasos que un ataque asíncrono podría tomar:\n\n- La víctima abre una sesión guardada en las cookies de su navegador y se registra en `mailbox.thm`.\n- El atacante incita a la víctima a abrir una página maliciosa con un script que pueda mandar queries a `mailbox.thm`.\n- Para modificar las preferencias de reenvío de su email, el script malicioso en la página del atacante hace una llamada AJAX a `mailbox.thm/api/updateEmail` (usando XMLHttpRequest o Fetch).\n- La cookie de sesión de `mailbox.thm` se incluye con la petición AJAX en el navegador de la víctima.\n- Después de recibir la petición AJAX, `mailbox.thm` evalúa y modifica la configuración de la víctima si no existe protección CSRF.\n\n----------------------------------------\n<h2>CSRF Basado en Flash</h2>\nEl término \"Flash-Based CSRF\" describe la técnica de realizar un ataque CSRF aprovechando las debilidades de los componentes Adobe Flash Player. Las aplicaciones de internet con funcionalidades como contenido interactivo, streaming de vídeo, y animaciones complejas, han sido posibles gracias a Flash. Sin embargo, a medida que ha pasado el tiempo, las debilidades de seguridad en Flash, particularmente aquellas usadas para lanzar CSRF, se han vuelto mayores. Al desarrollarse la tecnología HTML5, las debilidades se multiplicaron cesando su soporte (Adobe Flash Player) el 31 de Diciembre de 2020.\n\nIncluso aunque Flash ya no es mantenido, es necesario hablar de él por el legado que ha dejado en el internet que hoy conocemos. Un archivo malicioso de flash (`.swf`) mandará una petición no autorizada a otras webs.",
    "modified": "2026-02-16T01:08:34"
  },
  {
    "title": "4. Basic CSRF - Hidden Link-Image Exploitation",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/4-advanced-client-side-attacks/2-csrf/4-basic-csrf-hidden-link-image-exploitation/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/4. Advanced Client-Side Attacks/2. CSRF/4. Basic CSRF - Hidden Link-Image Exploitation.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 4. Advanced Client-Side Attacks > 2. CSRF",
    "content": "<h2>Vista General</h2>\nUna técnica cubierta conocida como \"hidden link/image exploitation\" en CSRF involucra a un atacante insertando una imagen de 0x0 píxeles o un link en una página web que sea prácticamente indetectable para el usuario. Típicamente el elemento `src` o `href` es configurado a la dirección de destino intencionada para actuar en nombre del usuario sin su conocimiento. Se aprovecha del hecho de que el navegador del usuario transfiere credenciales como cookies automáticamente.\n\n```html\n<!-- Website --> \n<a href=\"https://mybank.thm/transfer.php\" target=\"_blank\">Click Here</a>  \n<!-- User visits attacker's website while authenticated -->\n```\n\nEsta técnica se basa en sesiones autentificadas y utiliza ingeniería social para acercarse al usuario\n\n-----------------------------------------\n<h2>Cómo Funciona</h2>\nAhora que estás conectado a la VM, vamos a ver cómo funciona el ataque:\n\n- La máquina virtual representa la máquina de Josh, que usa Chrome para comprobar su email (`http://mailbox.thm:8081`) e iniciar sesión en su cuenta del banco (`http://mybank.thm:8080`). Debido a que es broker y debe hacer muchas transferencias diariamente, mantiene su sesión activa en el navegador todo el día.\n- El atacante, de alguna manera, averigua que Josh usa `mybank.thm:8080` para transacciones y que su cuenta siempre está activa.\n- El atacante también tiene una cuenta en el mismo banco, por lo que inicia sesión y busca vulnerabilidades.\n- Tú también puedes iniciar sesión en la cuenta de banco usando `GB82MYBANK5698:GB82MYBANK5698`.\n- Mientras escanea, encuentra que no se manda ningún parámetro adicional de la app de banco al transferir el pago. Este es el código que maneja la transferencia de fondos.\n\n```php\n<?php \n<form action=\"transfer.php\" method=\"post\">\n\n    <label for=\"to_account\">To Account:</label>\n    <input type=\"text\" id=\"to_account\" name=\"to_account\" required>\n\n    <label for=\"amount\">Amount:</label>\n    <input type=\"number\" id=\"amount\" name=\"amount\" required>\n\n    <button type=\"submit\">Transfer</button>\n</form>\n```\n\n- Aquí, el atacante puede emplear la técnica de la imagen escondida para construir un email y engañar a la víctima para que haga click en el link. El atacante sólo conoce la dirección de email de Josh por lo que lanza un ataque de ingeniería social mandándole el siguiente email.\n\n![[Pasted image 20260215131502.png]]\n\n- Lo más importante es que el atributo src de la imagen está configurado a la página de transferencia del banco. El atacante puede esconderlo o poner una imagen válida con la etiqueta anchor (`<a>`).\n\n```html\n<a href=\"http://mybank.thm:8080/dashboard.php?to_account=GB82MYBANK5698&amount=1000\" target=\"_blank\">Click Here to Redeem</a>\n```\n\n- Pare entender la perspectiva de la víctima, navega hasta la bandeja de entrada de Josh en `mailbox.thm:8081` para ver un nuevo email diciendo que ha ganado un viaje a Dubai y tiene que reclamarlo.\n- Una vez que hace click en el link, se le redirige a la página del banco de transferencias y los fondos son transferidos automáticamente.\n\n![[Pasted image 20260215131826.png]]\n\n------------------------------------\n<h2>¿Cuál era el Link Faltante?</h2>\nTodas las validaciones son correctas y precisas, sin embargo, el servidor no valida si la petición viene de un usuario legítimo.\n\n------------------------------------\n<h2>Securizando la Brecha</h2>\n- Desde el punto de vista de un pentester, es vital testear cada parámetro de petición y respuesta del formulario.\n- Desde el punto de vista del desarrollador, es importante asegurar que cada petición subida al servidor web contiene un token único para que el servidor pueda identificar si se ha hecho click a partir de un enlace válido.\n- El equipo IT del banco identifican rápidamente el problema y añaden un token CSRF con cada petición subida al servidor. El siguiente código contiene el código actualizado del lado del cliente. Podemos ver que hay un parámetro extra escondido, `csrf_token`, que será mandado al servidor con cada petición.\n\n```html\n<form method=\"post\" action=\"\">\n        <label for=\"password\">Password:</label>\n        <input type=\"password\" id=\"password\" name=\"current_password\" required>\n\n        <label for=\"confirm_password\">ConfirmPassword:</label>\n        <input type=\"password\" id=\"confirm_password\" name=\"confirm_password\" required>\n\t\t<input type=\"hidden\" id=\"csrf_token\" name=\"csrf_token\" value=\"<?php echo $_COOKIE['csrf-token']; ?>\">\n        <button type=\"submit\" name=\"password_submit\" >Update Password</button>\n    </form>submit\">\n</form> \n```\n\n- Del lado del servidor, este verificará si cada petición entrante contiene un token único, de no ser así lo rechaza.\n- Abre la bandeja de entrada de Josh y navega hasta el email del atacante con la chapa verde.\n\n![[Pasted image 20260215132719.png]]\n\n- Cuando el usuario hace click en el link, no transferirá los fondos ya que a la petición le falta el token CSRF único.\n\n![[Pasted image 20260215132809.png]]",
    "modified": "2026-02-16T01:08:34"
  }
]