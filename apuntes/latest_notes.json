[
  {
    "title": "2. Finding the Ingredients",
    "path": "/apuntes/thm/maquinas/1-easy/2-pickle-rick/2-finding-the-ingredients/",
    "src": "content/Ciberseguridad/THM/Maquinas/1. Easy/2. Pickle Rick/2. Finding the Ingredients.md",
    "breadcrumb": "THM > Maquinas > 1. Easy > 2. Pickle Rick",
    "content": "1. Empezamos escaneando la máquina.\n   ![[Pasted image 20251218181133.png]]\n2. Vamos a ir a la página web (puerto 80).\n   ![[Pasted image 20251218181652.png]]\n   Básicamente Rick nos pide ayuda porque necesita sus ingredientes que están en el ordenador pero no recuerda su contraseña y sin ella no nos podemos loguear. Sabemos que él es Rick, por lo que el usuario puede ser algo tipo `admin`, `root` o `rick`, siendo la última la más probable.\n3. Pero bueno, de momento vamos a seguir con el reconocimiento. Vamos a enumerar directorios con `gobuster`.\n   ![[Pasted image 20251218183448.png]]\n4. Mientras tanto vamos a inspeccionar la página con `Ctrl+U`.\n   ![[Pasted image 20251218182231.png]]\n   Vaya vaya, acabamos de encontrar el usuario: `R1ckRul3s`.\n5. Vamos a meternos en `/assets`.\n   ![[Pasted image 20251218183038.png]]\n6. Parece que hay unos cuantos archivos, vamos a descargarlos para examinarlos.\n   ![[Pasted image 20251218183334.png]]\n   O bien hay un formulario de subida o bien hay mensajes ocultos aquí, seguro.\n7. Después de usar `file` y `exiftool` parece ser que no hay nada.\n   ![[Pasted image 20251218183958.png]]\n8. Vamos a lanzar un ataque de fuerza bruta contra el puerto 22 de la máquina, es nuestra última bala.\n   ![[Pasted image 20251218184534.png]]\n   No funciona.\n9. Intentar loguearse sin más tampoco.\n   ![[Pasted image 20251218184604.png]]\n10. Vamos a hacer un escaneo más a fondo.\n    ![[Pasted image 20251218184642.png]]\n    Parece que SSH es una versión antigua.\n11. No he encontrado nada después de buscar vulnerabilidades de las versiones de SSH y Apache. Así que he optado por realizar más enumeración.\n    ![[Pasted image 20251218191615.png]]\n12. Vamos  a la página de `login.php`.\n    ![[Pasted image 20251218190310.png]]\n13. Vamos a interceptar la petición con Burp Suite para ver cómo es.\n    ![[Pasted image 20251218190431.png]]\n    Es una petición por POST.\n14. Vamos a lanzar un ataque de fuerza bruta contra la página de login.\n\t1. Primero probamos cómo se ve la respuesta cuando la metemos mal.\n\t   ![[Pasted image 20251218191255.png]]\n\t2. Con esta información ya podemos iniciar el ataque de fuerza bruta.\n\t   ![[Pasted image 20251218192000.png]]\n15. Mientras espero me da por seguir mirando y enumerando en la página. Pruebo `/robots.txt`.\n    ![[Pasted image 20251218191835.png]]\n    Parece que podría ser la contraseña. Esto es algo que Rick dice muuuuucho.\n16. Efectivamente era la contraseña.\n    ![[Pasted image 20251218191925.png]]\n    Ya no tiene sentido seguir con el ataque de fuerza bruta así que lo paro.\n17. Parece que podemos ejecutar comandos. Vamos a listar y a leer si hay algo interesante.\n    ![[Pasted image 20251218194113.png]]\n18. No se puede hacer `cat` directo.\n    ![[Pasted image 20251218194152.png]]\n19. Si nos ponemos a investigar, en todas las otras páginas se ve el `/denied.php`.\n    ![[Pasted image 20251218194818.png]]\n20. Si lo intentamos borrar no podemos porque es propiedad de `Ubuntu`. Pero si escribimos `sudo -l`:\n    ![[Pasted image 20251218194951.png]]\n21. Si hacemos `sudo rm denied.php`.\n    ![[Pasted image 20251218195105.png]]\n22. Tampoco funciona así.\n    ![[Pasted image 20251218195307.png]]\n23. Vamos a probar con una reverse shell.\n    ![[Pasted image 20251218195437.png]]\n    ![[Pasted image 20251218195606.png]]\n24. Recibimos la shell.\n    ![[Pasted image 20251218195626.png]]\n25. Estabilizamos y mejoramos la shell.\n    ![[Pasted image 20251218195832.png]]\n26. Leemos el primer ingrediente.\n    ![[Pasted image 20251218195912.png]]\n    En `clue.txt` pone que miremos por el sistema de archivos para encontrar la segunda pista.\n27. Buscando llegamos al perfil de `rick`.\n    ![[Pasted image 20251218200239.png]]\n28. Y allí leemos el segundo ingrediente.\n    ![[Pasted image 20251218200305.png]]\n29. Si buscamos por history.\n    ![[Pasted image 20251218200637.png]]\n30. Si lo leemos.\n    ![[Pasted image 20251218200712.png]]\n\n>[!SUCCESS] Hemos encontrado todos los ingredientes :))",
    "modified": "2025-12-19T00:53:33"
  },
  {
    "title": "1. Introduction",
    "path": "/apuntes/thm/maquinas/1-easy/2-pickle-rick/1-introduction/",
    "src": "content/Ciberseguridad/THM/Maquinas/1. Easy/2. Pickle Rick/1. Introduction.md",
    "breadcrumb": "THM > Maquinas > 1. Easy > 2. Pickle Rick",
    "content": "![[Pasted image 20251218165357.png]]\n\nEste reto ambientado en Rick y Morty requiere que explotes un servidor web y encuentres tres ingredientes para ayudar a Rick a hacer su poción y transformarse de nuevo en humano (ahora es un pepinillo, **El Rickynillo**).",
    "modified": "2025-12-19T00:53:33"
  },
  {
    "title": "9. Bypassing Server-Side Filtering - Magic Numbers",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/9-bypassing-server-side-filtering-magic-numbers/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/9. Bypassing Server-Side Filtering - Magic Numbers.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "Ya hemos visto el filtrado de extensiones del lado del servidor, pero vamos a aprovechar para ver cómo se comprueban los magic numbers del lado del servidor también.\n\nLos magic numbers se utilizan para identificar los archivos de manera más precisa. El magic number de un archivo es una string de dígitos hexadecimales y es siempre la primera parte de un archivo. De esta manera, leyendo los primeros bytes de un archivo y comparándolos con una whitelist o blacklist, podemos verificar si el archivo es o no legítimo para su subida.\n\n>[!IMPORTANT] Esta técnica puede ser efectiva contra servidores basados en PHP pero puede fallar contra otros tipos de servidores web.\n\nVeamos un ejemplo. Como generalmente, tenemos una página de subida.\n\n![[Pasted image 20251217135821.png]]\n\nComo es esperado, si subimos una shell.php, obtendremos un error. Sin embargo, si subimos un JPEG, el sitio web lo acepta.\n\nDel intento anterior sabemos que los archivos JPEG son aceptados, por lo que le meteremos los magic numbers de JPEG a nuestro `shell.php`. Una vista rápida a la [lista de firmas de la Wikipedia](https://en.wikipedia.org/wiki/List_of_file_signatures) muestra que hay varias posibilidades de magic numbers para archivos JPEG. No debería importar cuál usemos aquí, así que elegiremos uno (`FF D8 FF DB`). Podríamos añadir la representación ASCII de estos caracteres (`ÿØÿÛ`) al principio del documento, pero es más fácil trabajar directamente en hexadecimal.\n\nAntes de empezar, usaremos el comando `file` para comprobar el tipo de archivo de shell.php:\n\n![[Pasted image 20251218111141.png]]\n\nObviamente nos dice que es un archivo PHP. Ahora vamos a añadir 4 caracteres (porque el magic number que hemos seleccionado son 4 caracteres) al inicio del documento. No importa qué caracteres sean.\n\n![[Pasted image 20251218111513.png]]\n\nAhora vamos a abrirlo con `hexeditor` o cualquier otra herramienta que permita editar en hexadecimal.\n\n![[Pasted image 20251218111555.png]]\n\nPor lo que se ve la \"A\" se representa como 41 en hezadecimal. Vamos a cambiar las 4 \"A\"s por magic numbers.\n\n![[Pasted image 20251218111640.png]]\n\nSi ahora usamos el comando `file`:\n\n![[Pasted image 20251218111829.png]]\n\nAhora vamos a subir la shell.\n\n![[Pasted image 20251218111849.png]]\n\nAhí lo tenemos, hemos bypasseado el filtro basado en magic numbers del lado del servidor y obtenido una reverse shell.\n\n---------------------------------------\nVe a `magic.uploadvulns.thm` y encuentra la flag en `/var/www/`.\n\n1. Vamos a la página dada.\n   ![[Pasted image 20251218115633.png]]\n2. Vamos a escanear la página con `gobuster`.\n   ![[Pasted image 20251218121545.png]]\n3. Vamos a probar a subir nuestra reverse shell del tirón.\n   ![[Pasted image 20251218115909.png]]\n   Parece que sólo admiten GIFs.\n4. Vamos a la [página de firmas de la Wikipedia](https://en.wikipedia.org/wiki/List_of_file_signatures) y buscamos por GIF.\n   ![[Pasted image 20251218120019.png]]\n5. Abrimos nuestro archivo shell y le metemos 6 caracteres cualquiera.\n   ![[Pasted image 20251218120113.png]]\n6. Abrimos el documento con `hexeditor`.\n   ![[Pasted image 20251218120156.png]]\n7. Cambiamos los \"42\" por los caracteres seleccionados, por ejemplo `47 49 46 38 37 61`.\n   ![[Pasted image 20251218120320.png]]\n8. Guardamos y comprobamos con `file`.\n   ![[Pasted image 20251218120358.png]]\n9. Subimos el archivo \"GIF\".\n   ![[Pasted image 20251218120620.png]]\n10. Nos ponemos en escucha.\n    ![[Pasted image 20251218121624.png]]\n11. Intentamos navegar a nuestra shell, que estará en `/graphics`.\n    ![[Pasted image 20251218121730.png]]\n    Hemos recibido la reverse shell.\n12. Vamos a leer la flag.\n    ![[Pasted image 20251218121829.png]]",
    "modified": "2025-12-19T00:53:33"
  },
  {
    "title": "10. Example Methodology",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/10-example-methodology/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/10. Example Methodology.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "Hemos visto varios tipos de filtro ya, tanto del lado del cliente como del lado del servidor. En la próxima tarea realizaremos un reto black-box, así que vamos a ver cómo es una metodología de acercamiento para este tipo de reto.\n\n1. Lo primero que deberíamos hacer es mirar la página web entera. Usando extensiones de navegador como Wappalyzer, o a mano, buscaríamos indicadores de lenguages y frameworks que usan las aplicaciones web. Un buen comienzo manual sería mandar una petición a la web e interceptarla con Burp Suite buscando headers como `server` o `x-powered-by`. También buscaríamos vectores potenciales de ataque.\n2. Habiendo encontrado una página de subida, intentaríamos inspeccionarla más a fondo. Mirando el código fuente en busca de scripts del lado del cliente para determinar si hay algún tipo de filtro del lado del cliente.\n3. Luego intentaríamos subir un archivo completamente inocente. Desde ahí buscaríamos a ver cómo se accede a nuestro archivo. En este paso es donde herramientas como `gobuster` entran en juego. Este paso es extremadamente importante pues no sólo nos da un mejor entendimiento de la web, sino que nos da una idea de archivos aceptados en los que podemos basar nuestra investigación futura. Un parámetro muy útil es `-x`, que nos permite listar archivos, Por ejemplo con `-x php,txt,html`.\n4. Sabiendo cómo y dónde se suben nuestros archivos, intentaríamos una subida de archivos maliciosa, bypasseando cualquier filtro del lado del cliente. Según el error que devuelva el servidor haríamos una cosa u otra.\n\nAsumiendo que nuestro archivo ha sido parado por el servidor, aquí tienes algunas formas de asegurarte qué tipo de filtros del lado del servidor hay:\n\n- Si puedes subir un archivo con una extensión totalmente inválida (`test.invalidfileextension`),  lo más probable es que el servidor esté usando una blacklist para filtrar extensiones.\n- Prueba a subir el archivo inocente de nuevo pero cambia los magic numbers. Si falla, sabes que el servidor usa un filtro de magic numbers.\n- Ahora prueba a resubir tu archivo inocente pero intercepta la petición en Burp Suite y cambia el tipo MIME a algo que esperarías que fuese filtrado. Si falla sabes que el filtro está basado en tipos MIME.\n- Enumerar tamaño de archivos se basa en empezar subiendo un archivo pequeño e ir incrementando su tamaño hasta dar con el límite.",
    "modified": "2025-12-19T00:53:33"
  },
  {
    "title": "11. Challenge",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/11-challenge/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/11. Challenge.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "Navega hasta `jewel.uploadvulns.thm` y encuentra la flag en `/var/www`.\n\n1. Vamos a la página dada.\n   ![[Pasted image 20251218141614.png]]\n   Si nos quedamos unos segundos parados, podemos ver que en realidad las imágenes se van moviendo, es decir, que es un carrusel que la página va cargando. Por desgracia, en el html de la página no pone desde dónde se están cargando estas imágenes.\n2. Vamos a lanzar un escaneo contra la página.\n   ![[Pasted image 20251218144822.png]]\n3. Buscaremos filtros JavaScript del lado del cliente.\n   ![[Pasted image 20251218142004.png]]\n   Metiéndonos en el Debugger, podemos observar algunos scripts JavaScript. En concreto uno que se llama `upload.js` nos da una pista de que está siendo llamado al intentar subir un archivo. Si revisamos el script, tiene hasta comentarios por lo que no hace ni falta saber JS. Está utilizando:\n\t1. Un filtro de tamaño.\n\t2. Un filtro de Magic Numbers.\n\t3. Un filtro de extensión de archivo.\n4. Vamos a intentar subir nuestro archivo `reverseshell.php`.\n\t1. Primero vamos a modificar el archivo para que se ajuste a nuestra IP y puerto (`/usr/share/webshells/php/php-reverse-shell.php`). Y ahora vamos a cambiarle la extensión a `.jpg`.\n\t   ![[Pasted image 20251218153533.png]]\n\t2. Ahora modificamos los magic numbers con `hexeditor`.\n\t   ![[Pasted image 20251218153801.png]]\n\t3. Lo guardamos y lo subimos.\n\t   ![[Pasted image 20251218153839.png]]\n\t   Vaya, parece que hemos sobrepasado del tirón los filtros del lado del cliente y del lado del servidor. Porque no olvidemos que acabamos de subir una reverse shell.\n5. Si nos fijamos en el escaneo podemos ver unas cuantas páginas interesantes. La más interesante parece `/admin`.\n   ![[Pasted image 20251218154737.png]]\n   Parece una página que ejecuta código.\n6. También hay otra que se llama `/content`. Si combinamos esta información con lo que podíamos ver en el apartado de \"Network\" en la página del carrusel podemos ver el tipo de nombre que tienen las imágenes guardadas en este directorio.\n   ![[Pasted image 20251218154939.png]]\n   Ademas nos dan un diccionario en la actividad que va desde `AAA → ZZZ`.\n7. Vamos a lanzar un escaneo de archivos `.jpg` con dicho diccionario sobre `jewel.uploadvulns.thm/content/`.\n   ![[Pasted image 20251218155445.png]]\n8. Basándonos en el tamaño de nuestra shell, podemos concretar que `YBW.jpg` es, de hecho, nuestra shell.\n   ![[Pasted image 20251218155556.png]]\n9. Nos ponemos en escucha.\n   ![[Pasted image 20251218155646.png]]\n10. Volvemos a la página de `/admin` e intentaremos ejecutar nuestra shell.\n    ![[Pasted image 20251218155719.png]]\n11. Parece que no funciona.\n    ![[Pasted image 20251218160030.png]]\n12. Hacemos más reconocimiento.\n    ![[Pasted image 20251218160056.png]]\n    Parece que no usa PHP, sino Node.js, hay que cambiar de reverse shell.\n13. Vamos a [Reverse Shell Generator](https://www.revshells.com/).\n    ![[Pasted image 20251218160519.png]]\n14. Realizamos el proceso de modificación de extensión y magic numbers entero otra vez, subimos el archivo nuevo y realizamos otro escaneo con el diccionario proporcionado.\n    ![[Pasted image 20251218161220.png]]\n    Basándonos en el escaneo anterior podemos determinar que el archivo que acabamos de subir es `CDB.jpg`.\n15. Cargamos el archivo nuevo estando en escucha.\n    ![[Pasted image 20251218161339.png]]\n    Tampoco ha funcionado.\n    ![[Pasted image 20251218160030.png]]\n16. Vamos a probar con una shell de [Payloads All The Things](https://swisskyrepo.github.io/InternalAllTheThings/cheatsheets/shell-reverse-cheatsheet/#nodejs). Repetimos los pasos.\n    ![[Pasted image 20251218160030.png]]\n17. Tampoco ha funcionado por lo que debe ser un tema de los magic numbers. Para evitar tener que ponerlos tenemos que usar Burp Suite para quitar ese JS que bloquea del lado del cliente.\n\t1. Abrimos Burp Suite y le damos a `Proxy → Proxy settings`.\n\t   ![[Pasted image 20251218163135.png]]\n\t2. Ahí le damos a la primera línea y a \"Edit\".\n\t   ![[Pasted image 20251218163348.png]]\n\t3. Eliminamos `^js$|`.\n\t   ![[Pasted image 20251218163425.png]]\n\t4. Capturamos las peticiones de la página de subida. **ES MUY IMPORTANTE RECARGAR LA CACHE (`Ctrl+Shift+R`)**.\n\t   ![[Pasted image 20251218163657.png]]\n\t5. Le damos a forward hasta que nos aparezca `upload.js` y le damos a intercept this request.\n\t   ![[Pasted image 20251218163913.png]]\n\t6. Le damos a forward y recibiremos la respuesta.\n\t   ![[Pasted image 20251218164008.png]]\n\t7. Eliminamos los checks.\n\t   ![[Pasted image 20251218164048.png]]\n\t8. Le seguimos dando a forward hasta que cargue la página.\n\t   ![[Pasted image 20251218164128.png]]\n\t9. Ahora vamos a subir la shell de node.js sin los magic numbers.\n\t   ![[Pasted image 20251218153839.png]]\n\t10. Escanearemos el contenido de nuevo.\n\t    ![[Pasted image 20251218164955.png]]\n\t    Sabemos que el archivo es `PYL.jpg`.\n18. Lo ejecutamos.\n    ![[Pasted image 20251218165029.png]]\n19. Leemos la flag.\n    ![[Pasted image 20251218165112.png]]",
    "modified": "2025-12-19T00:53:33"
  }
]