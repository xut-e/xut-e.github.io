[
  {
    "title": "1. Key Concepts",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/4-oauth-vulnerabilities/1-key-concepts/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/4. OAuth Vulnerabilities/1. Key Concepts.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 4. OAuth Vulnerabilities",
    "content": "EN esta tarea veremos los conceptos clave para entender OAuth, específicamente OAuth 2.0. Para hacer los conceptos más fáciles de entender, los explicaremos mediante un ejemplo: usar la app de móvil de una cafetería para pedir y pagar un café.\n\n---------------------------------------------\n<h2>Resource Owner</h2>\nEl dueño del recurso es la persona o sistema que controla cierta información y puede autorizar a la aplicación a acceder a dicha información en su nombre. Este concepto es fundamental, ya que se centra en el contenido del usuario y su control. Por ejemplo, eres el dueño del recurso siendo un cliente de la cafetería, ya que puedes controlar la información de tu cuenta y darle permiso a la app para acceder a tus datos.\n\n----------------------------------------\n<h2>Client</h2>\nEl cliente puede ser una app móvil o una aplicación web del lado del servidor. Actúa como intermediario, pidiendo acceso a recursos y realizando las acciones que el dueño del recurso le permite. Por ejemplo, la aplicación web o móvil  de la cafetería es el cliente. El cual necesita tu autorización para acceder a los detalles de tu cuenta, incluyendo la información de pago.\n\n-----------------------------------\n<h2>Servidor de Autorización</h2>\nEl servidor de autorización es responsable de emitir tokens de acceso al cliente después de haber autentificado exitosamente al dueño del recurso y haber obtenido su autorización. El servidor de autorización juega un papel crucial en el proceso OAuth asegurándose de que el cliente recibe el permiso sólo después de que se realice un consentimiento y autorización de usuario legítimos. Por ejemplo, el sistema de backend  de la cafetería que maneja la autentificación y autorización es el servidor de autorización. Verifica tus credenciales y le da permiso (si son correctas) a la app para que acceda a tu cuenta.\n\n----------------------------------------------\n<h2>Servidor de Recursos</h2>\nEl servidor que hostea los recursos protegidos puede aceptar y responder a las peticiones hacia estos recursos usando tokens. Este servidor se asegura de que sólo clientes autentificados y autorizados puedan acceder o manipular la información del dueño del recurso. Por ejemplo, sería la base de datos de la cafetería que guarda tu información de cuenta, historial de compra y detalles de pago. Responde a peticiones de la aplicación permitiéndole recuperar y modificar tu información.\n\n--------------------------------------\n<h2>Authorization Grant</h2>\nEl cliente usa una credencial representando la autorización del dueño del recurso para obtener un token de acceso. Los tipos primarios de permiso son: `Authorization Code`, `Implicit`, `Resource Owner Password Credentials` y `Client Credentials`. Por ejemplo, cuando inicias sesión en la app de la cafetería, se te da un permiso de autorización. La aplicación usa este permiso para darte un token de acceso desde el servidor de autorización.\n\n--------------------------------\n<h2>Refresh Token</h2>\nUna credencial que el cliente puede usar para obtener un nuevo token de acceso sin requerir que el dueño del recurso se re-autentifique. Los tokens de refresco, suelen tener un gran tiempo de vida y ofrecen una forma de mantener las sesiones del usuario sin interrupciones frecuentes de login. Por ejemplo, cuando tu token de acceso vence, la aplicación web usa el token de refresco para obtener un nuevo token de acceso para que no tengas que volver a loguearte.\n\n------------------------------------------\n<h2>Redirect URI</h2>\nLa URI a la que el servidor de autorización redirigirá al user-agent del dueño del recurso después de la aceptación o denegación de la autorización. Comprueba si el cliente para el que se ha pedido la respuesta es correcto. Por ejemplo, después de interactuar con la app de la cafetería e iniciar sesión, serás redirigido al servidor de autorización por la página de la app, conocida como URI de redirección para confirmar que has iniciado sesión exitosamente.\n\n---------------------------------------\n<h2>Scope</h2>\nScopes son un mecanismo para limitar los accesos de una aplicación a la cuenta de un usuario. Permiten al cliente especificar el nivel de acceso necesitado y al servidor de autorización informar al usuario sobre los niveles de acceso que la aplicación pide. El alcance (scope) ayuda a reforzar el concepto de los menos privilegios posibles. Por ejemplo, la app de la cafetería puede pedir diferentes scopes, como acceso a tu historial de compra e información de pago. Como dueño del recurso, puedes ver qué información pide la app y dar o denegar dichos permisos.\n\n-----------------------------------------------\n<h2>State Parameter</h2>\nUn parámetro opcional mantiene el estado entre el cliente u el servidor de autorización. Puede ayudar a prevenir ataques CSRF asegurando que la respuesta coincide con la petición del cliente. El parameter state es una parte crucial de securizar el flujo OAuth. Por ejemplo, cuando inicias el proceso de login, la app de la cafetería manda  un parameter state al servidor de autorización. Este parámetro ayuda a asegurar que la respuesta que recibes está vinculada a tu petición original, protegiendo contra cierto tipo de ataques.\n\n------------------------------------------\n<h2>Token & Authorization Endpoint</h2>\nEl endpoint del servidor de autorización es donde el cliente intercambia el permiso de autorización (o refresh token) por un token de acceso. Por el contrario, el endpoint de autorización es donde el dueño del recurso se autentifica y autoriza al cliente para acceder a recursos protegidos.",
    "modified": "2025-12-22T00:56:16"
  },
  {
    "title": "2. OAuth Grant Types",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/4-oauth-vulnerabilities/2-oauth-grant-types/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/4. OAuth Vulnerabilities/2. OAuth Grant Types.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 4. OAuth Vulnerabilities",
    "content": "OAuth 2.0 ofrece varios tipos de permisos para acomodarse a varios escenarios y tipos de clientes. Estos tipos definen cómo la aplicación puede obtener un token de acceso para acceder a recursos protegidos en nombre del dueño del recurso. En esta tarea, veremos 4 tipos de permiso OAuth 2.0.\n\n------------------------------------\n<h2>Authorization Code Grant</h2>\nEste es el flujo OAuth más usado que se ajusta a las aplicaciones del lado del servidor (PHP, JAVA; .NET, etc). En este flujo **el cliente redirige al usuario al servidor de autorización, donde el usuario se autentifica y concede la autorización**. El servidor entonces redirige al usuario al cliente con el código de autorización. El cliente intercambia dicho código por un token de acceso pidiéndoselo al endpoint del token del servidor de autorización.\n\n![[Pasted image 20251221174848.png]]\n\nEs conocido por ensalzar la seguridad, ya que el código de autorización es intercambiado por un token de acceso server-to-server, por lo que el token no es expuesto mediante el user agent (navegador), reduciendo el riesgo de filtración de token. También soporta usar tokens de refresco.\n\n----------------------------------\n<h2>Implicit Grant</h2>\nEstá principalmente diseñado para aplicaciones web y móviles donde los clientes no pueden guardar secretos de forma segura. **Emite directamente el token de acceso al cliente sin requerir la autorización de un código externo**. En este flujo, el cliente redirige al usuario al servidor de autorización. Después de que el usuario se autentifique y le de autorización, el servidor de autorización devuelve un token de acceso en el fragmento URL. El flujo es así:\n\n![[Pasted image 20251221232716.png]]\n\nEste tipo de permiso está simplificado y es adecuado para clientes que no pueden guardar secretos de forma segura. Es más rápido ya que incluye menos pasos que el authorization code grant. Sin embargo, es menos seguro ya que el token de acceso está expuesto en el user agent y puede ser registrado por el historial del navegador. Además no soporta tokens de refresco.\n\n------------------------------------------\n<h2>Resource Owner Password Credentials Grant</h2>\nSe usa cuando el cliente es **altamente confiado por el dueño del recurso**, como las aplicaciones first-party. El cliente colecciona las credenciales del usuario directamente y las intercambia por un token de acceso como se muestra debajo.\n\n![[Pasted image 20251221234303.png]]\n\nEn este flujo, el usuario ofrece sus credenciales directamente al cliente. El cliente manda las credenciales al servidor de autorización el cual verifica las credenciales y emite un token de acceso. Este tipo de permiso es directo, requiriendo menos interacciones, haciéndolo adecuado para aplicaciones altamente confiables donde el usuario está seguro de dar sus credenciales. Sin embargo, es menos seguro porque incluye compartir las credenciales directamente con el cliente y no es sostenible para aplicaciones de terceros.\n\n--------------------------------------\n<h2>Client Credentials Grant</h2>\nSe usa para las interacciones server-to-server sin intromisión del usuario. El cliente usa sus credenciales para autentificarse con el servidor de autorización y obtener un token de acceso. En este flujo el cliente se autentifica con el servidor de autorización usando sus credenciales, y el servidor de autorización emite un token de acceso directamente al cliente como se ve aquí abajo:\n\n![[Pasted image 20251221234739.png]]\n\nEl adecuado para servicios backend y comunicaciones servidor a servidor ya que no incluye credenciales de usuario, por lo que reduce los riesgos de seguridad relativos a la exposición de datos del usuario.",
    "modified": "2025-12-22T00:56:16"
  },
  {
    "title": "3. Sensitive Information Disclosure",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/3-jwt-security/3-sensitive-information-disclosure/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/3. JWT Security/3. Sensitive Information Disclosure.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 3. JWT Security",
    "content": "<h2>Divulgación de Información Sensible</h2>\nEl primer problema común que veremos será la exposición de información en el JWT.\n\nUn acercamiento de manejo de sesiones basado en cookies usa la sesión del lado del servidor para guardar múltiples parámetros. En PHP, por ejemplo, puedes usar `$SESSION['var']=data` para guardar un valor asociado con la sesión de un usuario. Estos valores no se exponen del lado del cliente y por ello sólo pueden ser recuperados del lado del servidor. Sin embargo, con los tokens, las afirmaciones son expuestas ya que el JWT entero se manda al lado del cliente. Algunos ejemplos serían:\n\n- Divulgación de credenciales en hash, o pero, en texto claro si la contraseña se manda como afirmación.\n- Exposición de información de la red interna como IP privada o hostname del servidor de autentificación.\n\n<h4>Ejemplo práctico 1</h4>\nVamos a autentificarnos en nuestra API con la siguiente petición cURL:\n\n`curl -H 'Content-Type: application/json' -X POST -d '{ \"username\" : \"user\", \"password\" : \"password1\" }' http://10.80.190.89/api/v1.0/example1`\n\nEsto nos devuelve un JWT token.\n\n![[Pasted image 20251220151113.png]]\n\nUna vez lo tenemos, decodeamos el body del JWT para ver información sensible. Puedes hacerlo manualmente o usar [JWT.io](https://jwt.io/) para hacerlo.\n\n![[Pasted image 20251220152644.png]]\n\n<h6>El Error de Desarrollo</h6>\nEn el ejemplo, la información sensible fue añadida a las afirmaciones, como se muestra debajo.\n\n```python\npayload = {\n    \"username\" : username,\n    \"password\" : password,\n    \"admin\" : 0,\n    \"flag\" : \"[redacted]\"\n}\n\naccess_token = jwt.encode(payload, self.secret, algorithm=\"HS256\")\n```\n\n<h6>El Arreglo</h6>\nValores como la contraseña o la flag no deberían ser añadidas a los claims (afirmaciones) ya que el JWT será mandado al cliente. En su lugar, estos valores deberían guardarse de forma segura en el backend del servidor. Al ser requeridos, el nombre de usuario puede ser leído de un JWT verificado y usado para comprobar el valor de la flag/contraseña.\n\n```python\npayload = jwt.decode(token, self.secret, algorithms=\"HS256\")\n\nusername = payload['username']\nflag = self.db_lookup(username, \"flag\")\n```",
    "modified": "2025-12-21T00:57:18"
  },
  {
    "title": "4. Signature Validation Mistakes",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/3-jwt-security/4-signature-validation-mistakes/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/3. JWT Security/4. Signature Validation Mistakes.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 3. JWT Security",
    "content": "El segundo error común con los JWTs es no verificar correctamente la firma. Si la firma no se verifica correctamente, un atacante puede falsificar un token JWT para ganar acceso a la cuenta del usuario.\n\n----------------------------------------\n<h2>No Verificar la Firma</h2>\nEl primer problema con la validación de la firma es cuando no hay validación de la firma. Si el servidor no verifica la firma del JWT, entonces es posible modificar los claims en el JWT a lo que prefieras que sean.\n\n<h4>Ejemplo Práctico 2</h4>\nNos autentificaremos en la API con:\n\n`curl -H 'Content-Type: application/json' -X POST -d '{ \"username\" : \"user\", \"password\" : \"password2\" }' http://10.80.190.89/api/v1.0/example2`\n\nUna vez autentificados, podemos ver nuestro usuario con:\n\n`curl -H 'Authorization: Bearer [JWT Token]' http://10.80.190.89/api/v1.0/example2?username=user`\n\n![[Pasted image 20251220155740.png]]\n\nSin embargo, vamos a tratar de autentificarnos sin firma para conseguir ser el usuario que queramos. Para ello, tenemos que modificar la claim de admin y el usuario, tanto del body como de la URL.\n\n![[Pasted image 20251220160034.png]]\n\n<h6>El Error de Desarrollo</h4>\nEn el ejemplo, la firma no se comprueba, como podemos ver debajo:\n\n```python\npayload = jwt.decode(token, options={'verify_signature': False})\n```\n\n>[!IMPORTANT] Aunque esto es bastante raro en APIs normales, suele ocurrir en las APIs \"server-to-server\". \n\n<h6>El Arreglo</h6>\nEl JWT siempre debería ser validado o deberían usarse factores de autentificación adicionales, como certificados para la comunicación entre servidores. El JWT puede verificarse dando el secreto (o clave pública) como se muestra debajo.\n\n```python\npayload = jwt.decode(token, self.secret, algorithms=\"HS256\")\n```\n\n-----------------------------------\n<h2>Downgrade a None</h2>\nOtro problema es el downgrade del algoritmo de firmado. JWT soporta el algoritmo de firmado `None`, que significa que no se usa firma. Aunque parece una idea \"tonta\", la idea era para la comunicación servidor a servidor, donde la firma del token ya se comprobaba en el proceso de escalado. Si los desarrolladores no requieren verificar el algoritmo, o al menos denegar el algoritmo `None`, puedes cambiar el tipo de algoritmo especificado en el header del JWT, lo que causaría que la librería usada para la verificación siempre devolviera true, permitiendo así falsificar claims del token.\n\n<h4>Ejemplo Práctico 3</h4>\nAutentifícate en la API para recibir tu token JWT y verificar tu usuario. Para realizar este ataque, necesitará alterar manualmente el claim `alg` a `None`. Puedes usar [CyberChef](https://gchq.github.io/CyberChef/)  para dicho propósito. Que no se te olvide poner el punto al final.\n\n![[Pasted image 20251220172813.png]]\n\n<h6>El Error de Desarrollo</h6>\nAunque parece el mismo problema que antes, desde el punto de vista de desarrollo, es más complejo. A veces, los desarrolladores quieren asegurarse de que su implementación admite varios algoritmos de verificación de firmas. La implementación se leería entonces, normalmente, el header del JWT y parsea el algoritmo encontrado en la verificación del componente.\n\n```python\nheader = jwt.get_unverified_header(token)\n\nsignature_algorithm = header['alg']\n\npayload = jwt.decode(token, self.secret, algorithms=signature_algorithm)\n```\n\nEl problema es obvio, si ponemos `None` entonces este se convierte en el algoritmo, con los consecuentes problemas. La librería [Pyjwt](https://pyjwt.readthedocs.io/en/stable/), tiene implementado código seguro para prevenir dicho problema.\n\n<h6>El Arreglo</h6>\nSi se deben soportar múltiples algoritmos, estos deberían ser declarados en el código como un array.\n\n```python\npayload = jwt.decode(token, self.secret, algorithms=[\"HS256\", \"HS384\", \"HS512\"])\n\nusername = payload['username']\nflag = self.db_lookup(username, \"flag\")\n```\n\n------------------------------------\n<h2>Secretos Simétricos Débiles</h2>\nSi se usa un algoritmo de firmado simétrico, la seguridad del JWT recae en la fortaleza y la entropía del secreto usado. Si se usa un secreto débil, puede ser posible realizar crackeo offline para recuperar el secreto. Una vez el valor secreto se conoce, puedes ganar acceso alterando las claims y recalculando una firma válida.\n\n<h4>Ejemplo Práctico 4</h4>\nPara este ejemplo, un secreto débil fue usado para generar el JWT. Una vez obtengas el JWT, tienes varias opciones para romper el secreto. Por ejemplo, puedes usar `hashcat` o `john`.\n\n1. Guarda el JWT en un archivo llamado `jwt.txt`.\n   ![[Pasted image 20251220181345.png]]\n2. Descarga una lista de secretos JWT comunes, vamos a usar `wget https://raw.githubusercontent.com/wallarm/jwt-secrets/master/jwt.secrets.list`.\n   ![[Pasted image 20251220181524.png]]\n3. Usamos hashcat para crackear el secret.\n   ![[Pasted image 20251220182248.png]]\n4. Ahora construimos el JWT y conseguimos la flag.\n   ![[Pasted image 20251220185838.png]]\n\n<h6>El Error de Desarrollo</h6>\nEl problema ocurre debido a que el secreto JWT usado es muy débil. Esto puede ocurrir si los desarrolladores tienen prisa o copian código de ejemplos.\n\n<h6>El Arreglo</h6>\nUn secreto seguro debe ser utilizado. Este valor será usado en el software y no por humanos, por lo que una string larga y aleatoria debería valer.\n\n---------------------------------------------\n<h2>Confusión del Algoritmo de Firmado</h2>\nEl último problema común con la validación de la firma es cuando se puede realizar un ataque de confusión de algoritmo. Es similar al ataque de downgrade `None`. Sin embargo, pasa específicamente con la confusión entre algoritmos de firmado simétricos y asimétricos. Si se usa un algoritmo asimétrico como RS356, puede ser posible hacer un downgrade del algoritmos a HS256. En estos casos, alguna librerías vuelven por defecto a usar la clave pública como clave simétrica. Como esta es conocida, puedes falsificar el JWT.\n\n<h4>Ejemplo Práctico 5</h4>\nEs similar al ejemplo 3. Excepto por que esta vez el algoritmo `None` no está permitido. Sin embargo, una vez que te autentifiques, también recibirás la clave pública. Como la clave pública no se reconoce como información sensible es común que la puedas encontrar. A veces incluso está incrustada como claim en el JWT. En este ejemplo debes downgradear el algoritmo a HS256 y usar la clave pública para falsificar un token.\n\n```python\nimport base64 \nimport hmac \nimport hashlib \nimport json \n\ndef b64url(data): \n\treturn base64.urlsafe_b64encode(data).decode('utf-8').replace('=', '') \n\n# 1. Datos \npublic_key = \"clave_pública\" \nheader = {\"typ\": \"JWT\", \"alg\": \"HS256\"} \npayload = {\"username\": \"admin\", \"admin\": 1} \n\n# 2. Codificar Header y Payload \njson_header = json.dumps(header, separators=(',', ':')).encode() \njson_payload = json.dumps(payload, separators=(',', ':')).encode() \ndata_to_sign = b64url(json_header) + \".\" + b64url(json_payload) \n\n# 3. Firmar usando la clave pública como secreto HMAC-SHA256 \nsignature = hmac.new( \n\tpublic_key.encode('utf-8'), \n\tdata_to_sign.encode('utf-8'), \n\thashlib.sha256 \n).digest() \n\n# 4. Token final \nprint(data_to_sign + \".\" + b64url(signature))\n```\n\nPuedes usar este código.\n\n1. Obtenemos el token y la clave pública.\n   ![[Pasted image 20251220192434.png]]\n2. Usamos el script de arriba para generar el token.\n   ![[Pasted image 20251220192510.png]]\n3. Obtenemos la flag.\n   ![[Pasted image 20251220192530.png]]\n\n<h6>El Error de Desarrollo</h6>\nEl error en este ejemplo es similar al del ejemplo 3 pero un poco más complejo. Aunque el algoritmo `None` está deshabilitado, el problema principal surge de que se permitan tanto los algoritmos simétricos como los asimétricos.\n\n```python\npayload = jwt.decode(token, self.secret, algorithms=[\"HS256\", \"HS384\", \"HS512\", \"RS256\", \"RS384\", \"RS512\"])\n```\n\nHay que tener cuidado especial para no permitir mezclar tipos de algoritmos.\n\n<h6>El Arreglo</h6>\nAunque permitamos ambos algoritmos de firmado, se requiere un poco más de lógica para asegurar que no hay confusión, como se muestra en el ejemplo de abajo.\n\n```python\nheader = jwt.get_unverified_header(token)\n\nalgorithm = header['alg']\npayload = \"\"\n\nif \"RS\" in algorithm:\n    payload = jwt.decode(token, self.public_key, algorithms=[\"RS256\", \"RS384\", \"RS512\"])\nelif \"HS\" in algorithm:\n    payload = jwt.decode(token, self.secret, algorithms=[\"HS256\", \"HS384\", \"HS512\"])\n\nusername = payload['username']\nflag = self.db_lookup(username, \"flag\")\n```",
    "modified": "2025-12-21T00:57:18"
  },
  {
    "title": "2. JSON Web Tokens",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/1-authentication/3-jwt-security/2-json-web-tokens/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/1. Authentication/3. JWT Security/2. JSON Web Tokens.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 1. Authentication > 3. JWT Security",
    "content": "JWTs son tokens autocontenidos que pueden ser usados para transmitir información de sesión de forma segura. Es un estándar abierto, ofreciendo información para cualquier desarrollador o creador de librerías que quiera usarlos.\n\n------------------------------\n<h2>Estructura JWT</h2>\nUn JWT consta de 3 componentes cada uno encodeado en base64 y separado por puntos.\n\n- **Header:** El header normalmente indica el tipo de token, que es JWT, y el algoritmo usado para la firma.\n- **Payload:** El payload es el cuerpo del token que contiene las afirmaciones. Estas son piezas de información ofrecidas para una entidad específica. En JWTs, hay afirmaciones registradas, las cuales son predefinidas por el estándar JWT, y públicas o privadas, las cuales son definidas por el desarrollador.\n- **Signature:** La firma es la parte del token que ofrece un método para verificar la autenticidad de dicho token. La firma se crea usando un algoritmo especificado en el header.\n\n------------------------------------------\n<h2>Algoritmos de Firmado</h2>\nAunque hay varios algoritmos diferentes definidos en el estándar JWT, sólo nos importan 3:\n\n- **None:** El algoritmo None significa que no se utiliza ningún algoritmo para la firma. De manera efectiva, es un JWT sin firma, significando que la verificación de las afirmaciones no puede ser hecha a través de la firma.\n- **Symmetric Signing:** Un algoritmo de firmado simétrico, como HS256, crea la firma añadiendo un valor secreto al header y body del JWT antes de generar un valor hash. La verificación del token puede ser realizada por cualquier sistema conocedor de dicho secreto.\n- **Asymmetric Signing:** Un algoritmo de firmado asimétrico, como RS256, crea la firma usando una clave privada para firmar el header y cuerpo del JWT. Se crea generando el hash y luego encriptando el hash usando la clave privada. La verificación la puede realizar cualquier sistema conocedor de la clave pública asociada a la clave privada utilizada para crear la firma.\n\n-----------------------------------\n<h2>Seguridad en la Firma</h2>\nLos JWT pueden ser encriptados (llamados JWEs), pero la fuerza principal de los JWTs viene de la firma. Una vez que se firma el JWT,  puede mandarse al cliente, quien puede usarlo cuando lo necesite. Podemos tener un servidor de autentificación centralizado que cree los JWTs usados en varias aplicaciones. Cada aplicación puede verificas la firma.",
    "modified": "2025-12-21T00:57:18"
  }
]