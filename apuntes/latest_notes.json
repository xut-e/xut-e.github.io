[
  {
    "title": "9. Bypassing Server-Side Filtering - Magic Numbers",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/9-bypassing-server-side-filtering-magic-numbers/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/9. Bypassing Server-Side Filtering - Magic Numbers.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "Ya hemos visto el filtrado de extensiones del lado del servidor, pero vamos a aprovechar para ver cómo se comprueban los magic numbers del lado del servidor también.\n\nLos magic numbers se utilizan para identificar los archivos de manera más precisa. El magic number de un archivo es una string de dígitos hexadecimales y es siempre la primera parte de un archivo. De esta manera, leyendo los primeros bytes de un archivo y comparándolos con una whitelist o blacklist, podemos verificar si el archivo es o no legítimo para su subida.\n\n>[!IMPORTANT] Esta técnica puede ser efectiva contra servidores basados en PHP pero puede fallar contra otros tipos de servidores web.\n\nVeamos un ejemplo. Como generalmente, tenemos una página de subida.\n\n![[Pasted image 20251217135821.png]]",
    "modified": "2025-12-18T00:49:09"
  },
  {
    "title": "8. Bypassing Server-Side Filtering - File Extensions",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/8-bypassing-server-side-filtering-file-extensions/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/8. Bypassing Server-Side Filtering - File Extensions.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "Los filtros del lado del cliente son fáciles de sobrepasar porque ves el código. Pero ¿qué pasa cuando no puedes verlo? Tenemos que realizar un montón de pruebas para entender qué es lo que está pasando por detrás para poder crear un payload que se ajuste a las restricciones.\n\nPara la primera parte de esta tarea miraremos un sitio web que está usando una blacklist para las extensiones como filtro del lado del servidor. Hay una variedad de formas diferentes en las que esto podría estar programado, y el bypass a utilizar depende de ello. En el mundo real no seríamos capaces de ver el código, pero para este ejemplo usaremos:\n\n```php\n<?php       \n//Get the extension       \n$extension = pathinfo($_FILES[\"fileToUpload\"][\"name\"])[\"extension\"];       \n//Check the extension against the blacklist -- .php and .phtml       \nswitch($extension){           \n\tcase \"php\":           \n\tcase \"phtml\":           \n\tcase NULL:               \n\t\t$uploadFail = True;               \n\t\tbreak;           \n\tdefault:               \n\t\t$uploadFail = False;       \n}   \n?>\n```\n\nEn esta instancia, el código busca el último punto en el nombre del archivo y lo usa para confirmar la extensión, por lo que eso es lo que trataremos de bypassear. Otras formas en las que el código podría funcionar serían: buscar el primer punto en el nombre de archivo o partir el nombre por cada punto y ver si hay extensiones no permitidas.\n\nPodemos ver que el código está filtrando `.php` y `.phtml`, por lo que si queremos subir un script PHP, vamos a tener que encontrar otra extensión. La [página de Wikipedia](https://en.wikipedia.org/wiki/PHP) para PHP nos da unas cuantas extensiones comunes que podemos probar. Sin embargo hay algunas más raras que los servidores pueden reconocer todavía. Estas incluyen `.php3`, `.php4`, `.php5`, `.php7`, `.phps`, `.php-s`, `.pht` y `.phar`. Todos estos bypassean el filtro. Pero parece que el servidor no está configurado para reconocerlos como archivos `php`.\n\n![[Pasted image 20251216211116.png]]\n\nEste es el por defecto para los servidores de Apache2. Sin embargo, el sysadmin debe haber cambiado la configuración por defecto, por lo que merece la pena probar.\n\nEventualmente, encontramos que la extensión `.phar` bypassea el filtro y funciona, dándonos una shell.\n\n![[Pasted image 20251216211454.png]]\n\n--------------------------------\nVeamos otro ejemplo, con un filtro diferente. Esta vez, lo haremos completamente black-box.\n\nUna vez más, tenemos nuestro formulario de subida.\n\n![[Pasted image 20251216211556.png]]\n\nEmpezaremos investigando el alcance con un archivo de subida legítimo. Subiremos `spaniel.jpg`, la imagen de antes.\n\n![[Pasted image 20251216211635.png]]\n\nBien, esto nos dice que los archivos JPEG son aceptados. Vamos a probar una que casi al 100% de seguridad será rechazada (`shell.php`).\n\n![[Pasted image 20251216212211.png]]\n\nEfectivamente.\n\nDesde aquí ya enumeramos, probando técnicas de arriba y tratando, generalmente, de obtener una idea de qué acepta o rechaza el filtro.\n\nEn este caso, hemos encontrado que no hay extensiones shell que se ejecuten y no estén filtradas, por lo que de vuelta a la pizarra.\n\nEn el ejemplo anterior, vimos que el código usaba `pathinfo()` para obtener los últimos caracteres después del punto, pero ¿qué pasa si filtra el input ligeramente diferente?\n\nTrataremos de subir un archivo llamado `shell.jpg.php`. Sabemos que los archivos JPEG son aceptados, por lo que ¿y si el filtro sólo comprueba que la extensión `.jpg` exista?\n\nEl pseudo código de este tipo de filtro podría verse algo como así:\n\n```pseudocode\nACCEPT FILE FROM THE USER \n-- \nSAVE FILENAME IN VARIABLE userInput   \nIF STRING \".jpg\" IS IN VARIABLE userInput:       \n\tSAVE THE FILE   \nELSE:       \n\tRETURN ERROR MESSAGE\n```\n\nCuando probamos a subirlo recibimos un mensaje de éxito. Navegar hasta el directorio `/uploads` confirma que el payload se subió exitosamente.\n\n![[Pasted image 20251216213219.png]]\n\nAl activarlo, recibiremos nuestra shell.\n\n![[Pasted image 20251216213236.png]]\n\n---------------------------------------\nEsto no es una lista exhaustiva de vulnerabilidades de subida de archivos relativo a las extensiones. Como en todo en el hacking, buscamos explotar debilidades del código escrito por otros. Este puede ser extremadamente único para la tarea a realizar. Hay un millón de formas diferentes de implementar la misma funcionalidad cuando se trata de programar.\n\n-------------------------------------------------\nAhora es tu turno, averigua y bypassea el filtro para subir y activar una shell. La flag está en `/var/www/`. Ve al sitio `annex.uploadvulns.thm` y comienza.\n\n>[!IMPORTANT] Por primera vez, se ha implementado un esquema de nombramiento aleatorio, por lo que a partir de ahora puede que no todos los directorios sean indexables.\n\n1. Vamos a la página dada.\n   ![[Pasted image 20251216224705.png]]\n2. Hacemos un escaneo con `gobuster`.\n   ![[Pasted image 20251216231603.png]]\n3. Volviendo a la página, parece curiosa, vamos a ver cómo es la sintaxis:\n   ![[Pasted image 20251216224830.png]]\n4. Primero vamos a seleccionar una imagen legítima.\n   ![[Pasted image 20251216225024.png]]\n5. Lo subimos y obtenemos succesfully.\n   ![[Pasted image 20251216225109.png]]\n6. Vamos a probar con uno que no nos dejará (lo más probable).\n   ![[Pasted image 20251216225327.png]]\n7. Lo subimos y obviamente es inválido.\n   ![[Pasted image 20251216225348.png]]\n8. Vamos a seguir mapeando.\n\t1. Con `.jpg`.\n\t   ![[Pasted image 20251216225613.png]]\n\t2. Parece que ha funcionado.\n\t   ![[Pasted image 20251216225648.png]]\n9. Vamos a ver de qué se trataba ese directorio `/privacy`.\n   ![[Pasted image 20251216231759.png]]\n   Es donde se guardan los archivos subidos.\n10. Nos ponemos en escucha en el puerto que hayamos especificado.\n    ![[Pasted image 20251216231940.png]]\n11. Le damos a la \"imagen\".\n    ![[Pasted image 20251216232031.png]]\n    Vaya, parece que ha fallado.\n12. Vamos a probar con una webshell.\n    ![[Pasted image 20251216232510.png]]\n13. Voy a probar a meterle el null byte, por si cuela.\n    ![[Pasted image 20251216232636.png]]\n14. A ver si hay suerte.\n    ![[Pasted image 20251216232707.png]]\n    ![[Pasted image 20251216232746.png]]\n    No     :(\n15. Después de probar un poco vemos que `.php5` sirve como tipo de archivo.\n    ![[Pasted image 20251216233046.png]]\n    ![[Pasted image 20251216233628.png]]\n16. Ahora vamos a la página, le damos al link y metemos el parámetro `?cmd=pwd`.\n    ![[Pasted image 20251216233927.png]]\n17. Vamos a listar `/var/www/`.\n    ![[Pasted image 20251216234023.png]]\n18. Leemos la flag.\n    ![[Pasted image 20251216234100.png]]",
    "modified": "2025-12-17T00:48:47"
  },
  {
    "title": "12. Conclusion",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/12-conclusion/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/12. Conclusion.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "",
    "modified": "2025-12-17T00:48:47"
  },
  {
    "title": "0. Upload Vulnerabilities",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/0-upload-vulnerabilities/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/0. Upload Vulnerabilities.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "[[1. Getting Started]]\n[[2. Introduction]]\n[[3. General Methodology]]\n[[4. Overwriting Existing Files]]\n[[5. Remote Code Execution]]\n[[6. Filtering]]\n[[7. Bypassing Client-Side Filtering]]\n[[8. Bypassing Server-Side Filtering - File Extensions]]\n[[9. Bypassing Server-Side Filtering - Magic Numbers]]\n[[10. Example Methodology]]\n[[11. Challenge]]\n[[12. Conclusion]]",
    "modified": "2025-12-17T00:48:47"
  },
  {
    "title": "7. Bypassing Client-Side Filtering",
    "path": "/apuntes/thm/1-career/2-penetration-tester/2-web-fundamentals/4-web-hacking-fundamentals/8-upload-vulnerabilities/7-bypassing-client-side-filtering/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/2. Web Fundamentals/4. Web Hacking Fundamentals/8. Upload Vulnerabilities/7. Bypassing Client-Side Filtering.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 2. Web Fundamentals > 4. Web Hacking Fundamentals > 8. Upload Vulnerabilities",
    "content": "Empezaremos con la primera (y más débil) linea de defensa: filtrado del lado del cliente.\n\nComo mencionamos previamente, el filtrado del lado del cliente suele ser extremadamente fácil de bypassear. Como ocurre por completo en la máquina que puedes controlar, al tener acceso al código es fácil de modificar.\n\nHay cuatro maneras fáciles de bypassear los típicos filtros de subida del lado del cliente:\n\n1. Deshabilita JavaScript en tu navegador: Esto funcionará si el sitio web no requiere JavaScript para ofrecer funcionaliddades básicas.\n2. Intercepta y modifica la página entrante: Usando Burp Suite, podemos interceptar la página entrante y quitarle el filtro JavaScript antes de que tenga oportunidad de ejecutarse.\n3. Intercepta y modifica el archivo subido: Este método permite que la página se cargue de forma normal pero intercepta el archivo subido después de haber pasado los filtros pero cuando todavía no ha llegado al servidor.\n4. Manda el archivo directamente al punto de subida: Si puedes mandar el archivo directamente al punto de salida, puedes evitar filtros del navegador. El comando para dicho propósito sería algo así: `curl -X POST -F \"submit:<value>\" -F \"<file-parameter>:@<path-to-file>\" <site>`. Para poder usar este método deberías primero interceptar una petición de subida exitosa para ver parámetros, headers y demás.\n\nCubriremos los métodos 2 y 3 en profundidad debajo.\n\n-------------------------------------------------\nAsumamos que hemos encontrado una página de subida.\n\n![[Pasted image 20251215124519.png]]\n\nComo siempre, miraremos el código fuente. Aquí podemos ver una función JavaScript básica que comprueba el tipo MIME de los archivos subidos:\n\n![[Pasted image 20251215124652.png]]\n\nEn esta instancia podemos ver que el filtro está usando una whitelist para excluir cualquier tipo MIME que no sea `image/jpeg`.\n\nEl próximo paso es intentar una subida de archivo. Si seleccionamos JPEG, la función lo acepta y cualquier otra la rechaza.\n\nHabiendo establecido esto, arrancamos BurpSuite y recargamos la página. Veremos nuestra propia petición al sitio web pero lo que realmente queremos es ver es la respuesta del servidor, así que hacemos click derecho en la información interceptada, bajamos hasta \"Do Intercept\" y seleccionamos \"Response to this Request\".\n\n![[Pasted image 20251215124935.png]]\n\nCuando hacemos click en \"Forward\" arriba de la ventana, veremos la respuesta del servidor a nuestra petición. Aquí, podemos borrar, comentar o romper la función JavaScript antes de que tenga oportunidad de cargar.\n\n![[Pasted image 20251215125235.png]]\n\nHabiendo borrado la función, le damos de nuevo a \"Forward\" hasta que veamos que el sitio web ha terminado de cargarse y ahora ya podemos subir cualquier tipo de archivo a la página.\n\n![[Pasted image 20251215125327.png]]\n\n>[!IMPORTANT] Burp Suite no intercepta (por defecto) archivos JavaScript externos que la página cargue. Si necesitas editar un script que no esté en la página principal, necesitas ir a `Options > Intercept Client Requests` y editar la condición de la primera línea para eliminar `^js$|`:\n\n![[Pasted image 20251215125537.png]]\n\n---------------------------------------------------\nYa hemos bypasseado este filtro interceptando y eliminándolo antes de que cargue la página, pero intentémoslo hacer subiendo un archivo con una extensión y tipo MIME legítimos e interceptándolo y corrigiéndolo con BurpSuite.\n\nHabiendo recargado la página web, para poner el filtro en su lugar, tomemos la reverse shell que hemos usado antes y renombrémosla para que se llame \"shell.jpg\". Como el archivo cumple con la condición del tipo MIME, nuestro filtro del lado del cliente deja pasar nuestro payload sin quejas.\n\n![[Pasted image 20251215130752.png]]\n\nUna vez más, activamos Burp Suite y le damos a \"Upload\" para interceptar la petición.\n\n![[Pasted image 20251215130825.png]]\n\nObserva que el tipo MIME de nuestra shell PHP es `image/jpeg`. Cambiaremos esto a `text/x-php`, y la extensión de `.jpg` a `.php` y le daremos a forward.\n\n![[Pasted image 20251215130939.png]]\n\nAhora, al navegar a `http://demo.uploadvulns.thm/uploads/shell.php` habiendo activado un listener, recibiremos una conexión de la shell.\n\n![[Pasted image 20251215131029.png]]\n\n---------------------------------\nHemos cubierto en detalle dos formas de bypassear un filtro de subida de lado del cliente. Ahora es hora de que lo probemos. Ve a `java.uploadvulns.thm` y bypassea el filtro para conseguir una reverse shell. Recuerda escanear el sitio web con `gobuster`.\n\n1. Vamos al sitio web dado.\n   ![[Pasted image 20251215224146.png]]\n2. Escanearemos mientras tanto la página con `gobuster`.\n   ![[Pasted image 20251215225918.png]]\n3. Vamos a interceptar una subida de archivo con Burp Suite.\n\t1. Abrimos Burp Suite y su navegador y vamos al sitio web que nos dan.\n\t   ![[Pasted image 20251215224459.png]]\n\t2. Seleccionamos un archivo y activamos la intercepción.\n\t   ![[Pasted image 20251215224527.png]]\n\t3. Le damos a \"Upload\" y esperamos la petición.\n\t   ![[Pasted image 20251215224611.png]]\n4. El content type parece ser `image/png`.\n   ![[Pasted image 20251215224721.png]]\n5. Le damos a \"Forward\".\n   ![[Pasted image 20251215224812.png]]\n   Parece que se ha subido exitosamente.\n6. Vamos ahora a subir una `shell.php` y a capturar la respuesta.\n\t1. Editamos la shell.\n\t   ![[Pasted image 20251215225158.png]]\n\t2. Nos ponemos en escucha.\n\t   ![[Pasted image 20251215225244.png]]\n\t3. Subimos la shell y la interceptamos con Burp Suite.\n\t   ![[Pasted image 20251215225330.png]]\n\t   Parece que no nos deja.\n\t4. Le cambiamos la extensión a `.png`.\n\t   ![[Pasted image 20251215225504.png]]\n\t5. Ahora sí.\n\t   ![[Pasted image 20251215225523.png]]\n\t6. Vamos a interceptarlo.\n\t   ![[Pasted image 20251215225558.png]]\n\t7. Cambiamos el filename a `reverseshell.php` y content-type a `text/x-php`.\n\t   ![[Pasted image 20251215225716.png]]\n\t8. Le damos a forward hasta que ponga success.\n\t   ![[Pasted image 20251215225828.png]]\n7. Ahora debemos navegar a la shell, que basándonos en nuestro escaneo con `gobuster` seguramente esté en `/images`.\n   ![[Pasted image 20251215230007.png]]\n   La página parece quedarse cargando.\n8. Pero si volvemos al listener:\n   ![[Pasted image 20251215230034.png]]\n9. Ahora vamos al directorio que nos dan y leemos la flag.\n   ![[Pasted image 20251215230112.png]]",
    "modified": "2025-12-16T00:54:19"
  }
]