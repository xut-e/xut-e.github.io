[
  {
    "title": "6. ORM Injection - Vulnerable Implementation",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/6-orm-injection/6-orm-injection-vulnerable-implementation/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/6. ORM Injection/6. ORM Injection - Vulnerable Implementation.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 6. ORM Injection",
    "content": "Aunque las prácticas de programación seguras son esenciales, también es importante reconocer cómo un desarrollador puede implementar sin querer una versión vulnerable de ORM, creando vías para la explotación. Ocurre cuando los desarrolladores usan librerías ORM mal configuradas o antiguas. Los desarrolladores deben asegurarse de estar usando versiones actualizadas y seguras de dichas librerías.\n\n----------------------------------------\n<h2>Ejemplo Práctico</h2>\nUno de estos ejemplos es el paquete de construcción de queries de Laravel, el cual tuvo una vulnerabilidad de seguridad importante en versiones anteriores a la 1.17.1. Esta vulnerabilidad permitía la inyección SQL mediante parámetros query no sanitizados. La vulnerabilidad fue identificada en cómo manejaba el paquete los parámetros de búsqueda sin validación adecuada. Hemos usado el [Spatie query builder](https://github.com/spatie/laravel-query-builder) para este ejemplo, lo que también usa el Laravel's query builder internamente.\n\nPara demostrar esta vulnerabilidad puedes acceder a `https://IP.reverse-proxy.cell-prod-us-east-1b.vm.tryhackme.com/query_users?sort=name`. Este endpoint permite recuperar los usuarios de arriba ordenados por la columna `name` vía el parámetro `sort`.\n\n![[Pasted image 20260116135729.png]]\n\nEl traducción de query equivalente de Laravel es `SELECT * FROM users ORDER BY name ASC LIMIT 2`.\n\n<h4>Intento de Inyección</h4>\nSi intentamos inyectar el parámetro nombre con `name'`, veremos que la app devuelve un error de que no pudo encontrar el nombre de la columna.\n\n![[Pasted image 20260116142050.png]]\n\nNuestro objetivo aquí es manipular la query para obtener la información completa de la tabla `users` en lugar de ser restringidos a un número de filas.\n\nSin embargo, inyectar el parámetro sort en este contexto no es tan fácil como concatenar el `SELECT` y usar métodos de inyección rutinarios. El reto yace en romper efectivamente la cláusula `ORDER BY` para manipular la ejecución. Para conseguir esto, podemos utilizar una función especial: el operador `->` el cual sirve como alias de la función `json_extract` en MySQL. Este operador nos permite navegar la información JSON y extraer valores específicos. Usando el operador `->` en conjunción con el payload `\"%27))`, podemos romper la cláusula `ORDER BY`. El payload `->\"%27))` termina efectivamente la extracción JSON, bypasseando las limitaciones impuestas por la query inicial y permitiéndonos añadir comandos SQL adicionales.\n\n<h4>Payload Final</h4>\nPrepararemos el payload final de la siguiente manera:\n\n- **Query Inicial:** La query inicial que Laravel traduce para mostrar a los usuarios pertinentes es `SELECT * FROM users ORDER BY name ASC LIMIT 2`.\n- **Rompiendo la Query:** Inyectando `name->\"%27))`, podemos causar la ruptura de la query para crear una oportunidad de inyectar nuestro propio SQL.\n- **Construyendo el Payload:** Para explotar esta vulnerabilidad, construimos el payload para que rompa la string e inyecte el SQL. El payload debería ser algo como `name->\"%27)) SQL INJECTION QUERY #`. En el valor de parámetro `name->`, el operador `->` es parseado por Laravel y reemplazado con la función MySQL JSON. Por otro lado, `\"%27))` cierra la string y condición anteriores. `SQL INJECTION QUERY` permite al atacante escribir su propia query. El carácter `#` comenta el resto de la linea.\n- **Resultado Final:** El payload para obtener las filas adicionales de la base de datos sería `SELECT * FROM 'users' ORDER BY json_unquote(json_extract('name', '$.\"\"')) LIMIT 10#\"')) ASC LIMIT 2`, incluyendo el payload inyectado.\n\n![[Pasted image 20260116143658.png]]",
    "modified": "2026-01-17T00:53:14"
  },
  {
    "title": "7. Best Practices",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/6-orm-injection/7-best-practices/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/6. ORM Injection/7. Best Practices.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 6. ORM Injection",
    "content": "Ahora que entendemos la superficie de ataque de la inyección ORM, prevenir estas vulnerabilidades requiere implementar medidas de seguridad robustas y monitorizar continuamente debilidades potenciales.\n\n--------------------------------------\n<h2>Algunas Prácticas Importantes</h2>\n- **Validación de Input:** Valida siempre el input del usuario del lado del cliente y del lado del servidor. Asegúrate de que la información introducida cumple con formato, tipo y longitud.\n- **Queries Parametrizadas:** Usa queries parametrizadas (prepared statements) para interactuar con la base de datos.\n- **Uso de ORM:** Utiliza las herramientas integradas del ORM para interactuar con la base de datos. \n- **Escapado y Sanitización:** Escapa y sanitiza siempre el input del usuario para eliminar caracteres especiales e información maliciosa.\n- **Lista de Inputs Permitidos:** Implementa un alista para la validación de inputs. Permite sólo específicos (whitelist).\n\n------------------------------------------\n<h2>Aplicación en Frameworks Populares</h2>\nExploraremos prácticas esenciales para salvaguardarnos de la inyección ORM en frameworks ORM populares. Herramientas ORM como Doctrine (PHP), SQLAlchemy (Python), Hibernate (Java) y Entity Framework (.NET) ofrecen abstracciones poderosas para interactuar con bases de datos. Sin embargo, para prevenir vulnerabilidades de inyección SQL, es crucial emplear prácticas de programación segura.\n\n<h4>Doctrine (PHP)</h4>\nUsa statements preparados con queries parametrizadas para prevenir los ataques de inyección SQL.\n\n```php\n$query = $entityManager->createQuery('SELECT u FROM User u WHERE u.username = :username');\n$query->setParameter('username', $username);\n$users = $query->getResult();\n```\n\n<h4>SQLAlchemy (Python)</h4>\nUsa el ORM de SQLAlchemy y Query API para usar queries parametrizadas, que escapan automáticamente.\n\n```python\nfrom sqlalchemy.orm import sessionmaker\nSession = sessionmaker(bind=engine)\nsession = Session()\nuser = session.query(User).filter_by(username=username).first()\n```\n\n<h4>Hibernate</h4>\nUsa parámetros nombrados con la Query API de Hibernate para asegurar que los inputs sean correctamente escapados.\n\n```java\nString hql = \"FROM User WHERE username = :username\";\nQuery query = session.createQuery(hql);\nquery.setParameter(\"username\", username);\nList results = query.list();\n```\n\n<h4>Entity Framework (.NET)</h4>\nEmplea queries parametrizadas en el Entity Framework para securizar las interacciones de la base de datos y mitiga el riesgo de vulnerabilidades de inyección SQL.\n\n```C#\nvar user = context.Users.FirstOrDefault(u => u.Username == username);\n```",
    "modified": "2026-01-17T00:53:14"
  },
  {
    "title": "4. Identifying ORM Injection",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/6-orm-injection/4-identifying-orm-injection/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/6. ORM Injection/4. Identifying ORM Injection.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 6. ORM Injection",
    "content": "Identificar vulnerabilidades ORM involucra examinar cómo el input del usuario se maneja en las queries. Estas vulnerabilidades surgen cuando el input del usuario se incrusta directamente en los métodos query ORM sin sanitizar o validar.\n\n--------------------------------------\n<h2>Técnicas de Comprobación de Inyección ORM</h2>\n- **Revisión de Código Manual:** Una inspección a conciencia del código fuente puede revelar métodos de query raw como `whereRaw()` que incorporan el input directamente. Busca strings concatenadas o inputs no escapados.\n- **Escaneo Automatizado:** Usa herramientas de escaneo de seguridad diseñadas para detectar vulnerabilidades ORMi.\n- **Comprobación de Validación de Input:** Realiza comprobaciones manuales inyectando payloads en los inputs de la aplicación.\n- **Comprobación Basada en Errores:** Introduce información incorrecta o malformada adrede para disparar errores, que pueden revelar detalles de la estructura subyacente.\n\n<h4>Frameworks y Comprobación de Inyección ORM</h4>\n\n| **Framework  <br>** | **Librería ORM** | **Métodos Comúnmente Vulnerables**   |\n| ------------------- | ---------------- | ------------------------------------ |\n| Laravel             | Eloquent ORM     | `whereRaw(), DB::raw()`              |\n| Ruby on Rails       | Active Record    | `where(\"name = '#{input}'\")`         |\n| Django              | Django ORM       | `extra()`, `raw()`                   |\n| Spring              | Hibernate        | `createQuery()` with `concatenation` |\n| Node.js             | Sequelize        | `sequelize.query()`                  |\n\nLa tabla de arriba subraya varios frameworks de desarrollo web y su librería ORM asociada, detallando métodos comunes que son tendentes a vulnerabilidades. Por ejemplo, en Laravel, usando `whereRaw()` o `DB::raw()` con el input del usuario puede llevar a inyección ORM, pero puede prevenirse usando queries parametrizadas con el método `where()`. En Django, de forma similar, métodos como `extra()` y `raw()` pueden introducir vulnerabilidades si no se manejan correctamente.\n\n---------------------------------------------\n<h2>Explorando la Aplicación Objetivo</h2>\nAhora que sabemos cómo identificar vulnerabilidades de inyección ORM, visitemos el sitio `https://IP.reverse-proxy.cell-prod-us-east-1b.vm.tryhackme.com/`. Aquí veremos que el sitio web te pide un input. Para determinar qué framework se usa, podemos emplear varias técnicas como inspeccionar cookies, ver el código fuente o analizar headers HTTP.\n<h4>Técnicas para Identificar el Framework</h4>\n- **Verificar Cookies:** Examina las cookies configuradas por la aplicación. Los frameworks suelen usar convenciones de nombramiento únicas.\n  ![[Pasted image 20260116114511.png]]\n- **Revisar Código Fuente:** Mira en el código fuente HTML en busca de comentarios, etiquetas meta o cualquier script incrustado que pueda revelar firmas específicas de framework.\n  ![[Pasted image 20260116114608.png]]\n- **Analizar headers HTTP:** Los headers HTTP pueden contener a veces información sobre el servidor y el framework.\n- **Estructura URL:** La estructura de las URLs puede dar pistas sobre el framework.\n- **Páginas de Login y Error:** Las páginas de error y autentificación pueden revelar a veces el framework.\n\nAhora que hemos identificado que la aplicación usa Laravel inspeccionando cookies y código fuente, podemos ir más allá poniendo input malicioso para explorar su comportamiento. Específicamente, introduciremos `1'` para ver cómo maneja ese input. Lo introducimos en el campo email (vulnerable) y la mandamos.\n\n![[Pasted image 20260116120810.png]]\n\nDespués de subirla tenemos que observar de cerca el comportamiento de la aplicación. Si la aplicación devuelve un mensaje de error como `SQLSTATE[42000]: Syntax error or access violation` indica que el input ha sido manejado incorrectamente porque lo ha concatenado, resultando en error de sintaxis. El output muestra que usa Laravel's Eloquent ORM ya que los mensajes de error y patrones query son característicos de ello.",
    "modified": "2026-01-17T00:53:14"
  },
  {
    "title": "5. ORM Injection - Weak Implementation",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/6-orm-injection/5-orm-injection-weak-implementation/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/6. ORM Injection/5. ORM Injection - Weak Implementation.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 6. ORM Injection",
    "content": "En esta tarea exploraremos cómo un atacante puede explotar vulnerabilidades ORM cuando este está implementado débilmente. Primero visitamos el sitio web.\n\n![[Pasted image 20260116122434.png]]\n\nTomemos un momento para ver el código fuente usado por el desarrollador para el campo **Email (Vulnerable)**:\n\n```php\npublic function searchBlindVulnerable(Request $request)\n{\n    $users = [];\n    $email = $request->input('email');\n    $users = Admins::whereRaw(\"email = '$email'\")->get();\n    if ($users) {\n        return view('user', ['users' => $users]);\n    } else {\n        return view('user', ['message' => 'User not found']);\n    }\n}\n```\n\n----------------------------------------------\n<h2>Lo que Hace esta Función</h2>\nLa función `search BlindVulnerable()` está diseñada para recuperar registros de usuarios basad en el parámetro email dado por el usuario. Aquí está un desglose detallado de la función:\n\n- **Recuperar Input:** La función captura el parámetro `email` de la petición HTTP. Esto se hace con el método input del objeto `$request`.\n- **Construir Query:** La función construye la query SQL usando el método de Laravel `whereRaw()` el cual directamente incorpora el valor email en la query SQL.\n- **Ejecutar Query:** Se ejecuta la query y se guarda el valor en la variable `$users`.\n- **Devolver Vista:** Finalmente, la función devuelve una vista. Si el array `$users` no está vacío, pasa la información del usuario a la vista, en otro caso pasa \"**User not Found**\".\n\nEl problema principal en esta función yace en el uso directo de `whereRaw()` con el input del usuario. Este método de construcción de queries es vulnerable a la inyección porque no sanitiza el input.\n\nUn atacante puede explotar esta vulnerabilidad manipulando el parámetro email. Si un atacante introduce `1' OR '1'='1`, la query resultante se vuelve:\n\n```sql\nSELECT * FROM users WHERE email = '1' OR '1'='1';\n```\n\nEsta query siempre devuelve todos los registros de usuarios porque la condición `'1'='1'` siempre es true.\n\n----------------------------------------------------\n<h2>Explotación Detallada</h2>\n- **Introducir Valor Malicioso:** El atacante introduce un payload en el campo vulnerable, por ejemplo `1' OR '1'='1'`.\n- **Construir la Query:** La función `searchBlindVulnerable()` recupera este input y construye la siguiente query:\n\n```php\n$users = User::whereRaw(\"email = '1' OR '1'='1'\")->get();\n```\n\n- **Ejecutar la Query:** Eloquent ORM de Laravel transforma esto en un statement SQL: `SELECT * FROM users WHERE email = '1' OR '1'='1';`.\n- **Resultado:** Como `'1'='1'` siempre es true, la query devuelve todos los registros en la tabla users.\n  ![[Pasted image 20260116125611.png]]\n\n-------------------------------------------------\n<h2>Implementar Queries ORM Seguras</h2>\nEchemos un vistazo a la versión segura de la función para demostrar cómo la implementación segura puede proteger contra las vulnerabilidades de inyección ORM. Usando queries parametrizadas podemos asegurarnos de que el input del usuario esté debidamente sanitizado, reduciendo significativamente el riesgo de ataques de inyección. Aquí una implementación segura de la función vía **Email (Secure)**:\n\n```php\npublic function searchBlindSecure(Request $request)\n{\n    $email = $request->input('email');\n    $users = User::where('email', $email)->get();\n    if (isset($users) && count($users) > 0) {\n        return view('user', ['users' => $users]);\n    } else {\n        return view('user', ['message' => 'User not found']);\n    }\n}\n```\n\n---------------------------------------\n<h2>Desglose de Implementación Segura</h2>\n- **Recuperar el Input:** La función captura el parámetro email de la petición HTTP usando el método input del objeto `$request`.\n- **Construir la Query de Forma Segura:** En lugar de usar `whereRaw()`, usamos la versión segura, `where()`. Este método automáticamente escapa el input previniendo la SQLi.\n- **Ejecutar la Query:** Se ejecuta la query y se guarda el resultado en la variable `$users`. Debido a que la query está parametrizada, el input está sanitizado por lo que no puede romper la estructura SQL.\n- **Devolver la Vista:** Finalmente la función devuelve una vista. Si el array `$users` contiene información, pasa al usuario la información a ver. Si no, muestra un mensaje de error.\n\nSi ahora intentamos usar la misma query en el input seguro, obtendremos lo siguiente:\n\n![[Pasted image 20260116131829.png]]\n\n-----------------------------------------\n<h2>Por qué es Esto Seguro</h2>\n- **Queries Parametrizadas:** Las queries parametrizadas se aseguran de que los valores del input sean tratados sólo como datos, no código ejecutable.\n- **Escape Automático:** Eloquent escapa automáticamente los valores introducidos.\n- **Lógica de Query Consistente:** Usando métodos de Eloquent como `where()` la lógica de la query se mantiene clara y consistente.",
    "modified": "2026-01-17T00:53:14"
  },
  {
    "title": "3. How ORM Works",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/6-orm-injection/3-how-orm-works/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/6. ORM Injection/3. How ORM Works.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 6. ORM Injection",
    "content": "<h2>Mapear Entre Objetos en el Código y Tablas de Bases de Datos</h2>\nORM es una técnica que simplifica la interacción de información en una aplicación mapeando objetos en el código a tablas de bases de datos. En PHP, este proceso involucra definir clases que representen tablas de bases de datos y sus relaciones, Cada clase corresponde a una columna en la tabla, y cada instancia de clase representa una fila.\n\nPor ejemplo, usando Laravel's Eloquent ORM, puedes definir una clase modelo así:\n\n```php\nnamespace App\\Models;\nuse Illuminate\\Database\\Eloquent\\Model;\nclass User extends Model\n{\n    protected $table = 'users';\n    protected $fillable = [\n        'name', 'email', 'password',\n    ];\n    // Other Eloquent model configurations can go here...\n}\n```\n\nEn este ejemplo, la clase `User` se mapea a la tabla `user` en la base de datos, con propiedades correspondiendo a las columnas. Eloquent ORM maneja la traducción entre estas representaciones de objetos y las queries SQL subyacentes, permitiendo a los desarrolladores manipular registros de bases de datos usando sintaxis orientada a objetos.\n\n----------------------------------------\n<h2>Operaciones ORM Comunes (Create, Read, Update, Delete)</h2>\nLas operaciones comunes de bases de datos en frameworks ORM, comúnmente conocidas como CRUD:\n\n- **Create:** Crear nuevos registros en la base de datos involucra instanciar un nuevo objeto modelo, configurando sus propiedades y guardándolo en la base da datos.\n  \n```php\nuse App\\Models\\User;\n\n// Create a new user\n$user = new User();\n$user->name = 'Admin';\n$user->email = 'admin@example.com';\n$user->password = bcrypt('password'); \n$user->save();\n```\n  \n  Este código crea un nuevo usuario y lo guarda en la base de datos. El método de guardado prepara la entidad para su inserción y ejecuta el statement SQL INSERT para añadir un nuevo registro en la tabla users. La función `bcrypt()` es usada para hashear de forma segura la contraseña antes de guardarla.\n- **Read:** Leer los registros de la base de datos involucra recuperar información usando varios métodos de Eloquent.\n  \n```php\nuse App\\Models\\User;\n\n// Find a user by ID\n$user = User::find(1);\n\n// Find all users\n$allUsers = User::all();\n\n// Find users by specific criteria\n$admins = User::where('email', 'admin@example.com')->get();\n```\n  \n  Este código demuestra formas diferentes de recuperar registros de la base de datos. La función `find(1)` recupera el usuario con ID 1 ejecutando el statement SQL SELECT. La función `all()` recupera todos los usuarios ejecutando `SELECT * FROM users`. La cláusula `where('email', 'admin@example.com')->get()` recupera los usuarios con el email especificado ejecutando `SELECT * FROM users WHERE emai = 'admin@example.com'`.\n\nDe forma similar a las operaciones create y read, las funcionalidades delete y update siguen un enfoque similar. Para actualizaciones recuperas el registro existente, lo modificas y guardas los cambios. Para borrados recuperas el registro y llamas al método delete para eliminarlo de la base de datos. \n\n------------------------------------------------\n<h2>Comparando la Inyección SQL y ORM</h2>\nLa inyección SQL y ORM son ambas técnicas usada para explotar vulnerabilidades en las interacciones de las bases de datos, pero tienen como objetivos diferentes niveles del stack:\n\n- **SQL Injection:** Apunta a queries SQL, permitiendo a los atacantes manipular statements SQL directamente. Esto se consigue inyectando input malicioso en la string query. La parte de inyección en la siguiente query, `OR '1'='1`, siempre evalúa en true.\n\n```php\nSELECT * FROM users WHERE username = 'admin' OR '1'='1';\n```\n\n- **ORM Injection:** Apunta al framework ORM explotando cómo se construyen las queries desde las operaciones de objetos. Los atacantes manipulan los métodos ORM y propiedades para influenciar las queries SQL resultantes.\n  \n ```php\n $userRepository->findBy(['username' => \"admin' OR '1'='1\"]);\n ```\n  \n  En el código de arriba, la parte de la inyección, `admin' OR '1'='1`, siempre se evalúa en true.\n\n------------------------------------------\n<h2>Diferencias Clave en Técnicas de Explotación</h2>\n\n| **Aspecto**        | **SQL Injection  <br>**                                                   | **ORM Injection**                                                                                                              |\n| ------------------ | ------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |\n| Nivel de Inyección | Apunta a queries SQL raw directamente                                     | Apunta a la construcción de queries del framework ORM                                                                          |\n| Complejidad        | Más directo ya que manipula SQL                                           | Requiere entendimiento de cómo funcionan los métodos internos de ORM                                                           |\n| Detección          | Más fácil de detectar con WAFs tradicionales y registros query            | Más difícil detectar ya que los payloads están en métodos ORM                                                                  |\n| Mitigación         | Uso de statements preparados, queries parametrizadas, validación de input | Configuración ORM correcta, validación de input a nivel de aplicación, funcionalidades ORM reforzando la seguridad de la query |\n\n----------------------------------------------\n<h2>Configurando el Entorno</h2>\nYa que estamos usando Laravel para este proyecto, explicaremos brevemente cómo configurar Eloquent ORM (Laravel-Based). Eloquent ORM es el ORM por defecto de Laravel, que ofrece una implementación de `Active Record` simple y bonita para trabajar con tu base de datos. Primero, debemos instalar Laravel usando Composer. Abre tu terminal y ejecuta el comando `composer create-project --prefer-dist laravel/laravel thm-project`, donde `thm-project` es el nombre del proyecto. No necesitas hacer estos pasos, es sólo para ayudarte a entender cómo funciona.\n\n<h4>Configurar las Credenciales de la Base de Datos</h4>\nDespués necesitamos configurar nuestras credenciales. Laravel usa el archivo `.env` para almacenar las variables de entorno, incluyendo credenciales. Abre el archivo `.env` en la raíz de tu proyecto Laravel y actualiza las siguientes líneas con los detalles de tu base de datos.\n\n```php\nDB_CONNECTION=mysql\nDB_HOST=127.0.0.1\nDB_PORT=3306\nDB_DATABASE=your_database_name\nDB_USERNAME=your_database_user\nDB_PASSWORD=your_database_password\n```\n\n<h4>Configurar Migraciones</h4>\nLas migraciones son el control de versiones de tu base de datos, permitiéndote modificar y compartir fácilmente el esquema de la base de datos. El sistema de migración de Laravel es una parte esencial del framework y simplifica el manejo de los cambios en la base de datos.\n\n<h4>Crear una Migración</h4>\nPara crear una migración, podemos usar el comando `Artisan` que viene con Laravel. Puedes ejecutar el comando `php artisan make:migration create_users_table --create=users` para generar una migración para la tabla `users`.\n\nEste comando genera un archivo de migración en el directorio de base de datos/migración. El archivo de migración contiene métodos para definir la estructura de la tabla `users`.\n\n```php\n<?php\nuse Illuminate\\Database\\Migrations\\Migration;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Support\\Facades\\Schema;\nclass CreateUsersTable extends Migration\n{\n    public function up()\n    {\n        Schema::create('users', function (Blueprint $table) {\n            $table->id();\n            $table->string('name');\n            $table->string('email')->unique();\n            $table->string('password');\n            $table->timestamps();\n        });\n    }\n    public function down()\n    {\n        Schema::dropIfExists('users');\n    }\n}\n```\n\nEn el código de arriba, el método `up()` define la estructura de la tabla `users`. Por el contrario, `down()` dropea la tabla `users` si se revierte la migración.\n\nDespués de definir la migración, ejecuta el comando `php artisan migrate` para aplicar la migración y crear la tabla `users` en la base de datos. Este comando ejecutará `up()` en el archivo de migración y creará la tabla `users` con las columnas especificadas en la base de datos.\n\nEn el contexto de ORM, las migraciones simplifican el proceso de mapear las tablas de la base de datos para modelos de aplicación. Sin embargo, desde el punto de vista de un red teamer, migraciones mal configuradas pueden llevar a vulnerabilidades como ORM injection.",
    "modified": "2026-01-16T00:55:48"
  }
]