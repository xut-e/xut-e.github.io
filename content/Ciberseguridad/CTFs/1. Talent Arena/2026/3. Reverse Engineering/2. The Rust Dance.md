1. Empezamos comprobando el tipo de archivo que tenemos en frente.
   ![[Pasted image 20260210201613.png]]
2. Ahora vamos a ejecutar el código una vez para ver su comportamiento.
   ![[Pasted image 20260210201659.png]]
   Parece que debemos de introducir el código correcto para que el programa nos devuelva la flag.
3. Vamos a hacer una serie de comprobaciones para ver qué strings hay dentro del código.
	1. Empezamos investigando las strings con `strings ./rust-dance`.
	   ![[Pasted image 20260210202014.png]]
	   Pero hay demasiadas.
	   ![[Pasted image 20260210202041.png]]
	2. Así que seremos un poco más selectivos.
	   ![[Pasted image 20260210202235.png]]
	   Aquí vemos algunas coincidencias, pero (aunque hay más) no vemos nada muy interesante.
	3. Vamos a observar trazas dinámicas, para ello usamos `strace` y filtramos después.
	   ![[Pasted image 20260210202548.png]]
	   ![[Pasted image 20260210202734.png]]
	   Como `strace` no revela comparaciones en `libc`, el siguiente paso es usar `ltrace` para ver si `memcmp/strcmp/bcmp` existen. Sin embargo, nos ayuda a conocer el punto en el que introducir un `breakpoint` más adelante.
	4. Usamos `ltrace`.
	   ![[Pasted image 20260210203610.png]]
	   Parece que no hay ninguna llamada típica por lo que parece que NO hay una comprobación directa entre dos strings. Lo más probable es que la validación la haga en el código propio sin acceder a más valores de memoria.
4. Vamos a descompilar el binario con `ghidra`.
	1. Abrimos el archivo en `ghidra` y lo analizamos.
	   ![[Pasted image 20260211191947.png]]
	2. Buscamos la string de `Unlock code`.
	   ![[Pasted image 20260211192435.png]]
	   ![[Pasted image 20260211192449.png]]
	   Esto nos lleva a la función que lo imprime.
	3. Si hacemos doble click sobre la referencia de función que lo imprime:
	   ![[Pasted image 20260211192604.png]]
	   Nos lleva aquí:
	   ![[Pasted image 20260211192646.png]]
	   Donde hay otras dos referencias:
	   ![[Pasted image 20260211192720.png]]
	   Hacemos doble click en la primera
	4. Se nos cargará la función en el Decompile (a la derecha) y después de buscar un rato encontramos el bucle que realiza operaciones contra nuestro string. Primero se valida si el input tiene 19 (`0x13`) caracteres exactamente. Si es así comienza las transformaciones.
	   ![[Pasted image 20260211202813.png]]
	   ![[Pasted image 20260211202838.png]]
5. Son más de 700 lineas de operaciones, vueltas y comprobaciones, es demasiado para un humano con poco tiempo, por lo que se lo pasaremos a nuestro mejor amigo: `ChatGPT`.
6. Le pasamos todo el contenido de `.rodata` a ChatGPT.
   ![[Pasted image 20260211204023.png]]
7. Con el contenido de `.rodata` y el bucle de comprobación, la IA nos devuelve un código que al ejecutar puede obtener el "Unlock code".

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# -------------------------
# Helpers (rotaciones)
# -------------------------
def rol8(x, r):
    r &= 7
    return ((x << r) | (x >> (8 - r))) & 0xFF

def ror8(x, r):
    r &= 7
    return ((x >> r) | (x << (8 - r))) & 0xFF

def rol4(x):
    # swap nibbles (su propio inverso)
    return ((x << 4) | (x >> 4)) & 0xFF

# -------------------------
# Constantes (sacadas de .rodata, según tu dump)
# -------------------------
KEY_00103CF0 = [
    0x87, 0x9e, 0xb5, 0xcc, 0xe3, 0xfa, 0x11, 0x28,
    0x3f, 0x56, 0x6d, 0x84, 0x9b, 0xb2, 0xc9, 0xe0
]

ADD_00103D10 = [
    0x33, 0xCC, 0x35, 0xCA, 0x37, 0xC8, 0x39, 0xC6,
    0x3B, 0xC4, 0x3D, 0xC2, 0x3F, 0xC0, 0x41, 0xBE
]

# DWords objetivo tras el nibble-swap (porque el OR da 0 => cada XOR debe ser 0)
# buf[0:4]  == 0x4694ac0e
# buf[4:8]  == 0x72be6fc6
# buf[8:12] == 0xee795db7
# buf[12:16]== 0xa2edd0e2
TARGET16_AFTER_NIBBLE = [
    0x0e, 0xac, 0x94, 0x46,
    0xc6, 0x6f, 0xbe, 0x72,
    0xb7, 0x5d, 0x79, 0xee,
    0xe2, 0xd0, 0xed, 0xa2
]

# Bytes finales tras rol4 (lo que compara el if)
POST16_18_ROL4 = [0xC6, 0x28, 0x8A]

# -------------------------
# Shift exacto del bucle (según el ensamblado)
# -------------------------
def shift_even(i, c):
    # ECX = floor(i/7)
    q7 = i // 7
    # EDX = ((((i - q7) >> 1) + q7) >> 2)
    edx = (((i - q7) >> 1) + q7) >> 2
    # R9D = edx*7
    r9 = edx * 7
    # CL = c - r9  (y luego rotate)
    return (c - r9) & 7

def shift_odd(i, c):
    # en ensamblado: (floor(i/5) * 5) y luego c - eso
    q5 = i // 5
    edx = q5 * 5
    return (c - edx) & 7

def invert_rotation(buf19_after):
    """
    Invierte el bucle que rota 19 bytes (i=0..18, c=1..19).
    """
    b = buf19_after[:]
    for i in range(18, -1, -1):
        c = i + 1
        sh = shift_even(i, c) if (i & 1) == 0 else shift_odd(i, c)
        if (i & 1) == 0:
            # forward: ROL -> inverse: ROR
            b[i] = ror8(b[i], sh)
        else:
            # forward: ROR -> inverse: ROL
            b[i] = rol8(b[i], sh)
    return b

# -------------------------
# Inversión total
# -------------------------
def recover_unlock():
    # (1) Invertir nibble-swap de los 16 primeros bytes
    after_padd = [rol4(x) for x in TARGET16_AFTER_NIBBLE]

    # (2) Invertir PADDB (restar vector ADD_00103D10)
    after_rotate_0_15 = [(b - k) & 0xFF for b, k in zip(after_padd, ADD_00103D10)]

    # (3) Invertir bytes 16..18:
    #     forward: b += [0x43,0xBC,0x45] ; rol4(b)
    #     inverse: ror4(b) ; b -= [0x43,0xBC,0x45]
    pre_add = [rol4(x) for x in POST16_18_ROL4]  # inverse rol4 == rol4
    b16 = (pre_add[0] - 0x43) & 0xFF
    b17 = (pre_add[1] - 0xBC) & 0xFF
    b18 = (pre_add[2] - 0x45) & 0xFF

    buf_after_rotation = after_rotate_0_15 + [b16, b17, b18]

    # (4) Invertir el bucle de rotaciones para obtener el buffer justo después del shuffle inicial
    buf_pre_loop = invert_rotation(buf_after_rotation)

    # (5) Invertir el “shuffle SSE”:
    #     En ensamblado realmente es: out[0..15] = reverse( (in[3..18] ^ KEY) )
    out0_15 = buf_pre_loop[:16]
    in_3_18_xored = list(reversed(out0_15))
    in_3_18 = [b ^ k for b, k in zip(in_3_18_xored, KEY_00103CF0)]

    # (6) Recuperar in[0..2] desde buf[16..18]:
    #     buf[16] = in[2]^0x70, buf[17] = in[1]^0x59, buf[18]=in[0]^0x42
    in2 = buf_pre_loop[16] ^ 0x70
    in1 = buf_pre_loop[17] ^ 0x59
    in0 = buf_pre_loop[18] ^ 0x42

    unlock = bytes([in0, in1, in2] + in_3_18)
    return unlock

if __name__ == "__main__":
    code = recover_unlock()
    print(code.decode("latin1"))

```

8. Si ahora ejecutamos dicho código:
   ![[Pasted image 20260211204250.png]]
9. Introducimos dicho código en el programa.
   ![[Pasted image 20260211204330.png]]

