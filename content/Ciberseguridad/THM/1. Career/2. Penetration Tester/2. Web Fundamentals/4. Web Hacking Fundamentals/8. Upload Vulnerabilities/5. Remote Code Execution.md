RCE nos permitiría ejecutar código de manera arbitraria en el servidor. Aunque esto es más probable que pase con un usuario con bajos privilegios como `www-data`, sigue siendo una vulnerabilidad muy seria. Tiende a ser explotado subiendo un programa en el mismo lenguaje que el backend. Este solía ser PHP, sin embargo, en tiempos más modernos, otros lenguajes backend se han impuesto (como Python Django y JavaScript en forma de Node.js).

>[!IMPORTANT] En routed applications (aquellas donde las rutas de archivos son generadas dinámicamente) es más difícil para los atacantes explotar este tipo de vulnerabilidades ya que no pueden predecir el path de los archivos.

Hay dos manera principales de conseguir una RCE en un servidor web: webshells y reverse/bind shells. Idealmente, bind/reverse shells es el escenario perfecto para un atacante. Sin embargo, puede que tu única opción sea una webshell. Primero subimos el archivo y luego lo intentamos ejecutar, ya sea navegando directamente hacia él si el servidor lo permite o forzando a al app a que lo cargue.

-------------------------------------------
<h2>WebShells</h2>
Asumamos que hemos encontrado una página con un formulario de subida:

![[Pasted image 20251214170645.png]]

¿Qué hacemos ahora? Bien empezaremos con un escaneo de `gobuster`:

![[Pasted image 20251214170714.png]]

Parece que tenemos dos directorios: `uploads` y `assets`. Parece que cualquier archivo que subamos se subirá al directorio `/uploads`. Intentaremos subir la imagen del perrito de la tarea anterior.

![[Pasted image 20251214170838.png]]

![[Pasted image 20251214170845.png]]

Ahora, si vamos a `http://demo.uploadvulns.thm/uploads`, deberíamos ver que la imagen se ha subido.

![[Pasted image 20251214170922.png]]

![[Pasted image 20251214170941.png]]

Vale, podemos subir imágenes. Intentémoslo con una webshell ahora.

Sabemos que este servidor web corre con un backend PHP, por lo que podemos empezar con la creación de la shell, en un entorno real puede que tengamos que realizar más enumeración.

Una webshell simple funciona tomando un parámetro y ejecutándolo como comando de sistema. En PHP, la sintaxis sería:

```php
<?php
echo system($_GET["cmd"]);
?>
```

Este código toma el parámetro GET cmd y lo ejecuta como comando. Luego muestra el output por pantalla. Probemos a subirla y a ejecutar algún comando.

![[Pasted image 20251214171444.png]]

Ha funcionado, por lo que ahora podríamos usar esta webshell para leer archivos en el sistema o para mejorarla a una reverse shell.

>[!NOTE] Cuando tenemos una webshell, muchas veces es más legible mirar el código fuente de la página.

----------------------------------
<h2>Reverse Shells</h2>
El proceso de subir una reverse shell es casi idéntico al de subir una webshell. Usaremos la reverse shell de Pentest Monkey que viene por defecto en Kali, aunque también la puedes descargar [aquí](https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php).

Necesitas editar la línea 49, que ahora mismo dice `$ip = '127.0.0.1'; //CHANGE THIS`. Lo siguiente que debemos hacer es arrancar un listener en el puerto que elijamos.

![[Pasted image 20251214172414.png]]

Ahora subimos la shell y la activamos navegando a ella: `http://demo.uploadvulns.thm/uploads/shell.php`. El nombre de la shell será el que nosotros le pongamos (`php-reverse-shell.php` por defecto).

![[Pasted image 20251214172528.png]]

---------------------------------------
Ahora navega a `shell.uploadvulns.thm` y completa esta tarea.

1. Vamos a la página.
   ![[Pasted image 20251214175129.png]]
2. Hacemos un escaneo con `gobuster`.
   ![[Pasted image 20251214180746.png]]
   Podemos intuir que lo que subimos se está guardando en `/resources`.
3. Hacemos una webshell en php.
   ![[Pasted image 20251214180958.png]]
4. La subimos.
   ![[Pasted image 20251214181029.png]]
   ![[Pasted image 20251214181055.png]]
   Se ha subido exitosamente.
5. Navegamos hasta la shell y le metemos un comando (`whoami`) para comprobar que funciona.
   ![[Pasted image 20251214181154.png]]
6. Vamos a leer el contenido de `/var/www` con `ls /var/www`.
   ![[Pasted image 20251214181239.png]]
7. Leemos el contenido de la flag con `cat /var/www/flag.txt`.
   ![[Pasted image 20251214181319.png]]

