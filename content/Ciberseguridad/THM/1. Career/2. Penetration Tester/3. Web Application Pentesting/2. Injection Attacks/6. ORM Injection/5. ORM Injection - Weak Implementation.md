En esta tarea exploraremos cómo un atacante puede explotar vulnerabilidades ORM cuando este está implementado débilmente. Primero visitamos el sitio web.

![[Pasted image 20260116122434.png]]

Tomemos un momento para ver el código fuente usado por el desarrollador para el campo **Email (Vulnerable)**:

```php
public function searchBlindVulnerable(Request $request)
{
    $users = [];
    $email = $request->input('email');
    $users = Admins::whereRaw("email = '$email'")->get();
    if ($users) {
        return view('user', ['users' => $users]);
    } else {
        return view('user', ['message' => 'User not found']);
    }
}
```

----------------------------------------------
<h2>Lo que Hace esta Función</h2>
La función `search BlindVulnerable()` está diseñada para recuperar registros de usuarios basad en el parámetro email dado por el usuario. Aquí está un desglose detallado de la función:

- **Recuperar Input:** La función captura el parámetro `email` de la petición HTTP. Esto se hace con el método input del objeto `$request`.
- **Construir Query:** La función construye la query SQL usando el método de Laravel `whereRaw()` el cual directamente incorpora el valor email en la query SQL.
- **Ejecutar Query:** Se ejecuta la query y se guarda el valor en la variable `$users`.
- **Devolver Vista:** Finalmente, la función devuelve una vista. Si el array `$users` no está vacío, pasa la información del usuario a la vista, en otro caso pasa "**User not Found**".

El problema principal en esta función yace en el uso directo de `whereRaw()` con el input del usuario. Este método de construcción de queries es vulnerable a la inyección porque no sanitiza el input.

Un atacante puede explotar esta vulnerabilidad manipulando el parámetro email. Si un atacante introduce `1' OR '1'='1`, la query resultante se vuelve:

```sql
SELECT * FROM users WHERE email = '1' OR '1'='1';
```

Esta query siempre devuelve todos los registros de usuarios porque la condición `'1'='1'` siempre es true.

----------------------------------------------------
<h2>Explotación Detallada</h2>
- **Introducir Valor Malicioso:** El atacante introduce un payload en el campo vulnerable, por ejemplo `1' OR '1'='1'`.
- **Construir la Query:** La función `searchBlindVulnerable()` recupera este input y construye la siguiente query:

```php
$users = User::whereRaw("email = '1' OR '1'='1'")->get();
```

- **Ejecutar la Query:** Eloquent ORM de Laravel transforma esto en un statement SQL: `SELECT * FROM users WHERE email = '1' OR '1'='1';`.
- **Resultado:** Como `'1'='1'` siempre es true, la query devuelve todos los registros en la tabla users.
  ![[Pasted image 20260116125611.png]]

-------------------------------------------------
<h2>Implementar Queries ORM Seguras</h2>
Echemos un vistazo a la versión segura de la función para demostrar cómo la implementación segura puede proteger contra las vulnerabilidades de inyección ORM. Usando queries parametrizadas podemos asegurarnos de que el input del usuario esté debidamente sanitizado, reduciendo significativamente el riesgo de ataques de inyección. Aquí una implementación segura de la función vía **Email (Secure)**:

```php
public function searchBlindSecure(Request $request)
{
    $email = $request->input('email');
    $users = User::where('email', $email)->get();
    if (isset($users) && count($users) > 0) {
        return view('user', ['users' => $users]);
    } else {
        return view('user', ['message' => 'User not found']);
    }
}
```

---------------------------------------
<h2>Desglose de Implementación Segura</h2>
- **Recuperar el Input:** La función captura el parámetro email de la petición HTTP usando el método input del objeto `$request`.
- **Construir la Query de Forma Segura:** En lugar de usar `whereRaw()`, usamos la versión segura, `where()`. Este método automáticamente escapa el input previniendo la SQLi.
- **Ejecutar la Query:** Se ejecuta la query y se guarda el resultado en la variable `$users`. Debido a que la query está parametrizada, el input está sanitizado por lo que no puede romper la estructura SQL.
- **Devolver la Vista:** Finalmente la función devuelve una vista. Si el array `$users` contiene información, pasa al usuario la información a ver. Si no, muestra un mensaje de error.

Si ahora intentamos usar la misma query en el input seguro, obtendremos lo siguiente:

![[Pasted image 20260116131829.png]]

-----------------------------------------
<h2>Por qué es Esto Seguro</h2>
- **Queries Parametrizadas:** Las queries parametrizadas se aseguran de que los valores del input sean tratados sólo como datos, no código ejecutable.
- **Escape Automático:** Eloquent escapa automáticamente los valores introducidos.
- **Lógica de Query Consistente:** Usando métodos de Eloquent como `where()` la lógica de la query se mantiene clara y consistente.

