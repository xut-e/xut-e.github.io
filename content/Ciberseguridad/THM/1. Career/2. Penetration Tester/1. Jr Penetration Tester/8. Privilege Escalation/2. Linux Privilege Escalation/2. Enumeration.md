cat La enumeración es el primer paso que debes tomar una vez ganas acceso a cualquier sistema. En entornos reales, el test no acaba cuando ganas acceso al sistema.

-----------------------------------
<h2>hostname</h2>
El comando `hostname` devolverá el nombre de la máquina. Aunque este valor puede ser fácilmente cambiado o ser una string sin sentido, a veces puede ofrecer cierta información a cerca de la función en la red (por ejemplo SQL-PROD-01 para un servidor de producción SQL).

------------------------------------
<h2>uname -a</h2>
Mostrará información del sistema dándonos detalles sobre el kernel usado. Es útil cuando queremos buscar versiones vulnerables del kernel que nos lleven a una escalada de privilegios.

-----------------------------------------
<h2>/proc/version</h2>
El filesystem proc (procfs) nos ofrece información sobre los procesos del sistema objetivo. Mirar en `/proc/version` puede darte información sobre el kernel e información adicional como si un compilador está instalado.

---------------------------------------
<h2>/etc/issue</h2>
También se puede identificar sistemas mirando el archivo `/etc/issue`. Este normalmente contiene algo de información sobre el sistema operativo pero puede ser personalizado/cambiado.

------------------------------------
<h2>Comando ps</h2>
El comando `ps` es un método efectivo para ver procesos corriendo en un sistema Linux. El comando `ps` mostrará los procesos para la shell actual.

El output de `ps` (Process Status) muestra:

- **PID:** El ID del proceso (único).
- **TTY:** Tipo de terminal usada por el usuario.
- **Time:** Cantidad de tiempo de CPU usado por el proceso (no es el tiempo que lleva corriendo).
- **CMD:** Comando o archivo ejecutable corriendo.

El comando `ps` ofrece unas cuantas opciones de ayuda.

- `ps -A`: Muestra todos los procesos.
- `ps axjf`: Muestra el árbol de procesos.
- `ps aux`: La opción `aux` mostrará los procesos de todos los usuarios (a), el usuario que lanzó el proceso (u) y procesos que no están atados a la terminal (x).

-------------------------------------------------
<h2>env</h2>
El comando `env` mostrará variables de entorno (environment).

La variable PATH podría tener un compilador o lenguaje de scripting (python) que podría ser usado para ejecutar código en el sistema objetivo o para escalar privilegios.

---------------------------------------------
<h2>sudo -l</h2>
El sistema objetivo puede que haya sido configurado para permitir a los usuarios ejecutar algunos (o todos los) comandos como "root". El comando `sudo -l` lista los comandos que puedes ejecutar usando `sudo`.

--------------------------------
<h2>ls</h2>
Uno de los comandos más comunes usados en Linux es probablemente `ls`.

Al mirar potenciales vectores de escalada de privilegios, recuerda usar el comando `ls` con el parámetro `-la`. Este ejemplo de abajo muestra gráficamente por qué hacerlo.

![[Pasted image 20251126142829.png]]

--------------------------------------
<h2>id</h2>
El comando `id` ofrecerá una vista general de de los niveles del privilegio del usuario y grupos a los que pertenece.

El comando `id` puede ser usado para obtener los resultados de otro usuario.

![[Pasted image 20251126143123.png]]

-----------------------------------------------
<h2>/etc/passwd</h2>
Puede ser una manera sencilla de descubrir más usuarios en el sistema.

![[Pasted image 20251126143157.png]]

Se puede convertir fácilmente en una lista de usuarios para atacar por fuerza bruta:

`cat /etc/passwd | cut -d ":" -f 1 > users.txt`

-----------------------------------
<h2>history</h2>
Mirar comandos anteriores con el comando `history` puede darnos alguna idea sobre el sistema objetivo e incluso (aunque rara vez) tener información almacenada como usuarios o contraseñas.

-----------------------------------------
<h2>ifconfig</h2>
El sistema objetivo puede ser un punto de pivotaje hacia otra red. El comando `ipconfig` nos dará información sobre las interfaces de red en el sistema. El ejemplo de abajo muestra que el sistema objetivo tiene 3 interfaces (eth0, tun0 y tun1). Nuestra máquina atacante sólo puede alcanzar eth0 pero no las otras dos directamente (hasta ahora que hemos tomado control del sistema objetivo).

![[Pasted image 20251126184752.png]]

Esto puede confirmarse mediante el comando `iproute` que nos permite ver las rutas de red existentes.

![[Pasted image 20251126184827.png]]

-----------------------------------
<h2>netstat</h2>
Siguiendo un check inicial para interfaces y rutas de red existentes, merece la pena mirar en las comunicaciones existentes. El comando `netstat` puede usarse con diferentes opciones para recoger información en conexiones existentes.

- `netstat -a`: Muestra todos los puertos en escucha y conexiones establecidas.
- `netstat -at` o `netstat -au`: Pueden usarse para listar protocolos TCP o UDP.
- `netstat -l`: Lista puertos en modo de escucha. Puede mezclarse con la opción `-t` para listar sólo aquellos que usen el protocolo TCP.
  ![[Pasted image 20251126185408.png]]
- `netstat -s`: Lista estadísticas de uso por protocolo. También se puede combinar con las opciones `-t` o `-u` para limitar el output a un protocolo en especcífico.
- `netstat -tp`: Lista las conexiones con el nombre de servicio e información PID. Se puede combinar con `-l` para listar puertos que escuchan. Si vemos que el PID/nombre de programa está vacío (`-`), puede ser que necesitemos permisos de administrador para verlo.
- `netstat -i`: Muestra estadísticas de interfaz. En este caso eth0 y tun0 son más activas que tun1.
  ![[Pasted image 20251126185938.png]]
- `netstat -ano`: Es la opción más común. Muestra todos los sockets (a), no resuelve nombres (n), muestra timers (o).
  ![[Pasted image 20251126190122.png]]

--------------------------------------
<h2>Comando find</h2>
Buscar en el sistema cierta información o vectores de escalada puede ser complicada de forma manual. Es por esto que existen herramientas como `find`.

- `find . -name flag1.txt`: Busca en el directorio actual un archivo llamado "flag1.txt".
- `find /home -name flag1.txt`: Busca en el directorio `/home` el archivo "flag1.txt".
- `find / -type d -name config`: Busca desde la raíz (`/`) un directorio llamado config.
- `find / -type f -perm 0777`: Busca archivos con los permisos 777.
- `find / -perm a=x`: Busca archivos ejecutables.
- `find /home -user frank`: Busca todos los archivos para el usuario "frank" desde `/home`.
- `find / -mtime 10`: Busca los archivos que fueron modificados en los últimos 10 días.
- `find / -atime 10`: Busca los archivos que fueron accedidos en los últimos 10 días.
- `find / -cmin -60`: Busca archivos cambiados en la última hora.
- `find / -amin -60`: Busca archivos accedidos en la última hora.
- `find / -size 50M`: Busca archivos con un tamaño de 50 MB.  Se puede combinar con `-` o `+` para indicar que sean menores o mayores que dicho tamño.

El comando `find` puede devolver cantidades ingnetes de errores como "archivo no encontrado" o "permiso denegado". Por esto es importante redirigir la salida de errores a la papelera: `2>/dev/null`.

- `find / -writable -type d 2>/dev/null`: Busca directorios escribibles desde la raíz.
- `find / -perm -222 -type d 2>/dev/null`:  Busca directorios escribibles desde la raíz.
- `find / -perm -o w -type d 2>/dev/null`: Busca directorios escribibles desde la raíz.

![[Pasted image 20251126193900.png]]

Se usa o para otros, u para el dueño y g para grupos.

Para encontrar herramientas o lenguajes soportados:

- `find / -name perl*`
- `find / -name python*`
- `find / -name gcc*`

Para encontrar archivos con permisos específicos, como aquellos con bit SUID: `find / -perm -u=s -type f 2>/dev/null`

